import { warn as Ps, reactive as rn, watchEffect as wt, toRef as W, Fragment as pe, shallowRef as fe, capitalize as Pr, isRef as ns, isReactive as ay, isProxy as ny, toRaw as Ye, camelize as Cs, isVNode as ry, Comment as iy, unref as Y, getCurrentInstance as xs, computed as I, inject as qe, provide as ht, ref as ie, defineComponent as dt, h as Oe, watch as ce, onScopeDispose as st, effectScope as Ho, createVNode as C, normalizeStyle as be, normalizeClass as ue, toValue as ot, mergeProps as re, createElementVNode as D, onBeforeUnmount as ha, readonly as Uo, toRefs as Gm, useId as Xt, onMounted as ua, onUpdated as sy, Text as ly, Transition as sn, resolveDynamicComponent as Wo, nextTick as Ee, withDirectives as Je, toDisplayString as Ue, TransitionGroup as Go, Teleport as oy, vShow as ya, onDeactivated as uy, createElementBlock as De, openBlock as oe, withCtx as le, createCommentVNode as Ve, onRenderTriggered as cy, createBlock as ye, getCurrentScope as dy, useSlots as fy, createTextVNode as Fe, renderList as pt, markRaw as my, onBeforeMount as Cr, cloneVNode as vy, vModelText as py, mergeModels as ac, useModel as nc, renderSlot as rc, normalizeProps as Gt, guardReactiveProps as oa, onUnmounted as hy, createSlots as Yo, withModifiers as yy, withKeys as gy } from "vue";
function xr(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var el, ic;
function by() {
  return ic || (ic = 1, el = function(a) {
    if (a && a.length)
      for (const n of a) {
        let t;
        switch (n.keyword) {
          case "additionalItems":
          case "items":
            t = "";
            var r = n.params.limit;
            t += "must NOT have more than " + r + " item", r != 1 && (t += "s");
            break;
          case "additionalProperties":
            t = "must NOT have additional properties";
            break;
          case "anyOf":
            t = 'must match a schema in "anyOf"';
            break;
          case "const":
            t = "must be equal to constant";
            break;
          case "contains":
            t = "must contain a valid item";
            break;
          case "dependencies":
          case "dependentRequired":
            t = "";
            var r = n.params.depsCount;
            t += "must have propert", r == 1 ? t += "y" : t += "ies", t += " " + n.params.deps + " when property " + n.params.property + " is present";
            break;
          case "discriminator":
            switch (n.params.error) {
              case "tag":
                t = 'tag "' + n.params.tag + '" must be string';
                break;
              case "mapping":
                t = 'value of tag "' + n.params.tag + '" must be in oneOf';
                break;
              default:
                t = 'must pass "' + n.keyword + '" keyword validation';
            }
            break;
          case "enum":
            t = "must be equal to one of the allowed values";
            break;
          case "false schema":
            t = "boolean schema is false";
            break;
          case "format":
            t = 'must match format "' + n.params.format + '"';
            break;
          case "formatMaximum":
          case "formatExclusiveMaximum":
            t = "";
            var i = n.params.comparison + " " + n.params.limit;
            t += "must be " + i;
            break;
          case "formatMinimum":
          case "formatExclusiveMinimum":
            t = "";
            var i = n.params.comparison + " " + n.params.limit;
            t += "must be " + i;
            break;
          case "if":
            t = 'must match "' + n.params.failingKeyword + '" schema';
            break;
          case "maximum":
          case "exclusiveMaximum":
            t = "";
            var i = n.params.comparison + " " + n.params.limit;
            t += "must be " + i;
            break;
          case "maxItems":
            t = "";
            var r = n.params.limit;
            t += "must NOT have more than " + r + " item", r != 1 && (t += "s");
            break;
          case "maxLength":
            t = "";
            var r = n.params.limit;
            t += "must NOT be longer than " + r + " character", r != 1 && (t += "s");
            break;
          case "maxProperties":
            t = "";
            var r = n.params.limit;
            t += "must NOT have more than " + r + " propert", r == 1 ? t += "y" : t += "ies";
            break;
          case "minimum":
          case "exclusiveMinimum":
            t = "";
            var i = n.params.comparison + " " + n.params.limit;
            t += "must be " + i;
            break;
          case "minItems":
            t = "";
            var r = n.params.limit;
            t += "must NOT have less than " + r + " item", r != 1 && (t += "s");
            break;
          case "minLength":
            t = "";
            var r = n.params.limit;
            t += "must NOT be shorter than " + r + " character", r != 1 && (t += "s");
            break;
          case "minProperties":
            t = "";
            var r = n.params.limit;
            t += "must NOT have less than " + r + " propert", r == 1 ? t += "y" : t += "ies";
            break;
          case "multipleOf":
            t = "must be a multiple of " + n.params.multipleOf;
            break;
          case "not":
            t = 'must NOT be valid according to schema in "not"';
            break;
          case "oneOf":
            t = 'must match exactly one schema in "oneOf"';
            break;
          case "pattern":
            t = 'must match pattern "' + n.params.pattern + '"';
            break;
          case "patternRequired":
            t = 'must have property matching pattern "' + n.params.missingPattern + '"';
            break;
          case "propertyNames":
            t = "property name is invalid";
            break;
          case "required":
            t = "must have required property " + n.params.missingProperty;
            break;
          case "type":
            t = "must be " + n.params.type;
            break;
          case "unevaluatedItems":
            t = "";
            var r = n.params.len;
            t += "must NOT have more than " + r + " item", r != 1 && (t += "s");
            break;
          case "unevaluatedProperties":
            t = "must NOT have unevaluated properties";
            break;
          case "uniqueItems":
            t = "must NOT have duplicate items (items ## " + n.params.j + " and " + n.params.i + " are identical)";
            break;
          default:
            t = 'must pass "' + n.keyword + '" keyword validation';
        }
        n.message = t;
      }
  }), el;
}
var tl, sc;
function ky() {
  return sc || (sc = 1, tl = function(a) {
    if (a && a.length)
      for (const n of a) {
        let t;
        switch (n.keyword) {
          case "additionalItems":
          case "items":
            t = "";
            var r = n.params.limit;
            t += " يجب أن لا يحوي أكثر من " + r + " عنصر";
            break;
          case "additionalProperties":
            t = "يجب أن لا يحوي خصائص إضافية";
            break;
          case "anyOf":
            t = 'يجب أن يوافق أحد المخططات الموجودة في "anyOf"';
            break;
          case "const":
            t = "يجب أن يكون ثابتاً";
            break;
          case "contains":
            t = "يجب أن يحوي عنصرا صحيح";
            break;
          case "dependencies":
          case "dependentRequired":
            t = "";
            var r = n.params.depsCount;
            t += " يجب أن يحوي الخصائص " + n.params.deps + " عندما تكون الخاصية " + n.params.property + " موجودة";
            break;
          case "discriminator":
            switch (n.params.error) {
              case "tag":
                t = 'tag "' + n.params.tag + '" must be string';
                break;
              case "mapping":
                t = 'value of tag "' + n.params.tag + '" must be in oneOf';
                break;
              default:
                t = 'يجب أن تمرر كلمة التحقق المفتاحية "' + n.keyword + '"';
            }
            break;
          case "enum":
            t = "قيمة هذا الحقل يجب أن تكون مساوية لأحد القيم المعرفة مسبقاً";
            break;
          case "false schema":
            t = "المخطط المنطقي غير صحيح";
            break;
          case "format":
            t = 'يجب أن يوافق الصيغة "' + n.params.format + '"';
            break;
          case "formatMaximum":
          case "formatExclusiveMaximum":
            t = "";
            var i = n.params.comparison + " " + n.params.limit;
            t += " يجب أن يكون " + i;
            break;
          case "formatMinimum":
          case "formatExclusiveMinimum":
            t = "";
            var i = n.params.comparison + " " + n.params.limit;
            t += " يجب أن يكون " + i;
            break;
          case "if":
            t = 'يجب أن توافق المخطط "' + n.params.failingKeyword + '"';
            break;
          case "maximum":
          case "exclusiveMaximum":
            t = "";
            var i = n.params.comparison + " " + n.params.limit;
            t += " يجب أن يكون " + i;
            break;
          case "maxItems":
            t = "";
            var r = n.params.limit;
            t += " يجب أن لا يحوي أكثر من " + r + " عنصر";
            break;
          case "maxLength":
            t = "";
            var r = n.params.limit;
            t += " يجب أن لا يحوي أكثر من " + r + " محرف";
            break;
          case "maxProperties":
            t = "";
            var r = n.params.limit;
            t += " يجب أن لا يحوي أكثر من " + r + " خصائص";
            break;
          case "minimum":
          case "exclusiveMinimum":
            t = "";
            var i = n.params.comparison + " " + n.params.limit;
            t += " يجب أن يكون " + i;
            break;
          case "minItems":
            t = "";
            var r = n.params.limit;
            t += " يجب أن لا يحوي أقل من " + r + " عنصر";
            break;
          case "minLength":
            t = "";
            var r = n.params.limit;
            t += " يجب أن لا يحوي أقل من " + r + " محرف";
            break;
          case "minProperties":
            t = "";
            var r = n.params.limit;
            t += " يجب أن لا يحوي أقل من " + r + " خصائص";
            break;
          case "multipleOf":
            t = " يجب أن يحوي أكثر من " + n.params.multipleOf;
            break;
          case "not":
            t = 'يجب أن يكون غير صحيح وفقاً للمخطط "not"';
            break;
          case "oneOf":
            t = 'يجب أن يوافق مخطط واحد فقط موجود في "oneOf"';
            break;
          case "pattern":
            t = 'يجب أن يوافق النمط "' + n.params.pattern + '"';
            break;
          case "patternRequired":
            t = 'يجب أن يحوي خاصية توافق النمط "' + n.params.missingPattern + '"';
            break;
          case "propertyNames":
            t = "اسم الخاصية غير صالح";
            break;
          case "required":
            t = "هذا الحقل إلزامي";
            break;
          case "type":
            t = "قيمة هذا الحقل غير صالحة";
            break;
          case "unevaluatedItems":
            t = "";
            var r = n.params.len;
            t += "must NOT have more than " + r + " item", r != 1 && (t += "s");
            break;
          case "unevaluatedProperties":
            t = "must NOT have unevaluated properties";
            break;
          case "uniqueItems":
            t = "يجب أن لا يحوي عناصر مكررة (العنصر ## " + n.params.j + " و " + n.params.i + " متطابقة)";
            break;
          default:
            t = 'يجب أن تمرر كلمة التحقق المفتاحية "' + n.keyword + '"';
        }
        n.message = t;
      }
  }), tl;
}
var al, lc;
function wy() {
  return lc || (lc = 1, al = function(a) {
    if (a && a.length)
      for (const n of a) {
        let t;
        switch (n.keyword) {
          case "additionalItems":
          case "items":
            t = "";
            var r = n.params.limit;
            t += "no ha de tenir més de " + r + " element", r != 1 && (t += "s");
            break;
          case "additionalProperties":
            t = "no ha de tenir propietats addicionals";
            break;
          case "anyOf":
            t = 'ha de coincidir amb algun esquema definit a "anyOf"';
            break;
          case "const":
            t = "ha de ser igual a la constant";
            break;
          case "contains":
            t = "ha de contenir un ítem vàlid";
            break;
          case "dependencies":
          case "dependentRequired":
            t = "";
            var r = n.params.depsCount;
            t += "ha de contenir la propietat", r != 1 && (t += "s"), t += " " + n.params.deps + " quan la propietat " + n.params.property + " és present";
            break;
          case "discriminator":
            switch (n.params.error) {
              case "tag":
                t = 'tag "' + n.params.tag + '" must be string';
                break;
              case "mapping":
                t = 'value of tag "' + n.params.tag + '" must be in oneOf';
                break;
              default:
                t = 'ha de passar la validació de la clau "' + n.keyword + '"';
            }
            break;
          case "enum":
            t = "ha de ser igual a un dels valors predefinits";
            break;
          case "false schema":
            t = "l’esquema és fals";
            break;
          case "format":
            t = 'ha de coincidir amb el format "' + n.params.format + '"';
            break;
          case "formatMaximum":
          case "formatExclusiveMaximum":
            t = "";
            var i = n.params.comparison + " " + n.params.limit;
            t += "ha de ser " + i;
            break;
          case "formatMinimum":
          case "formatExclusiveMinimum":
            t = "";
            var i = n.params.comparison + " " + n.params.limit;
            t += "ha de ser " + i;
            break;
          case "if":
            t = 'ha de correspondre’s amb l’esquema "' + n.params.failingKeyword + '"';
            break;
          case "maximum":
          case "exclusiveMaximum":
            t = "";
            var i = n.params.comparison + " " + n.params.limit;
            t += "ha de ser " + i;
            break;
          case "maxItems":
            t = "";
            var r = n.params.limit;
            t += "no ha de tenir més de " + r + " ítem", r != 1 && (t += "s");
            break;
          case "maxLength":
            t = "";
            var r = n.params.limit;
            t += "no pot contenir més de " + r + " caràcter", r != 1 && (t += "s");
            break;
          case "maxProperties":
            t = "";
            var r = n.params.limit;
            t += "no pot contenir més de " + r + " propietat", r != 1 && (t += "s");
            break;
          case "minimum":
          case "exclusiveMinimum":
            t = "";
            var i = n.params.comparison + " " + n.params.limit;
            t += "ha de ser " + i;
            break;
          case "minItems":
            t = "";
            var r = n.params.limit;
            t += "no ha de tenir menys de " + r + " ítem", r != 1 && (t += "s");
            break;
          case "minLength":
            t = "";
            var r = n.params.limit;
            t += "no pot contenir menys de " + r + " caràcter", r != 1 && (t += "s");
            break;
          case "minProperties":
            t = "";
            var r = n.params.limit;
            t += "no pot contenir menys de " + r + " propietat", r != 1 && (t += "s");
            break;
          case "multipleOf":
            t = "ha de ser múltiple de " + n.params.multipleOf;
            break;
          case "not":
            t = 'no ha de ser vàlid d’acord amb l’esquema definit a "not"';
            break;
          case "oneOf":
            t = 'ha de coincidir només amb un esquema definit a "oneOf"';
            break;
          case "pattern":
            t = 'ha de coincidir amb el patró "' + n.params.pattern + '"';
            break;
          case "patternRequired":
            t = 'la propietat ha de coincidir amb el patró "' + n.params.missingPattern + '"';
            break;
          case "propertyNames":
            t = "la propietat no és vàlida";
            break;
          case "required":
            t = "ha de tenir la propietat requerida " + n.params.missingProperty;
            break;
          case "type":
            t = "ha de ser del tipus " + n.params.type;
            break;
          case "unevaluatedItems":
            t = "";
            var r = n.params.len;
            t += "must NOT have more than " + r + " item", r != 1 && (t += "s");
            break;
          case "unevaluatedProperties":
            t = "must NOT have unevaluated properties";
            break;
          case "uniqueItems":
            t = "no ha de tenir ítems duplicats (els ítems ## " + n.params.j + " i " + n.params.i + " són idèntics)";
            break;
          default:
            t = 'ha de passar la validació de la clau "' + n.keyword + '"';
        }
        n.message = t;
      }
  }), al;
}
var nl, oc;
function Sy() {
  return oc || (oc = 1, nl = function(a) {
    if (a && a.length)
      for (const n of a) {
        let t;
        switch (n.keyword) {
          case "additionalItems":
          case "items":
            t = "";
            var r = n.params.limit;
            t += "nemůže mít víc, než " + r + " prv", r >= 2 && r <= 4 ? t += "ky" : r != 1 ? t += "ek" : t += "ků";
            break;
          case "additionalProperties":
            t = "nemůže mít další položky";
            break;
          case "anyOf":
            t = 'musí vyhovět alespoň jednomu schématu v "anyOf"';
            break;
          case "const":
            t = "musí být roven konstantě";
            break;
          case "contains":
            t = "musí obsahovat prvek odpovídající schématu";
            break;
          case "dependencies":
          case "dependentRequired":
            t = "";
            var r = n.params.depsCount;
            t += "musí mít polož", r >= 2 && r <= 4 ? t += "ky" : r != 1 ? t += "ek" : t += "ka", t += ": " + n.params.deps + ", pokud obsahuje " + n.params.property;
            break;
          case "discriminator":
            switch (n.params.error) {
              case "tag":
                t = 'tag "' + n.params.tag + '" must be string';
                break;
              case "mapping":
                t = 'value of tag "' + n.params.tag + '" must be in oneOf';
                break;
              default:
                t = 'musí vyhovět "' + n.keyword + '" validaci';
            }
            break;
          case "enum":
            t = "musí být rovno jedné hodnotě z výčtu";
            break;
          case "false schema":
            t = "schéma je false";
            break;
          case "format":
            t = 'musí být ve formátu "' + n.params.format + '"';
            break;
          case "formatMaximum":
          case "formatExclusiveMaximum":
            t = "";
            var i = n.params.comparison + " " + n.params.limit;
            t += "musí být " + i;
            break;
          case "formatMinimum":
          case "formatExclusiveMinimum":
            t = "";
            var i = n.params.comparison + " " + n.params.limit;
            t += "musí být " + i;
            break;
          case "if":
            t = 'musí vyhovět "' + n.params.failingKeyword + '" schématu';
            break;
          case "maximum":
          case "exclusiveMaximum":
            t = "";
            var i = n.params.comparison + " " + n.params.limit;
            t += "musí být " + i;
            break;
          case "maxItems":
            t = "";
            var r = n.params.limit;
            t += "nesmí obsahovat víc než " + r + " prv", r >= 2 && r <= 4 ? t += "ky" : r != 1 ? t += "ek" : t += "ků";
            break;
          case "maxLength":
            t = "";
            var r = n.params.limit;
            t += "nesmí být delší než " + r + " zna", r >= 2 && r <= 4 ? t += "ky" : r != 1 ? t += "k" : t += "ků";
            break;
          case "maxProperties":
            t = "";
            var r = n.params.limit;
            t += "nesmí mít víc než " + r + " polož", r >= 2 && r <= 4 ? t += "ky" : r != 1 ? t += "ek" : t += "ka";
            break;
          case "minimum":
          case "exclusiveMinimum":
            t = "";
            var i = n.params.comparison + " " + n.params.limit;
            t += "musí být " + i;
            break;
          case "minItems":
            t = "";
            var r = n.params.limit;
            t += "nesmí obsahovat méně než " + r + " prv", r >= 2 && r <= 4 ? t += "ky" : r != 1 ? t += "ek" : t += "ků";
            break;
          case "minLength":
            t = "";
            var r = n.params.limit;
            t += "nesmí být kratší než " + r + " zna", r >= 2 && r <= 4 ? t += "ky" : r != 1 ? t += "k" : t += "ků";
            break;
          case "minProperties":
            t = "";
            var r = n.params.limit;
            t += "nesmí mít méně než " + r + " polož", r >= 2 && r <= 4 ? t += "ky" : r != 1 ? t += "ek" : t += "ka";
            break;
          case "multipleOf":
            t = "musí být násobkem " + n.params.multipleOf;
            break;
          case "not":
            t = 'nesmí vyhovět schématu v "not"';
            break;
          case "oneOf":
            t = 'musí vyhovět právě jednomu schématu v "oneOf"';
            break;
          case "pattern":
            t = 'musí vyhovět regulárnímu výrazu "' + n.params.pattern + '"';
            break;
          case "patternRequired":
            t = 'musí obsahovat položku vyhovující regulárnímu výrazu "' + n.params.missingPattern + '"';
            break;
          case "propertyNames":
            t = "název položky není platný";
            break;
          case "required":
            t = "musí obsahovat požadovanou položku " + n.params.missingProperty;
            break;
          case "type":
            t = "musí být " + n.params.type;
            break;
          case "unevaluatedItems":
            t = "";
            var r = n.params.len;
            t += "must NOT have more than " + r + " item", r != 1 && (t += "s");
            break;
          case "unevaluatedProperties":
            t = "must NOT have unevaluated properties";
            break;
          case "uniqueItems":
            t = "nesmí obsahovat duplicitní prvky (prvky ## " + n.params.j + " a " + n.params.i + " jsou identické)";
            break;
          default:
            t = 'musí vyhovět "' + n.keyword + '" validaci';
        }
        n.message = t;
      }
  }), nl;
}
var rl, uc;
function $y() {
  return uc || (uc = 1, rl = function(a) {
    if (a && a.length)
      for (const n of a) {
        let t;
        switch (n.keyword) {
          case "additionalItems":
          case "items":
            t = "";
            var r = n.params.limit;
            t += "darf nicht mehr als " + r + " Element", r != 1 && (t += "e"), t += " enthalten";
            break;
          case "additionalProperties":
            t = "darf keine zusätzlichen Attribute haben";
            break;
          case "anyOf":
            t = 'muss einem der Schemata in "anyOf" entsprechen';
            break;
          case "const":
            t = "muss gleich der Konstanten sein";
            break;
          case "contains":
            t = "muss ein valides Element enthalten";
            break;
          case "dependencies":
          case "dependentRequired":
            t = "";
            var r = n.params.depsCount;
            t += "muss Attribut", r != 1 && (t += "e"), t += " " + n.params.deps + " aufweisen, wenn Attribut " + n.params.property + " gesetzt ist";
            break;
          case "discriminator":
            switch (n.params.error) {
              case "tag":
                t = 'der Tag "' + n.params.tag + '" muss eine Zeichenkette sein';
                break;
              case "mapping":
                t = 'der Wert vom Tag "' + n.params.tag + '" muss im oneOf enthalten sein';
                break;
              default:
                t = 'muss die Validierung "' + n.keyword + '" bestehen';
            }
            break;
          case "enum":
            t = "muss einem der vorgegebenen Werte entsprechen";
            break;
          case "false schema":
            t = "boolesches Schema ist falsch";
            break;
          case "format":
            t = 'muss diesem Format entsprechen: "' + n.params.format + '"';
            break;
          case "formatMaximum":
          case "formatExclusiveMaximum":
            t = "";
            var i = n.params.comparison + " " + n.params.limit;
            t += "muss " + i + " sein";
            break;
          case "formatMinimum":
          case "formatExclusiveMinimum":
            t = "";
            var i = n.params.comparison + " " + n.params.limit;
            t += "muss " + i + " sein";
            break;
          case "if":
            t = 'muss dem Schema "' + n.params.failingKeyword + '" entsprechen';
            break;
          case "maximum":
          case "exclusiveMaximum":
            t = "";
            var i = n.params.comparison + " " + n.params.limit;
            t += "muss " + i + " sein";
            break;
          case "maxItems":
            t = "";
            var r = n.params.limit;
            t += "darf nicht mehr als " + r + " Element", r != 1 && (t += "e"), t += " haben";
            break;
          case "maxLength":
            t = "";
            var r = n.params.limit;
            t += "darf nicht länger als " + r + " Zeichen sein";
            break;
          case "maxProperties":
            t = "";
            var r = n.params.limit;
            t += "darf nicht mehr als " + r + " Attribut", r != 1 && (t += "e"), t += " haben";
            break;
          case "minimum":
          case "exclusiveMinimum":
            t = "";
            var i = n.params.comparison + " " + n.params.limit;
            t += "muss " + i + " sein";
            break;
          case "minItems":
            t = "";
            var r = n.params.limit;
            t += "darf nicht weniger als " + r + " Element", r != 1 && (t += "e"), t += " haben";
            break;
          case "minLength":
            t = "";
            var r = n.params.limit;
            t += "darf nicht kürzer als " + r + " Zeichen sein";
            break;
          case "minProperties":
            t = "";
            var r = n.params.limit;
            t += "darf nicht weniger als " + r + " Attribut", r != 1 && (t += "e"), t += " haben";
            break;
          case "multipleOf":
            t = "muss ein Vielfaches von " + n.params.multipleOf + " sein";
            break;
          case "not":
            t = 'muss dem in "not" angegebenen Schema widersprechen';
            break;
          case "oneOf":
            t = 'muss genau einem der Schemata in "oneOf" entsprechen';
            break;
          case "pattern":
            t = 'muss diesem Muster entsprechen: "' + n.params.pattern + '"';
            break;
          case "patternRequired":
            t = 'muss ein Attribut nach folgendem Muster haben "' + n.params.missingPattern + '"';
            break;
          case "propertyNames":
            t = "Attributname ist ungültig";
            break;
          case "required":
            t = "muss das erforderliche Attribut " + n.params.missingProperty + " enthalten";
            break;
          case "type":
            t = "muss sein: " + n.params.type;
            break;
          case "unevaluatedItems":
            t = "";
            var r = n.params.len;
            t += "darf nicht mehr als " + r + " Element", r != 1 && (t += "e"), t += " haben";
            break;
          case "unevaluatedProperties":
            t = "darf keine unausgewerteten Attribute haben";
            break;
          case "uniqueItems":
            t = "darf keine Duplikate enthalten (Elemente #" + n.params.j + " und #" + n.params.i + " sind gleich)";
            break;
          default:
            t = 'muss die Validierung "' + n.keyword + '" bestehen';
        }
        n.message = t;
      }
  }), rl;
}
var il, cc;
function _y() {
  return cc || (cc = 1, il = function(a) {
    if (a && a.length)
      for (const n of a) {
        let t;
        switch (n.keyword) {
          case "additionalItems":
          case "items":
            t = "";
            var r = n.params.limit;
            t += "no debe tener más de " + r + " elemento", r != 1 && (t += "s");
            break;
          case "additionalProperties":
            t = "no debe tener propiedades adicionales";
            break;
          case "anyOf":
            t = 'debe coincidir con algún esquema en "anyOf"';
            break;
          case "const":
            t = "debe ser igual a la constante";
            break;
          case "contains":
            t = "debe contener un elemento válido";
            break;
          case "dependencies":
          case "dependentRequired":
            t = "";
            var r = n.params.depsCount;
            t += "debe contener la", r != 1 && (t += "s"), t += " propiedad", r != 1 && (t += "es"), t += " " + n.params.deps + " cuando la propiedad " + n.params.property + " se encuentra presente";
            break;
          case "discriminator":
            switch (n.params.error) {
              case "tag":
                t = 'tag "' + n.params.tag + '" must be string';
                break;
              case "mapping":
                t = 'value of tag "' + n.params.tag + '" must be in oneOf';
                break;
              default:
                t = 'debe pasar la validación de palabra clave "' + n.keyword + '"';
            }
            break;
          case "enum":
            t = "deber ser igual a uno de los valores predefinidos";
            break;
          case "false schema":
            t = "el esquema és falso";
            break;
          case "format":
            t = 'debe coincidir con el formato "' + n.params.format + '"';
            break;
          case "formatMaximum":
          case "formatExclusiveMaximum":
            t = "";
            var i = n.params.comparison + " " + n.params.limit;
            t += "debe ser " + i;
            break;
          case "formatMinimum":
          case "formatExclusiveMinimum":
            t = "";
            var i = n.params.comparison + " " + n.params.limit;
            t += "debe ser " + i;
            break;
          case "if":
            t = 'debe corresponderse con el esquema "' + n.params.failingKeyword + '"';
            break;
          case "maximum":
          case "exclusiveMaximum":
            t = "";
            var i = n.params.comparison + " " + n.params.limit;
            t += "debe ser " + i;
            break;
          case "maxItems":
            t = "";
            var r = n.params.limit;
            t += "no debe contener más de " + r + " elemento", r != 1 && (t += "s");
            break;
          case "maxLength":
            t = "";
            var r = n.params.limit;
            t += "no debe contener más de " + r + " caracter", r != 1 && (t += "es");
            break;
          case "maxProperties":
            t = "";
            var r = n.params.limit;
            t += "no debe contener más de " + r + " propiedad", r != 1 && (t += "es");
            break;
          case "minimum":
          case "exclusiveMinimum":
            t = "";
            var i = n.params.comparison + " " + n.params.limit;
            t += "debe ser " + i;
            break;
          case "minItems":
            t = "";
            var r = n.params.limit;
            t += "no debe contener menos de " + r + " elemento", r != 1 && (t += "s");
            break;
          case "minLength":
            t = "";
            var r = n.params.limit;
            t += "no debe contener menos de " + r + " caracter", r != 1 && (t += "es");
            break;
          case "minProperties":
            t = "";
            var r = n.params.limit;
            t += "no debe contener menos de " + r + " propiedad", r != 1 && (t += "es");
            break;
          case "multipleOf":
            t = "debe ser múltiplo de " + n.params.multipleOf;
            break;
          case "not":
            t = 'no debe ser válido según el esquema en "not"';
            break;
          case "oneOf":
            t = 'debe coincidir con un solo esquema en "oneOf"';
            break;
          case "pattern":
            t = 'debe coincidir con el patron "' + n.params.pattern + '"';
            break;
          case "patternRequired":
            t = 'la propiedad debe coincidir con el patrón "' + n.params.missingPattern + '"';
            break;
          case "propertyNames":
            t = "la propiedad no és válida";
            break;
          case "required":
            t = "debe tener la propiedad requerida " + n.params.missingProperty;
            break;
          case "type":
            t = "debe ser " + n.params.type;
            break;
          case "unevaluatedItems":
            t = "";
            var r = n.params.len;
            t += "must NOT have more than " + r + " item", r != 1 && (t += "s");
            break;
          case "unevaluatedProperties":
            t = "must NOT have unevaluated properties";
            break;
          case "uniqueItems":
            t = "no debe contener elementos duplicados, (los elementos ## " + n.params.j + " y " + n.params.i + " son idénticos)";
            break;
          default:
            t = 'debe pasar la validación de palabra clave "' + n.keyword + '"';
        }
        n.message = t;
      }
  }), il;
}
var sl, dc;
function Py() {
  return dc || (dc = 1, sl = function(a) {
    if (a && a.length)
      for (const t of a) {
        let s;
        switch (t.keyword) {
          case "additionalItems":
          case "items":
            s = "";
            var n = t.params.limit;
            s += "saa sisältää enintään " + n, n == 1 ? s += ":n elementin" : s += " elementtiä";
            break;
          case "additionalProperties":
            s = "ei saa sisältää ylimääräisiä ominaisuuksia";
            break;
          case "anyOf":
            s = 'täytyy vastata "anyOf" skeemaa';
            break;
          case "const":
            s = "täytyy olla yhtä kuin vakio";
            break;
          case "contains":
            s = "täytyy sisältää kelvollinen elementti";
            break;
          case "dependencies":
          case "dependentRequired":
            s = "";
            var n = t.params.depsCount;
            s += "täytyy sisältää " + t.params.deps + " ominaisuu", n == 1 ? s += "s" : s += "det", s += " kun " + t.params.property + "-ominaisuus on läsnä";
            break;
          case "discriminator":
            switch (t.params.error) {
              case "tag":
                s = 'tunniste "' + t.params.tag + '" täytyy olla merkkijono';
                break;
              case "mapping":
                s = 'tunnisteen "' + t.params.tag + '" arvon muoto pitää olla oneOf';
                break;
              default:
                s = 'täytyy läpäistä "' + t.keyword + '" avainsanatarkistus';
            }
            break;
          case "enum":
            s = "täytyy olla yhtä kuin jokin sallituista arvoista";
            break;
          case "false schema":
            s = "boolean skeema on väärä";
            break;
          case "format":
            s = 'täytyy vastata muotoa "' + t.params.format + '"';
            break;
          case "formatMaximum":
          case "formatExclusiveMaximum":
            s = "";
            var i = t.params.comparison + " " + t.params.limit;
            s += "täytyy olla " + i;
            break;
          case "formatMinimum":
          case "formatExclusiveMinimum":
            s = "";
            var i = t.params.comparison + " " + t.params.limit;
            s += "täytyy olla " + i;
            break;
          case "if":
            s = 'täytyy vastata "' + t.params.failingKeyword + '" skeemaa';
            break;
          case "maximum":
          case "exclusiveMaximum":
            s = "";
            var i = t.params.comparison + " " + t.params.limit;
            s += "täytyy olla " + i;
            break;
          case "maxItems":
            s = "";
            var n = t.params.limit;
            s += "tulee sisältää enintään " + n + " ", n == 1 ? s += "elementti" : s += "elementtiä";
            break;
          case "maxLength":
            s = "";
            var n = t.params.limit;
            s += "ei saa olla pidempi kuin " + n + " merkki", n != 1 && (s += "ä");
            break;
          case "maxProperties":
            s = "";
            var n = t.params.limit;
            s += "tulee sisältää enintään " + n + " ", n == 1 ? s += "ominaisuus" : s += "ominaisuutta";
            break;
          case "minimum":
          case "exclusiveMinimum":
            s = "";
            var i = t.params.comparison + " " + t.params.limit;
            s += "täytyy olla " + i;
            break;
          case "minItems":
            s = "";
            var n = t.params.limit;
            s += "tulee sisältää vähintään " + n + " ", n == 1 ? s += "elementti" : s += "elementtiä";
            break;
          case "minLength":
            s = "";
            var n = t.params.limit;
            s += "ei saa olla lyhyempi kuin " + n + " merkki", n != 1 && (s += "ä");
            break;
          case "minProperties":
            s = "";
            var n = t.params.limit;
            s += "tulee sisältää vähintään " + n + " ", n == 1 ? s += "ominaisuus" : s += "ominaisuutta";
            break;
          case "multipleOf":
            s = "täytyy olla moninkertainen: " + t.params.multipleOf;
            break;
          case "not":
            s = 'ei saa olla hyväksytty skeeman "not" mukaan';
            break;
          case "oneOf":
            s = 'täytyy vastata täsmälleen yhtä "oneOf" -kohdassa määriteltyä skeemaa';
            break;
          case "pattern":
            s = 'täytyy vastata muotoa "' + t.params.pattern + '"';
            break;
          case "patternRequired":
            s = 'täytyy sisältää ominaisuus joka vastaa kaavaa "' + t.params.missingPattern + '"';
            break;
          case "propertyNames":
            s = "ominaisuuden nimi on virheellinen";
            break;
          case "required":
            s = "täytyy sisältää vaadittu ominaisuus " + t.params.missingProperty;
            break;
          case "type":
            s = "";
            var r = t.params.type;
            s += "täytyy olla ", r == "number" ? s += "numero" : r == "integer" ? s += "kokonaisluku" : r == "string" ? s += "merkkijono" : r == "boolean" ? s += "boolean" : s += r;
            break;
          case "unevaluatedItems":
            s = "";
            var n = t.params.len;
            s += "ei saa olla enemmän kuin " + n + " elementti", n != 1 && (s += "ä");
            break;
          case "unevaluatedProperties":
            s = "ei saa sisältää arvioimattomia ominaisuuksia";
            break;
          case "uniqueItems":
            s = "ei saa sisältää duplikaatteja (elementit ## " + t.params.j + " ja " + t.params.i + " ovat identtiset)";
            break;
          default:
            s = 'täytyy läpäistä "' + t.keyword + '" avainsanatarkistus';
        }
        t.message = s;
      }
  }), sl;
}
var ll, fc;
function Cy() {
  return fc || (fc = 1, ll = function(a) {
    if (a && a.length)
      for (const n of a) {
        let t;
        switch (n.keyword) {
          case "additionalItems":
          case "items":
            t = "";
            var r = n.params.limit;
            t += "ne doit pas contenir plus de " + r + " élémént", r != 1 && (t += "s");
            break;
          case "additionalProperties":
            t = "ne doit pas contenir de propriétés additionnelles";
            break;
          case "anyOf":
            t = 'doit correspondre à un schéma de "anyOf"';
            break;
          case "const":
            t = "doit être égal à la constante";
            break;
          case "contains":
            t = "doit contenir un élément valide";
            break;
          case "dependencies":
          case "dependentRequired":
            t = "";
            var r = n.params.depsCount;
            t += "doit avoir la propriété " + n.params.deps + " quand la propriété " + n.params.property + " est présente";
            break;
          case "discriminator":
            switch (n.params.error) {
              case "tag":
                t = 'tag "' + n.params.tag + '" must be string';
                break;
              case "mapping":
                t = 'value of tag "' + n.params.tag + '" must be in oneOf';
                break;
              default:
                t = 'doit être valide selon le critère "' + n.keyword + '"';
            }
            break;
          case "enum":
            t = "doit être égal à une des valeurs prédéfinies";
            break;
          case "false schema":
            t = 'le schema est "false"';
            break;
          case "format":
            t = 'doit correspondre au format "' + n.params.format + '"';
            break;
          case "formatMaximum":
          case "formatExclusiveMaximum":
            t = "";
            var i = n.params.comparison + " " + n.params.limit;
            t += "doit être " + i;
            break;
          case "formatMinimum":
          case "formatExclusiveMinimum":
            t = "";
            var i = n.params.comparison + " " + n.params.limit;
            t += "doit être " + i;
            break;
          case "if":
            t = 'doit correspondre au schéma "' + n.params.failingKeyword + '"';
            break;
          case "maximum":
          case "exclusiveMaximum":
            t = "";
            var i = n.params.comparison + " " + n.params.limit;
            t += "doit être " + i;
            break;
          case "maxItems":
            t = "";
            var r = n.params.limit;
            t += "ne doit pas contenir plus de " + r + " élément", r != 1 && (t += "s");
            break;
          case "maxLength":
            t = "";
            var r = n.params.limit;
            t += "ne doit pas dépasser " + r + " caractère", r != 1 && (t += "s");
            break;
          case "maxProperties":
            t = "";
            var r = n.params.limit;
            t += "ne doit pas contenir plus de " + r + " propriété", r != 1 && (t += "s");
            break;
          case "minimum":
          case "exclusiveMinimum":
            t = "";
            var i = n.params.comparison + " " + n.params.limit;
            t += "doit être " + i;
            break;
          case "minItems":
            t = "";
            var r = n.params.limit;
            t += "ne doit pas contenir moins de " + r + " élément", r != 1 && (t += "s");
            break;
          case "minLength":
            t = "";
            var r = n.params.limit;
            t += "ne doit pas faire moins de " + r + " caractère", r != 1 && (t += "s");
            break;
          case "minProperties":
            t = "";
            var r = n.params.limit;
            t += "ne doit pas contenir moins de " + r + " propriété", r != 1 && (t += "s");
            break;
          case "multipleOf":
            t = "doit être un multiple de " + n.params.multipleOf;
            break;
          case "not":
            t = 'est invalide selon le schéma "not"';
            break;
          case "oneOf":
            t = 'doit correspondre à exactement un schéma de "oneOf"';
            break;
          case "pattern":
            t = 'doit correspondre au format "' + n.params.pattern + '"';
            break;
          case "patternRequired":
            t = 'la propriété doit correspondre au format "' + n.params.missingPattern + '"';
            break;
          case "propertyNames":
            t = "le nom de propriété est invalide";
            break;
          case "required":
            t = "requiert la propriété " + n.params.missingProperty;
            break;
          case "type":
            t = "doit être de type " + n.params.type;
            break;
          case "unevaluatedItems":
            t = "";
            var r = n.params.len;
            t += "must NOT have more than " + r + " item", r != 1 && (t += "s");
            break;
          case "unevaluatedProperties":
            t = "must NOT have unevaluated properties";
            break;
          case "uniqueItems":
            t = "ne doit pas contenir de doublons (les éléments ## " + n.params.j + " et " + n.params.i + " sont identiques)";
            break;
          default:
            t = 'doit être valide selon le critère "' + n.keyword + '"';
        }
        n.message = t;
      }
  }), ll;
}
var ol, mc;
function xy() {
  return mc || (mc = 1, ol = function(a) {
    if (a && a.length)
      for (const n of a) {
        let t;
        switch (n.keyword) {
          case "additionalItems":
          case "items":
            t = "";
            var r = n.params.limit;
            t += "nem lehet több, mint " + r + " eleme";
            break;
          case "additionalProperties":
            t = "nem lehetnek további elemei";
            break;
          case "anyOf":
            t = 'meg kell feleljen legalább egy "anyOf" alaknak';
            break;
          case "const":
            t = "must be equal to constant";
            break;
          case "contains":
            t = "must contain a valid item";
            break;
          case "dependencies":
          case "dependentRequired":
            t = "";
            var r = n.params.depsCount;
            t += "-nak kell legyen", r > 1 && (t += "ek"), t += " a következő tulajdonsága", r != 1 && (t += "i"), t += ": " + n.params.deps + ", ha van " + n.params.property + " tulajdonsága";
            break;
          case "discriminator":
            switch (n.params.error) {
              case "tag":
                t = 'tag "' + n.params.tag + '" must be string';
                break;
              case "mapping":
                t = 'value of tag "' + n.params.tag + '" must be in oneOf';
                break;
              default:
                t = 'must pass "' + n.keyword + '" keyword validation';
            }
            break;
          case "enum":
            t = "egyenlő kell legyen valamely előre meghatározott értékkel";
            break;
          case "false schema":
            t = "boolean schema is false";
            break;
          case "format":
            t = 'meg kell feleljen a következő formátumnak: "' + n.params.format + '"';
            break;
          case "formatMaximum":
          case "formatExclusiveMaximum":
            t = "";
            var i = n.params.comparison + " " + n.params.limit;
            t += "must be " + i;
            break;
          case "formatMinimum":
          case "formatExclusiveMinimum":
            t = "";
            var i = n.params.comparison + " " + n.params.limit;
            t += "must be " + i;
            break;
          case "if":
            t = 'must match "' + n.params.failingKeyword + '" schema';
            break;
          case "maximum":
          case "exclusiveMaximum":
            t = "";
            var i = n.params.comparison + " " + n.params.limit;
            t += "kell legyen " + i;
            break;
          case "maxItems":
            t = "";
            var r = n.params.limit;
            t += "nem lehet több, mint " + r + " eleme";
            break;
          case "maxLength":
            t = "";
            var r = n.params.limit;
            t += "nem lehet hosszabb, mint " + r + " szimbólum";
            break;
          case "maxProperties":
            t = "";
            var r = n.params.limit;
            t += "nem lehet több, mint " + r + " tulajdonsága";
            break;
          case "minimum":
          case "exclusiveMinimum":
            t = "";
            var i = n.params.comparison + " " + n.params.limit;
            t += "kell legyen " + i;
            break;
          case "minItems":
            t = "";
            var r = n.params.limit;
            t += "nem lehet kevesebb, mint " + r + " eleme";
            break;
          case "minLength":
            t = "";
            var r = n.params.limit;
            t += "nem lehet rövidebb, mint " + r + " szimbólum";
            break;
          case "minProperties":
            t = "";
            var r = n.params.limit;
            t += "nem lehet kevesebb, mint " + r + " tulajdonsága";
            break;
          case "multipleOf":
            t = "a többszöröse kell legyen a következő számnak: " + n.params.multipleOf;
            break;
          case "not":
            t = 'nem lehet érvényes a "not" alaknak megfelelően';
            break;
          case "oneOf":
            t = 'meg kell feleljen pontosan egy "oneOf" alaknak';
            break;
          case "pattern":
            t = 'meg kell feleljen a következő mintának: "' + n.params.pattern + '"';
            break;
          case "patternRequired":
            t = 'must have property matching pattern "' + n.params.missingPattern + '"';
            break;
          case "propertyNames":
            t = "property name is invalid";
            break;
          case "required":
            t = "kell legyen " + n.params.missingProperty + " tulajdonsága";
            break;
          case "type":
            t = "" + n.params.type + " kell legyen";
            break;
          case "unevaluatedItems":
            t = "";
            var r = n.params.len;
            t += "must NOT have more than " + r + " item", r != 1 && (t += "s");
            break;
          case "unevaluatedProperties":
            t = "must NOT have unevaluated properties";
            break;
          case "uniqueItems":
            t = "nem lehetnek azonos elemei (" + n.params.j + " és " + n.params.i + " elemek azonosak)";
            break;
          default:
            t = 'must pass "' + n.keyword + '" keyword validation';
        }
        n.message = t;
      }
  }), ol;
}
var ul, vc;
function Vy() {
  return vc || (vc = 1, ul = function(a) {
    if (a && a.length)
      for (const n of a) {
        let t;
        switch (n.keyword) {
          case "additionalItems":
          case "items":
            t = "";
            var r = n.params.limit;
            t += " tidak boleh memiliki lebih dari " + r + " item";
            break;
          case "additionalProperties":
            t = "tidak boleh memiliki properti tambahan";
            break;
          case "anyOf":
            t = 'harus cocok dengan beberapa skema pada "anyOf"';
            break;
          case "const":
            t = "harus sama dengan konstan";
            break;
          case "contains":
            t = "harus berisi item yang valid";
            break;
          case "dependencies":
          case "dependentRequired":
            t = "";
            var r = n.params.depsCount;
            t += " harus memiliki properti " + n.params.deps + " ketika properti " + n.params.property + " hadir";
            break;
          case "discriminator":
            switch (n.params.error) {
              case "tag":
                t = 'tag "' + n.params.tag + '" must be string';
                break;
              case "mapping":
                t = 'value of tag "' + n.params.tag + '" must be in oneOf';
                break;
              default:
                t = 'harus lulus validasi kata kunci "' + n.keyword + '"';
            }
            break;
          case "enum":
            t = "harus sama dengan salah satu dari nilai yang telah ditentukan";
            break;
          case "false schema":
            t = "skema boolean salah";
            break;
          case "format":
            t = 'harus cocok dengan format "' + n.params.format + '"';
            break;
          case "formatMaximum":
          case "formatExclusiveMaximum":
            t = "";
            var i = n.params.comparison + " " + n.params.limit;
            t += "harus " + i;
            break;
          case "formatMinimum":
          case "formatExclusiveMinimum":
            t = "";
            var i = n.params.comparison + " " + n.params.limit;
            t += "harus " + i;
            break;
          case "if":
            t = 'harus cocok dengan skema "' + n.params.failingKeyword + '"';
            break;
          case "maximum":
          case "exclusiveMaximum":
            t = "";
            var i = n.params.comparison + " " + n.params.limit;
            t += "harus " + i;
            break;
          case "maxItems":
            t = "";
            var r = n.params.limit;
            t += " tidak boleh memiliki lebih dari " + r + " item";
            break;
          case "maxLength":
            t = "";
            var r = n.params.limit;
            t += " tidak boleh lebih dari " + r + " karakter";
            break;
          case "maxProperties":
            t = "";
            var r = n.params.limit;
            t += " tidak boleh memiliki lebih dari " + r + " properti";
            break;
          case "minimum":
          case "exclusiveMinimum":
            t = "";
            var i = n.params.comparison + " " + n.params.limit;
            t += "harus " + i;
            break;
          case "minItems":
            t = "";
            var r = n.params.limit;
            t += " tidak boleh kurang dari " + r + " item";
            break;
          case "minLength":
            t = "";
            var r = n.params.limit;
            t += " tidak boleh lebih pendek dari " + r + " karakter";
            break;
          case "minProperties":
            t = "";
            var r = n.params.limit;
            t += " tidak boleh kurang dari " + r + " properti";
            break;
          case "multipleOf":
            t = "harus merupakan kelipatan dari " + n.params.multipleOf;
            break;
          case "not":
            t = 'tidak boleh valid sesuai dengan skema pada "not"';
            break;
          case "oneOf":
            t = 'harus sama persis dengan satu skema pada "oneOf"';
            break;
          case "pattern":
            t = 'harus cocok dengan pola "' + n.params.pattern + '"';
            break;
          case "patternRequired":
            t = 'harus memiliki pola pencocokan properti "' + n.params.missingPattern + '"';
            break;
          case "propertyNames":
            t = "nama properti tidak valid";
            break;
          case "required":
            t = "harus memiliki properti " + n.params.missingProperty;
            break;
          case "type":
            t = "harus berupa " + n.params.type;
            break;
          case "unevaluatedItems":
            t = "";
            var r = n.params.len;
            t += "must NOT have more than " + r + " item", r != 1 && (t += "s");
            break;
          case "unevaluatedProperties":
            t = "must NOT have unevaluated properties";
            break;
          case "uniqueItems":
            t = "tidak boleh memiliki item duplikat (item ## " + n.params.j + " dan " + n.params.i + " identik)";
            break;
          default:
            t = 'harus lulus validasi kata kunci "' + n.keyword + '"';
        }
        n.message = t;
      }
  }), ul;
}
var cl, pc;
function Iy() {
  return pc || (pc = 1, cl = function(a) {
    if (a && a.length)
      for (const n of a) {
        let t;
        switch (n.keyword) {
          case "additionalItems":
          case "items":
            t = "";
            var r = n.params.limit;
            t += "non dovrebbe avere più di " + r + " element", r == 1 ? t += "o" : t += "i";
            break;
          case "additionalProperties":
            t = "non deve avere attributi aggiuntivi";
            break;
          case "anyOf":
            t = 'deve corrispondere ad uno degli schema in "anyOf"';
            break;
          case "const":
            t = "deve essere uguale alla costante";
            break;
          case "contains":
            t = "deve contentere un elemento valido";
            break;
          case "dependencies":
          case "dependentRequired":
            t = "";
            var r = n.params.depsCount;
            t += "dovrebbe avere ", r == 1 ? t += "l'" : t += "gli ", t += "attribut", r == 1 ? t += "o" : t += "i", t += " " + n.params.deps + " quando l'attributo " + n.params.property + " è presente";
            break;
          case "discriminator":
            switch (n.params.error) {
              case "tag":
                t = 'il tag "' + n.params.tag + '" deve essere di tipo stringa';
                break;
              case "mapping":
                t = 'il valore del tag "' + n.params.tag + '" deve essere nei oneOf';
                break;
              default:
                t = 'deve essere valido secondo il criterio "' + n.keyword + '"';
            }
            break;
          case "enum":
            t = "deve essere uguale ad uno dei valori consentiti";
            break;
          case "false schema":
            t = "lo schema booleano è falso";
            break;
          case "format":
            t = 'deve corrispondere al formato "' + n.params.format + '"';
            break;
          case "formatMaximum":
          case "formatExclusiveMaximum":
            t = "";
            var i = n.params.comparison + " " + n.params.limit;
            t += "deve essere " + i;
            break;
          case "formatMinimum":
          case "formatExclusiveMinimum":
            t = "";
            var i = n.params.comparison + " " + n.params.limit;
            t += "deve essere " + i;
            break;
          case "if":
            t = 'deve corrispondere allo schema "' + n.params.failingKeyword + '"';
            break;
          case "maximum":
          case "exclusiveMaximum":
            t = "";
            var i = n.params.comparison + " " + n.params.limit;
            t += "deve essere " + i;
            break;
          case "maxItems":
            t = "";
            var r = n.params.limit;
            t += "non deve avere più di " + r + " element", r == 1 ? t += "o" : t += "i";
            break;
          case "maxLength":
            t = "";
            var r = n.params.limit;
            t += "non deve essere più lungo di " + r + " caratter", r == 1 ? t += "e" : t += "i";
            break;
          case "maxProperties":
            t = "";
            var r = n.params.limit;
            t += "non deve avere più di " + r + " attribut", r == 1 ? t += "o" : t += "i";
            break;
          case "minimum":
          case "exclusiveMinimum":
            t = "";
            var i = n.params.comparison + " " + n.params.limit;
            t += "deve essere " + i;
            break;
          case "minItems":
            t = "";
            var r = n.params.limit;
            t += "non deve avere meno di " + r + " element", r == 1 ? t += "o" : t += "i";
            break;
          case "minLength":
            t = "";
            var r = n.params.limit;
            t += "non deve essere meno lungo di " + r + " caratter", r == 1 ? t += "e" : t += "i";
            break;
          case "minProperties":
            t = "";
            var r = n.params.limit;
            t += "non deve avere meno di " + r + " attribut", r == 1 ? t += "o" : t += "i";
            break;
          case "multipleOf":
            t = "deve essere un multiplo di " + n.params.multipleOf;
            break;
          case "not":
            t = 'non deve essere valido in base allo schema di "non"';
            break;
          case "oneOf":
            t = 'deve corrispondere esattamente ad uno degli schema in "oneOf"';
            break;
          case "pattern":
            t = 'deve corrispondere al formato "' + n.params.pattern + '"';
            break;
          case "patternRequired":
            t = 'deve avere un attributo che corrisponda al formato "' + n.params.missingPattern + '"';
            break;
          case "propertyNames":
            t = "il nome dell'attritbuto non è valido";
            break;
          case "required":
            t = "deve avere l'attributo obbligatorio " + n.params.missingProperty;
            break;
          case "type":
            t = "deve essere di tipo " + n.params.type;
            break;
          case "unevaluatedItems":
            t = "";
            var r = n.params.len;
            t += "non deve avere più di " + r + " elementi", r == 1 ? t += "o" : t += "i";
            break;
          case "unevaluatedProperties":
            t = "non deve avere attributi non valutati";
            break;
          case "uniqueItems":
            t = "non deve avere duplicati (gli elementi ## " + n.params.j + " e " + n.params.i + " sono uguali)";
            break;
          default:
            t = 'deve essere valido secondo il criterio "' + n.keyword + '"';
        }
        n.message = t;
      }
  }), cl;
}
var dl, hc;
function Oy() {
  return hc || (hc = 1, dl = function(a) {
    if (a && a.length)
      for (const n of a) {
        let t;
        switch (n.keyword) {
          case "additionalItems":
          case "items":
            t = "";
            var r = n.params.limit;
            t += "は" + r + "以上あってはいけない";
            break;
          case "additionalProperties":
            t = "追加してはいけない";
            break;
          case "anyOf":
            t = '"anyOf"のスキーマとマッチしなくてはいけない';
            break;
          case "const":
            t = "must be equal to constant";
            break;
          case "contains":
            t = "must contain a valid item";
            break;
          case "dependencies":
          case "dependentRequired":
            t = "" + n.params.property + "がある場合、";
            var r = n.params.depsCount;
            t += "は" + n.params.deps + "をつけなければいけない";
            break;
          case "discriminator":
            switch (n.params.error) {
              case "tag":
                t = 'tag "' + n.params.tag + '" must be string';
                break;
              case "mapping":
                t = 'value of tag "' + n.params.tag + '" must be in oneOf';
                break;
              default:
                t = 'must pass "' + n.keyword + '" keyword validation';
            }
            break;
          case "enum":
            t = "事前に定義された値のいずれかに等しくなければいけない";
            break;
          case "false schema":
            t = "boolean schema is false";
            break;
          case "format":
            t = '"' + n.params.format + '"形式に揃えなければいけない';
            break;
          case "formatMaximum":
          case "formatExclusiveMaximum":
            t = "";
            var i = n.params.comparison + " " + n.params.limit;
            t += "must be " + i;
            break;
          case "formatMinimum":
          case "formatExclusiveMinimum":
            t = "";
            var i = n.params.comparison + " " + n.params.limit;
            t += "must be " + i;
            break;
          case "if":
            t = 'must match "' + n.params.failingKeyword + '" schema';
            break;
          case "maximum":
          case "exclusiveMaximum":
            t = "";
            var i = n.params.comparison + " " + n.params.limit;
            t += i + "でなければいけない";
            break;
          case "maxItems":
            t = "";
            var r = n.params.limit;
            t += "は" + r + "個以上であってはいけない";
            break;
          case "maxLength":
            t = "";
            var r = n.params.limit;
            t += "は" + r + "文字以上であってはいけない";
            break;
          case "maxProperties":
            t = "";
            var r = n.params.limit;
            t += "は" + r + "個以上のプロパティを有してはいけない";
            break;
          case "minimum":
          case "exclusiveMinimum":
            t = "";
            var i = n.params.comparison + " " + n.params.limit;
            t += i + "でなければいけない";
            break;
          case "minItems":
            t = "";
            var r = n.params.limit;
            t += "は" + r + "個以下であってはいけない";
            break;
          case "minLength":
            t = "";
            var r = n.params.limit;
            t += "は" + r + "文字以下であってはいけない";
            break;
          case "minProperties":
            t = "";
            var r = n.params.limit;
            t += "は" + r + "個以下のプロパティを有してはいけない";
            break;
          case "multipleOf":
            t = "" + n.params.multipleOf + "の倍数でなければいけない";
            break;
          case "not":
            t = '"not"のスキーマに従って有効としてはいけない';
            break;
          case "oneOf":
            t = '"oneOf"のスキーマと完全に一致しなくてはいけない';
            break;
          case "pattern":
            t = '"' + n.params.pattern + '"のパターンと一致しなければいけない';
            break;
          case "patternRequired":
            t = 'must have property matching pattern "' + n.params.missingPattern + '"';
            break;
          case "propertyNames":
            t = "property name is invalid";
            break;
          case "required":
            t = "必要なプロパティ" + n.params.missingProperty + "がなければいけない";
            break;
          case "type":
            t = "" + n.params.type + "でなければいけない";
            break;
          case "unevaluatedItems":
            t = "";
            var r = n.params.len;
            t += "must NOT have more than " + r + " item", r != 1 && (t += "s");
            break;
          case "unevaluatedProperties":
            t = "must NOT have unevaluated properties";
            break;
          case "uniqueItems":
            t = "重複するアイテムがあってはいけない（" + n.params.j + "と" + n.params.i + "は同じである）";
            break;
          default:
            t = 'must pass "' + n.keyword + '" keyword validation';
        }
        n.message = t;
      }
  }), dl;
}
var fl, yc;
function Ey() {
  return yc || (yc = 1, fl = function(a) {
    if (a && a.length)
      for (const n of a) {
        let t;
        switch (n.keyword) {
          case "additionalItems":
          case "items":
            t = "";
            var r = n.params.limit;
            t += " 항목은 아이템을 " + r + "개 이상 가질 수 없습니다";
            break;
          case "additionalProperties":
            t = "추가적인 속성은 허용되지 않습니다";
            break;
          case "anyOf":
            t = '"anyOf"의 스키마와 일치해야 합니다';
            break;
          case "const":
            t = "상수와 같아야합니다";
            break;
          case "contains":
            t = "올바른 아이템을 포함해야 합니다";
            break;
          case "dependencies":
          case "dependentRequired":
            t = "";
            var r = n.params.depsCount;
            t += n.params.property + "속성이 있는 경우, " + n.params.deps + " 속성이 있어야합니다";
            break;
          case "discriminator":
            switch (n.params.error) {
              case "tag":
                t = '"' + n.params.tag + '"태그는 반드시 문자열이여야 합니다';
                break;
              case "mapping":
                t = '"' + n.params.tag + '"태그의 값은 반드시 oneOf에 있어야 합니다';
                break;
              default:
                t = '"' + n.keyword + '"키워드 검사를 통과해야 합니다';
            }
            break;
          case "enum":
            t = "미리 정의된 값중 하나여야 합니다";
            break;
          case "false schema":
            t = "boolean 스키마는 올바르지 않습니다";
            break;
          case "format":
            t = '"' + n.params.format + '" 포맷과 일치해야 합니다';
            break;
          case "formatMaximum":
          case "formatExclusiveMaximum":
            t = "";
            var i = n.params.comparison + " " + n.params.limit;
            t += " " + i + " 이여야 합니다";
            break;
          case "formatMinimum":
          case "formatExclusiveMinimum":
            t = "";
            var i = n.params.comparison + " " + n.params.limit;
            t += " " + i + " 이여야 합니다";
            break;
          case "if":
            t = '"' + n.params.failingKeyword + '" 스키마와 일치해야 합니다';
            break;
          case "maximum":
          case "exclusiveMaximum":
            t = "";
            var i = n.params.comparison + " " + n.params.limit;
            t += " " + i + " 이여야 합니다";
            break;
          case "maxItems":
            t = "";
            var r = n.params.limit;
            t += "아이템이 최대 " + r + "개이여야 합니다";
            break;
          case "maxLength":
            t = "";
            var r = n.params.limit;
            t += "최대 " + r + "글자여야 합니다";
            break;
          case "maxProperties":
            t = "";
            var r = n.params.limit;
            t += "속성은 최대 " + r + "개 이내여야 합니다";
            break;
          case "minimum":
          case "exclusiveMinimum":
            t = "";
            var i = n.params.comparison + " " + n.params.limit;
            t += " " + i + " 이여야 합니다";
            break;
          case "minItems":
            t = "";
            var r = n.params.limit;
            t += "아이템이 최소 " + r + "개이여야 합니다";
            break;
          case "minLength":
            t = "";
            var r = n.params.limit;
            t += "최소 " + r + "글자여야 합니다";
            break;
          case "minProperties":
            t = "";
            var r = n.params.limit;
            t += "속성은 최소 " + r + "개 이상이여야 합니다";
            break;
          case "multipleOf":
            t = "" + n.params.multipleOf + "의 배수여야 합니다";
            break;
          case "not":
            t = '"not"스키마에 따라 유효하지 않아야 합니다';
            break;
          case "oneOf":
            t = '"oneOf" 스키마중 하나와 정확하게 일치해야 합니다';
            break;
          case "pattern":
            t = '"' + n.params.pattern + '"패턴과 일치해야 합니다';
            break;
          case "patternRequired":
            t = '"' + n.params.missingPattern + '"패턴과 일치하는 속성을 가져야 합니다';
            break;
          case "propertyNames":
            t = "속성명이 올바르지 않습니다";
            break;
          case "required":
            t = "" + n.params.missingProperty + " 속성은 필수입니다";
            break;
          case "type":
            t = "" + n.params.type + "이여야 합니다";
            break;
          case "unevaluatedItems":
            t = "";
            var r = n.params.len;
            t += "항목이 " + r + "개 아이템을 초과하면 안됩니다";
            break;
          case "unevaluatedProperties":
            t = "평가되지 않은 속성이 없어야합니다.";
            break;
          case "uniqueItems":
            t = "중복 아이템이 없어야 합니다 (아이템" + n.params.j + "과 아이템" + n.params.i + "가 동일합니다)";
            break;
          default:
            t = '"' + n.keyword + '"키워드 검사를 통과해야 합니다';
        }
        n.message = t;
      }
  }), fl;
}
var ml, gc;
function Ay() {
  return gc || (gc = 1, ml = function(a) {
    if (a && a.length)
      for (const t of a) {
        let s;
        switch (t.keyword) {
          case "additionalItems":
          case "items":
            s = "";
            var n = t.params.limit;
            s += "kan ikke ha mer enn " + n + " element", n != 1 && (s += "er");
            break;
          case "additionalProperties":
            s = "kan ikke ha flere egenskaper";
            break;
          case "anyOf":
            s = 'må samsvare med et schema i "anyOf"';
            break;
          case "const":
            s = "må være lik konstanten";
            break;
          case "contains":
            s = "må inneholde et gyldig element";
            break;
          case "dependencies":
          case "dependentRequired":
            s = "";
            var n = t.params.depsCount;
            s += "må ha egenskapen", n != 1 && (s += "e"), s += " " + t.params.deps + " når egenskapen " + t.params.property + " er angitt";
            break;
          case "discriminator":
            switch (t.params.error) {
              case "tag":
                s = 'tag "' + t.params.tag + '" must be string';
                break;
              case "mapping":
                s = 'value of tag "' + t.params.tag + '" must be in oneOf';
                break;
              default:
                s = "må samsvare med valideringen for " + t.keyword;
            }
            break;
          case "enum":
            s = "må være lik en av de forhåndsdefinerte verdiene";
            break;
          case "false schema":
            s = "boolsk schema er usannt";
            break;
          case "format":
            s = 'må stemme overens med formatet "' + t.params.format + '"';
            break;
          case "formatMaximum":
          case "formatExclusiveMaximum":
            s = "";
            var i = t.params.comparison + " " + t.params.limit;
            s += "må være " + i;
            break;
          case "formatMinimum":
          case "formatExclusiveMinimum":
            s = "";
            var i = t.params.comparison + " " + t.params.limit;
            s += "må være " + i;
            break;
          case "if":
            s = 'must match "' + t.params.failingKeyword + '" schema';
            break;
          case "maximum":
          case "exclusiveMaximum":
            s = "";
            var i = t.params.comparison + " " + t.params.limit;
            s += "må være " + i;
            break;
          case "maxItems":
            s = "";
            var n = t.params.limit;
            s += "kan ikke ha fler enn " + n + " element", n != 1 && (s += "er");
            break;
          case "maxLength":
            s = "";
            var n = t.params.limit;
            s += "kan ikke være lengre enn " + n + " tegn";
            break;
          case "maxProperties":
            s = "";
            var n = t.params.limit;
            s += "kan ikke ha mer enn " + n + " egenskap", n != 1 && (s += "er");
            break;
          case "minimum":
          case "exclusiveMinimum":
            s = "";
            var i = t.params.comparison + " " + t.params.limit;
            s += "må være " + i;
            break;
          case "minItems":
            s = "";
            var n = t.params.limit;
            s += "kan ikke ha færre enn " + n + " element", n != 1 && (s += "er");
            break;
          case "minLength":
            s = "";
            var n = t.params.limit;
            s += "kan ikke være kortere enn " + n + " tegn";
            break;
          case "minProperties":
            s = "";
            var n = t.params.limit;
            s += "kan ikke ha mindre enn " + n + " egenskap", n != 1 && (s += "er");
            break;
          case "multipleOf":
            s = "må være et multiplum av " + t.params.multipleOf;
            break;
          case "not":
            s = 'kan ikke samsvare med schema i "not"';
            break;
          case "oneOf":
            s = 'må samsvare med nøyaktig ett schema i "oneOf"';
            break;
          case "pattern":
            s = 'må samsvare med mønsteret "' + t.params.pattern + '"';
            break;
          case "patternRequired":
            s = 'må ha en egenskap som samsvarer med mønsteret "' + t.params.missingPattern;
            break;
          case "propertyNames":
            s = "egenskapen med navnet '", t.params.propertyNameout += "' er ugyldig";
            break;
          case "required":
            s = "må ha den påkrevde egenskapen " + t.params.missingProperty;
            break;
          case "type":
            s = "";
            var r = t.params.type;
            s += "må være ", r == "number" ? s += "et tall" : r == "integer" ? s += "et heltall" : r == "string" ? s += "en streng" : r == "boolean" ? s += "ja eller nei" : s += r;
            break;
          case "unevaluatedItems":
            s = "";
            var n = t.params.len;
            s += "must NOT have more than " + n + " item", n != 1 && (s += "s");
            break;
          case "unevaluatedProperties":
            s = "must NOT have unevaluated properties";
            break;
          case "uniqueItems":
            s = "kan ikke ha duplikate elemeneter (elementene ## " + t.params.j + " og " + t.params.i + " er identiske)";
            break;
          default:
            s = "må samsvare med valideringen for " + t.keyword;
        }
        t.message = s;
      }
  }), ml;
}
var vl, bc;
function Ty() {
  return bc || (bc = 1, vl = function(a) {
    if (a && a.length)
      for (const t of a) {
        let s;
        switch (t.keyword) {
          case "additionalItems":
          case "items":
            s = "";
            var n = t.params.limit;
            s += "mag niet meer dan " + n + " item", n != 1 && (s += "s"), s += " bevatten";
            break;
          case "additionalProperties":
            s = "mag geen extra eigenschappen bevatten";
            break;
          case "anyOf":
            s = 'moet overeenkomen met een schema in "anyOf"';
            break;
          case "const":
            s = "moet gelijk zijn aan constante";
            break;
          case "contains":
            s = "moet een geldig item bevatten";
            break;
          case "dependencies":
          case "dependentRequired":
            s = "";
            var n = t.params.depsCount;
            s += "moet de eigenschap", n != 1 && (s += "pen"), s += " " + t.params.deps + " bevatten als " + t.params.property + " is gedefinieerd";
            break;
          case "discriminator":
            switch (t.params.error) {
              case "tag":
                s = 'tag "' + t.params.tag + '" moet een tekenreeks zijn';
                break;
              case "mapping":
                s = 'de waarde van het veld "' + t.params.tag + '" moet voorkomen in de oneOf';
                break;
              default:
                s = 'moet sleutelwoord validatie "' + t.keyword + '" doorstaan';
            }
            break;
          case "enum":
            s = "moet overeenkomen met één van de voorgedefinieerde waarden";
            break;
          case "false schema":
            s = "boolean schema is fout";
            break;
          case "format":
            s = 'moet overeenkomen met het volgende formaat: "' + t.params.format + '"';
            break;
          case "formatMaximum":
          case "formatExclusiveMaximum":
            s = "";
            var i = t.params.comparison + " " + t.params.limit;
            s += "moet " + i + " zijn";
            break;
          case "formatMinimum":
          case "formatExclusiveMinimum":
            s = "";
            var i = t.params.comparison + " " + t.params.limit;
            s += "moet " + i + " zijn";
            break;
          case "if":
            s = 'moet overeenkomen met "' + t.params.failingKeyword + '" schema';
            break;
          case "maximum":
          case "exclusiveMaximum":
            s = "";
            var i = t.params.comparison + " " + t.params.limit;
            s += "moet " + i + " zijn";
            break;
          case "maxItems":
            s = "";
            var n = t.params.limit;
            s += "mag niet meer dan " + n + " item", n != 1 && (s += "s"), s += " bevatten";
            break;
          case "maxLength":
            s = "";
            var n = t.params.limit;
            s += "mag niet langer dan " + n + " karakter", n != 1 && (s += "s"), s += " zijn";
            break;
          case "maxProperties":
            s = "";
            var n = t.params.limit;
            s += "mag niet meer dan " + n + " eigenschap", n != 1 && (s += "pen"), s += " bevatten";
            break;
          case "minimum":
          case "exclusiveMinimum":
            s = "";
            var i = t.params.comparison + " " + t.params.limit;
            s += "moet " + i + " zijn";
            break;
          case "minItems":
            s = "";
            var n = t.params.limit;
            s += "mag niet minder dan " + n + " item", n != 1 && (s += "s"), s += " bevatten";
            break;
          case "minLength":
            s = "";
            var n = t.params.limit;
            s += "mag niet korter dan " + n + " karakter", n != 1 && (s += "s"), s += " zijn";
            break;
          case "minProperties":
            s = "";
            var n = t.params.limit;
            s += "mag niet minder dan " + n + " eigenschap", n != 1 && (s += "pen"), s += " bevatten";
            break;
          case "multipleOf":
            s = "moet een veelvoud van " + t.params.multipleOf + " zijn";
            break;
          case "not":
            s = 'mag niet overeenkomen met een schema in "not"';
            break;
          case "oneOf":
            s = 'moet overeenkomen met één schema in "oneOf"';
            break;
          case "pattern":
            s = 'moet overeenkomen met het volgende patroon: "' + t.params.pattern + '"';
            break;
          case "patternRequired":
            s = 'moet een eigenschap bevatten die overeenkomt met het pattroon: "' + t.params.missingPattern + '"';
            break;
          case "propertyNames":
            s = "eigenschapnaam is ongeldig";
            break;
          case "required":
            s = "moet de eigenschap " + t.params.missingProperty + " bevatten";
            break;
          case "type":
            s = "";
            var r = t.params.type;
            s += "moet een ", r == "number" ? s += "nummer" : r == "integer" ? s += "geheel getal" : r == "string" ? s += "tekenreeks" : r == "boolean" && (s += "ja of nee waarde"), s += " (" + r + ") bevatten";
            break;
          case "unevaluatedItems":
            s = "";
            var n = t.params.len;
            s += "mag niet meer dan " + n + " item", n != 1 && (s += "s"), s += " bevatten";
            break;
          case "unevaluatedProperties":
            s = "mag geen ongecontroleerde eigenschappen bevatten";
            break;
          case "uniqueItems":
            s = "mag geen gedupliceerde items bevatten (items ## " + t.params.j + " en " + t.params.i + " zijn identiek)";
            break;
          default:
            s = 'moet sleutelwoord validatie "' + t.keyword + '" doorstaan';
        }
        t.message = s;
      }
  }), vl;
}
var pl, kc;
function jy() {
  return kc || (kc = 1, pl = function(a) {
    if (a && a.length)
      for (const n of a) {
        let t;
        switch (n.keyword) {
          case "additionalItems":
          case "items":
            t = "";
            var r = n.params.limit;
            t += "nie powinien mieć więcej niż " + r + " element", r == 1 ? t += "u" : t += "ów";
            break;
          case "additionalProperties":
            t = "nie powinien zawierać dodatkowych pól";
            break;
          case "anyOf":
            t = 'powinien pasować do wzoru z sekcji "anyOf"';
            break;
          case "const":
            t = "powinien być równy stałej";
            break;
          case "contains":
            t = "must contain a valid item";
            break;
          case "dependencies":
          case "dependentRequired":
            t = "";
            var r = n.params.depsCount;
            t += "powinien zawierać pol", r == 1 ? t += "e" : t += "a", t += " " + n.params.deps + " kiedy pole " + n.params.property + " jest obecne";
            break;
          case "discriminator":
            switch (n.params.error) {
              case "tag":
                t = 'tag "' + n.params.tag + '" must be string';
                break;
              case "mapping":
                t = 'value of tag "' + n.params.tag + '" must be in oneOf';
                break;
              default:
                t = 'powinien przejść walidację "' + n.keyword + '"';
            }
            break;
          case "enum":
            t = "powinien być równy jednej z predefiniowanych wartości";
            break;
          case "false schema":
            t = "boolean schema is false";
            break;
          case "format":
            t = 'powinien zgadzać się z formatem "' + n.params.format + '"';
            break;
          case "formatMaximum":
          case "formatExclusiveMaximum":
            t = "";
            var i = n.params.comparison + " " + n.params.limit;
            t += "powinien być " + i;
            break;
          case "formatMinimum":
          case "formatExclusiveMinimum":
            t = "";
            var i = n.params.comparison + " " + n.params.limit;
            t += "powinien być " + i;
            break;
          case "if":
            t = 'must match "' + n.params.failingKeyword + '" schema';
            break;
          case "maximum":
          case "exclusiveMaximum":
            t = "";
            var i = n.params.comparison + " " + n.params.limit;
            t += "powinien być " + i;
            break;
          case "maxItems":
            t = "";
            var r = n.params.limit;
            t += "nie powinien mieć więcej niż " + r + " element", r == 1 ? t += "u" : t += "ów";
            break;
          case "maxLength":
            t = "";
            var r = n.params.limit;
            t += "nie powinien być dłuższy niż " + r + " znak", r != 1 && (t += "ów");
            break;
          case "maxProperties":
            t = "";
            var r = n.params.limit;
            t += "nie powinien zawierać więcej niż " + r + " ", r == 1 ? t += "pole" : t += "pól";
            break;
          case "minimum":
          case "exclusiveMinimum":
            t = "";
            var i = n.params.comparison + " " + n.params.limit;
            t += "powinien być " + i;
            break;
          case "minItems":
            t = "";
            var r = n.params.limit;
            t += "nie powinien mieć mniej niż " + r + " element", r == 1 ? t += "u" : t += "ów";
            break;
          case "minLength":
            t = "";
            var r = n.params.limit;
            t += "nie powinien być krótszy niż " + r + " znak", r != 1 && (t += "ów");
            break;
          case "minProperties":
            t = "";
            var r = n.params.limit;
            t += "nie powinien zawierać mniej niż " + r + " ", r == 1 ? t += "pole" : t += "pól";
            break;
          case "multipleOf":
            t = "powinien być wielokrotnością " + n.params.multipleOf;
            break;
          case "not":
            t = 'nie powinien pasować do wzoru z sekcji "not"';
            break;
          case "oneOf":
            t = 'powinien pasować do jednego wzoru z sekcji "oneOf"';
            break;
          case "pattern":
            t = 'powinien zgadzać się ze wzorem "' + n.params.pattern + '"';
            break;
          case "patternRequired":
            t = 'powinien mieć pole pasujące do wzorca "' + n.params.missingPattern + '"';
            break;
          case "propertyNames":
            t = "property name is invalid";
            break;
          case "required":
            t = "powinien zawierać wymagane pole " + n.params.missingProperty;
            break;
          case "type":
            t = "powinien być " + n.params.type;
            break;
          case "unevaluatedItems":
            t = "";
            var r = n.params.len;
            t += "must NOT have more than " + r + " item", r != 1 && (t += "s");
            break;
          case "unevaluatedProperties":
            t = "must NOT have unevaluated properties";
            break;
          case "uniqueItems":
            t = "nie powinien zawierać elementów które się powtarzają (elementy " + n.params.j + " i " + n.params.i + " są identyczne)";
            break;
          default:
            t = 'powinien przejść walidację "' + n.keyword + '"';
        }
        n.message = t;
      }
  }), pl;
}
var hl, wc;
function Dy() {
  return wc || (wc = 1, hl = function(a) {
    if (a && a.length)
      for (const t of a) {
        let s;
        switch (t.keyword) {
          case "additionalItems":
          case "items":
            s = "não são permitidos itens adicionais (mais do que " + n + ")";
            break;
          case "additionalProperties":
            s = "não são permitidas propriedades adicionais";
            break;
          case "anyOf":
            s = 'os dados não correspondem a nenhum schema de "anyOf"';
            break;
          case "const":
            s = "deve ser igual à constante";
            break;
          case "contains":
            s = "deve conter um item válido";
            break;
          case "dependencies":
          case "dependentRequired":
            s = "";
            var n = t.params.depsCount;
            s += " deve ter propriedade", n != 1 && (s += "s"), s += " " + t.params.deps + " quando a propriedade " + t.params.property + " estiver presente";
            break;
          case "discriminator":
            switch (t.params.error) {
              case "tag":
                s = 'a tag "' + t.params.tag + '" deve ser uma string';
                break;
              case "mapping":
                s = 'o valor da tag "' + t.params.tag + '" deve estar no oneOf';
                break;
              default:
                s = 'deve passar a validação da keyword "' + t.keyword + '"';
            }
            break;
          case "enum":
            s = "deve ser igual a um dos valores permitidos";
            break;
          case "false schema":
            s = 'o schema booleano é "false"';
            break;
          case "format":
            s = 'deve corresponder ao formato "' + t.params.format + '"';
            break;
          case "formatMaximum":
          case "formatExclusiveMaximum":
            s = "";
            var i = t.params.comparison + " " + t.params.limit;
            s += "deve ser " + i;
            break;
          case "formatMinimum":
          case "formatExclusiveMinimum":
            s = "";
            var i = t.params.comparison + " " + t.params.limit;
            s += "deve ser " + i;
            break;
          case "if":
            s = 'deve corresponder ao schema "' + t.params.failingKeyword + '"';
            break;
          case "maximum":
          case "exclusiveMaximum":
            s = "";
            var i = t.params.comparison + " " + t.params.limit;
            s += "deve ser " + i;
            break;
          case "maxItems":
            s = "";
            var n = t.params.limit;
            s += "não deve ter mais que " + n + " elemento", n != 1 && (s += "s");
            break;
          case "maxLength":
            s = "";
            var n = t.params.limit;
            s += "não deve ser maior que " + n + " caracter", n != 1 && (s += "es");
            break;
          case "maxProperties":
            s = "";
            var n = t.params.limit;
            s += "não deve ter mais que " + n + " propriedade", n != 1 && (s += "s");
            break;
          case "minimum":
          case "exclusiveMinimum":
            s = "";
            var i = t.params.comparison + " " + t.params.limit;
            s += "deve ser " + i;
            break;
          case "minItems":
            s = "";
            var n = t.params.limit;
            s += "não deve ter menos que " + n + " elemento", n != 1 && (s += "s");
            break;
          case "minLength":
            s = "";
            var n = t.params.limit;
            s += "não deve ser mais curta que " + n + " caracter", n != 1 && (s += "es");
            break;
          case "minProperties":
            s = "";
            var n = t.params.limit;
            s += "não deve ter menos que " + n + " propriedade", n != 1 && (s += "s");
            break;
          case "multipleOf":
            s = "deve ser múltiplo de " + t.params.multipleOf;
            break;
          case "not":
            s = 'não deve ser valido segundo o schema em "not"';
            break;
          case "oneOf":
            s = 'deve corresponder exatamente com um schema em "oneOf"';
            break;
          case "pattern":
            s = 'deve corresponder ao padrão "' + t.params.pattern + '"';
            break;
          case "patternRequired":
            s = 'deve ter a propriedade correspondente ao padrão "' + t.params.missingPattern + '"';
            break;
          case "propertyNames":
            s = "o nome da propriedade é inválido";
            break;
          case "required":
            s = "deve ter a propriedade obrigatória " + t.params.missingProperty;
            break;
          case "type":
            s = "";
            var r = t.params.type;
            s += "deve ser ", r == "number" ? s += "um número" : r == "integer" ? s += "um número inteiro" : r == "string" ? s += "um texto" : r == "boolean" ? s += "um booleano" : s += r;
            break;
          case "unevaluatedItems":
            s = "";
            var n = t.params.len;
            s += "não pode possuir mais que " + n + " ", n == 1 ? s += "item" : s += "itens";
            break;
          case "unevaluatedProperties":
            s = "não pode possuir propridades não avaliadas";
            break;
          case "uniqueItems":
            s = "não deve ter itens duplicados (os itens ## " + t.params.j + " e " + t.params.i + " são idênticos)";
            break;
          default:
            s = 'deve passar a validação da keyword "' + t.keyword + '"';
        }
        t.message = s;
      }
  }), hl;
}
var yl, Sc;
function My() {
  return Sc || (Sc = 1, yl = function(a) {
    if (a && a.length)
      for (const n of a) {
        let t;
        switch (n.keyword) {
          case "additionalItems":
          case "items":
            t = "";
            var r = n.params.limit;
            t += "должно иметь не более, чем " + r + " элемент", r >= 2 && r <= 4 ? t += "а" : r != 1 && (t += "ов");
            break;
          case "additionalProperties":
            t = "не должно иметь дополнительных полей";
            break;
          case "anyOf":
            t = 'должно соответствовать одной их схем в "anyOf"';
            break;
          case "const":
            t = "должно быть равно заданному значению";
            break;
          case "contains":
            t = "должно содержать значение соответствующее схеме";
            break;
          case "dependencies":
          case "dependentRequired":
            t = "";
            var r = n.params.depsCount;
            t += "должно иметь пол", r == 1 ? t += "е" : t += "я", t += " " + n.params.deps + ", когда присутствует поле " + n.params.property;
            break;
          case "discriminator":
            switch (n.params.error) {
              case "tag":
                t = 'поле "' + n.params.tag + '" должно быть строкой';
                break;
              case "mapping":
                t = 'значение поля "' + n.params.tag + '" должно быть в одной из oneOf схем ';
                break;
              default:
                t = 'должно соответствовать правилу "' + n.keyword + '"';
            }
            break;
          case "enum":
            t = "должно быть равно одному из разрешенных значений";
            break;
          case "false schema":
            t = "схема равна false";
            break;
          case "format":
            t = 'должно соответствовать формату "' + n.params.format + '"';
            break;
          case "formatMaximum":
          case "formatExclusiveMaximum":
            t = "";
            var i = n.params.comparison + " " + n.params.limit;
            t += "должно быть " + i;
            break;
          case "formatMinimum":
          case "formatExclusiveMinimum":
            t = "";
            var i = n.params.comparison + " " + n.params.limit;
            t += "должно быть " + i;
            break;
          case "if":
            t = 'должно соответствовать схемe "' + n.params.failingKeyword + '"';
            break;
          case "maximum":
          case "exclusiveMaximum":
            t = "";
            var i = n.params.comparison + " " + n.params.limit;
            t += "должно быть " + i;
            break;
          case "maxItems":
            t = "";
            var r = n.params.limit;
            t += "должно иметь не более, чем " + r + " элемент", r >= 2 && r <= 4 ? t += "а" : r != 1 && (t += "ов");
            break;
          case "maxLength":
            t = "";
            var r = n.params.limit;
            t += "должно быть не длиннее, чем " + r + " символ", r >= 2 && r <= 4 ? t += "а" : r != 1 && (t += "ов");
            break;
          case "maxProperties":
            t = "";
            var r = n.params.limit;
            t += "должно иметь не более, чем " + r + " пол", r == 1 ? t += "е" : r >= 2 && r <= 4 ? t += "я" : t += "ей";
            break;
          case "minimum":
          case "exclusiveMinimum":
            t = "";
            var i = n.params.comparison + " " + n.params.limit;
            t += "должно быть " + i;
            break;
          case "minItems":
            t = "";
            var r = n.params.limit;
            t += "должно иметь не менее, чем " + r + " элемент", r >= 2 && r <= 4 ? t += "а" : r != 1 && (t += "ов");
            break;
          case "minLength":
            t = "";
            var r = n.params.limit;
            t += "должно быть не короче, чем " + r + " символ", r >= 2 && r <= 4 ? t += "а" : r != 1 && (t += "ов");
            break;
          case "minProperties":
            t = "";
            var r = n.params.limit;
            t += "должно иметь не менее, чем " + r + " пол", r == 1 ? t += "е" : r >= 2 && r <= 4 ? t += "я" : t += "ей";
            break;
          case "multipleOf":
            t = "должно быть кратным " + n.params.multipleOf;
            break;
          case "not":
            t = 'должно не соответствовать схеме в "not"';
            break;
          case "oneOf":
            t = 'должно соответствовать в точности одной схемe в "oneOf"';
            break;
          case "pattern":
            t = 'должно соответствовать образцу "' + n.params.pattern + '"';
            break;
          case "patternRequired":
            t = 'должно иметь поле, соответствующее образцу "' + n.params.missingPattern + '"';
            break;
          case "propertyNames":
            t = "имя поля не соответствует схеме";
            break;
          case "required":
            t = "должно иметь обязательное поле " + n.params.missingProperty;
            break;
          case "type":
            t = "должно быть " + n.params.type;
            break;
          case "unevaluatedItems":
            t = "";
            var r = n.params.len;
            t += "должно иметь не более, чем " + r + " элемент", r >= 2 && r <= 4 ? t += "а" : r != 1 && (t += "ов");
            break;
          case "unevaluatedProperties":
            t = "не должно иметь непроверенных полей";
            break;
          case "uniqueItems":
            t = "не должно иметь повторяющихся элементов (элементы " + n.params.j + " и " + n.params.i + " идентичны)";
            break;
          default:
            t = 'должно соответствовать правилу "' + n.keyword + '"';
        }
        n.message = t;
      }
  }), yl;
}
var gl, $c;
function Ry() {
  return $c || ($c = 1, gl = function(a) {
    if (a && a.length)
      for (const n of a) {
        let t;
        switch (n.keyword) {
          case "additionalItems":
          case "items":
            t = "";
            var r = n.params.limit;
            t += "nemôže obsahovať viac, než " + r + " prv", r == 1 ? t += "ok" : t += "kov";
            break;
          case "additionalProperties":
            t = "nemôže obsahovať ďalšie položky";
            break;
          case "anyOf":
            t = 'musí splňovať aspoň jednu zo schém v "anyOf"';
            break;
          case "const":
            t = "musí byť konštanta";
            break;
          case "contains":
            t = "musí obsahovať prvok zodpovedajúci schéme";
            break;
          case "dependencies":
          case "dependentRequired":
            t = "";
            var r = n.params.depsCount;
            t += " musí obsahovať polož", r >= 2 && r <= 4 ? t += "ky" : r != 1 ? t += "iek" : t += "ka", t += ": " + n.params.deps + ", ak obsahuje " + n.params.property;
            break;
          case "discriminator":
            switch (n.params.error) {
              case "tag":
                t = 'tag "' + n.params.tag + '" must be string';
                break;
              case "mapping":
                t = 'value of tag "' + n.params.tag + '" must be in oneOf';
                break;
              default:
                t = 'musí splniť "' + n.keyword + '" validáciu';
            }
            break;
          case "enum":
            t = "musí byť jedna z definovaných hodnôt";
            break;
          case "false schema":
            t = "schéma je false";
            break;
          case "format":
            t = 'musí obsahovať formát "' + n.params.format + '"';
            break;
          case "formatMaximum":
          case "formatExclusiveMaximum":
            t = "";
            var i = n.params.comparison + " " + n.params.limit;
            t += "musí byť " + i;
            break;
          case "formatMinimum":
          case "formatExclusiveMinimum":
            t = "";
            var i = n.params.comparison + " " + n.params.limit;
            t += "musí byť " + i;
            break;
          case "if":
            t = 'must match "' + n.params.failingKeyword + '" schema';
            break;
          case "maximum":
          case "exclusiveMaximum":
            t = "";
            var i = n.params.comparison + " " + n.params.limit;
            t += "musí byť " + i;
            break;
          case "maxItems":
            t = "";
            var r = n.params.limit;
            t += "nesmie obsahovať viac než " + r + " prv", r == 1 ? t += "ok" : t += "kov";
            break;
          case "maxLength":
            t = "";
            var r = n.params.limit;
            t += "nesmie byť dlhší než " + r + " znak", r != 1 && (t += "ov");
            break;
          case "maxProperties":
            t = "";
            var r = n.params.limit;
            t += "nesmie obsahovať viac než " + r + " polož", r >= 2 && r <= 4 ? t += "ky" : r != 1 ? t += "iek" : t += "ka";
            break;
          case "minimum":
          case "exclusiveMinimum":
            t = "";
            var i = n.params.comparison + " " + n.params.limit;
            t += "musí byť " + i;
            break;
          case "minItems":
            t = "";
            var r = n.params.limit;
            t += "nesmie obsahovať menej než " + r + " prv", r == 1 ? t += "ok" : t += "kov";
            break;
          case "minLength":
            t = "";
            var r = n.params.limit;
            t += "nesmie byť kratší než " + r + " znak", r != 1 && (t += "ov");
            break;
          case "minProperties":
            t = "";
            var r = n.params.limit;
            t += "nesmie obsahovať menej než " + r + " polož", r >= 2 && r <= 4 ? t += "ky" : r != 1 ? t += "iek" : t += "ka";
            break;
          case "multipleOf":
            t = "musí byť násobkom " + n.params.multipleOf;
            break;
          case "not":
            t = 'nesmie splňovať schému v "not"';
            break;
          case "oneOf":
            t = 'musí splňovať práve jednu schému v "oneOf"';
            break;
          case "pattern":
            t = 'musí splňovať regulárny výraz "' + n.params.pattern + '"';
            break;
          case "patternRequired":
            t = 'musí obsahovať položku splňjúcu regulárny výraz "' + n.params.missingPattern + '"';
            break;
          case "propertyNames":
            t = "názov položky nezodpovedá schéme";
            break;
          case "required":
            t = "musí obsahovať požadovanú položku " + n.params.missingProperty;
            break;
          case "type":
            t = "musí byť " + n.params.type;
            break;
          case "unevaluatedItems":
            t = "";
            var r = n.params.len;
            t += "must NOT have more than " + r + " item", r != 1 && (t += "s");
            break;
          case "unevaluatedProperties":
            t = "must NOT have unevaluated properties";
            break;
          case "uniqueItems":
            t = "nesmie obsahovať duplicitné prvky (prvky ## " + n.params.j + " a " + n.params.i + " sú rovnaké)";
            break;
          default:
            t = 'musí splniť "' + n.keyword + '" validáciu';
        }
        n.message = t;
      }
  }), gl;
}
var bl, _c;
function Ny() {
  return _c || (_c = 1, bl = function(a) {
    if (a && a.length)
      for (const n of a) {
        let t;
        switch (n.keyword) {
          case "additionalItems":
          case "items":
            t = "";
            var r = n.params.limit;
            t += "borde ha fler än " + r + " sak", r != 1 && (t += "er");
            break;
          case "additionalProperties":
            t = "borde inte ha fler egenskaper";
            break;
          case "anyOf":
            t = 'borde matcha något schema i "anyOf"';
            break;
          case "const":
            t = "bör vara en konstant";
            break;
          case "contains":
            t = "bör innehålla ett giltigt objekt";
            break;
          case "dependencies":
          case "dependentRequired":
            t = "";
            var r = n.params.depsCount;
            t += "borde ha egenskap", r != 1 && (t += "er"), t += " " + n.params.deps + " när egenskap " + n.params.property + " finns tillgängligt";
            break;
          case "discriminator":
            switch (n.params.error) {
              case "tag":
                t = 'tag "' + n.params.tag + '" must be string';
                break;
              case "mapping":
                t = 'value of tag "' + n.params.tag + '" must be in oneOf';
                break;
              default:
                t = 'bör passera "' + n.keyword + '" nyckelord validering';
            }
            break;
          case "enum":
            t = "borde vara ekvivalent med en av dess fördefinierade värden";
            break;
          case "false schema":
            t = "boolean schema är falskt";
            break;
          case "format":
            t = 'borde matcha formatet "' + n.params.format + '"';
            break;
          case "formatMaximum":
          case "formatExclusiveMaximum":
            t = "";
            var i = n.params.comparison + " " + n.params.limit;
            t += "bör vara " + i;
            break;
          case "formatMinimum":
          case "formatExclusiveMinimum":
            t = "";
            var i = n.params.comparison + " " + n.params.limit;
            t += "bör vara " + i;
            break;
          case "if":
            t = 'must match "' + n.params.failingKeyword + '" schema';
            break;
          case "maximum":
          case "exclusiveMaximum":
            t = "";
            var i = n.params.comparison + " " + n.params.limit;
            t += "borde vara " + i;
            break;
          case "maxItems":
            t = "";
            var r = n.params.limit;
            t += "borde inte ha fler än " + r + " sak", r != 1 && (t += "er");
            break;
          case "maxLength":
            t = "";
            var r = n.params.limit;
            t += "borde inte vara längre än " + r + " tecken";
            break;
          case "maxProperties":
            t = "";
            var r = n.params.limit;
            t += "borde inte ha fler än " + r + " egenskap", r != 1 && (t += "er");
            break;
          case "minimum":
          case "exclusiveMinimum":
            t = "";
            var i = n.params.comparison + " " + n.params.limit;
            t += "borde vara " + i;
            break;
          case "minItems":
            t = "";
            var r = n.params.limit;
            t += "borde inte ha färre än " + r + " sak", r != 1 && (t += "er");
            break;
          case "minLength":
            t = "";
            var r = n.params.limit;
            t += "borde inte vara kortare än " + r + " tecken";
            break;
          case "minProperties":
            t = "";
            var r = n.params.limit;
            t += "borde inte ha färre än " + r + " egenskap", r != 1 && (t += "er");
            break;
          case "multipleOf":
            t = "borde vara en multipel av " + n.params.multipleOf;
            break;
          case "not":
            t = 'borde inte vara giltigt enligt schema i "not"';
            break;
          case "oneOf":
            t = 'borde matcha exakt ett schema i "oneOf"';
            break;
          case "pattern":
            t = 'borde matcha mönstret "' + n.params.pattern + '"';
            break;
          case "patternRequired":
            t = 'bör ha en egenskap som matchar mönstret "' + n.params.missingPattern + '"';
            break;
          case "propertyNames":
            t = "egenskap med namnet är inte giltig";
            break;
          case "required":
            t = "borde ha den nödvändiga egenskapen " + n.params.missingProperty;
            break;
          case "type":
            t = "borde vara " + n.params.type;
            break;
          case "unevaluatedItems":
            t = "";
            var r = n.params.len;
            t += "must NOT have more than " + r + " item", r != 1 && (t += "s");
            break;
          case "unevaluatedProperties":
            t = "must NOT have unevaluated properties";
            break;
          case "uniqueItems":
            t = "borde inte ha duplicerade saker (sakerna ## " + n.params.j + " och " + n.params.i + " är identiska)";
            break;
          default:
            t = 'bör passera "' + n.keyword + '" nyckelord validering';
        }
        n.message = t;
      }
  }), bl;
}
var kl, Pc;
function Ly() {
  return Pc || (Pc = 1, kl = function(a) {
    if (a && a.length)
      for (const n of a) {
        let t;
        switch (n.keyword) {
          case "additionalItems":
          case "items":
            t = "";
            var r = n.params.limit;
            t += "ต้องมีสมาชิกไม่เกิน " + r + " ตัว";
            break;
          case "additionalProperties":
            t = "ต้องไม่มี property อื่นๆ นอกเหนีอจากที่กำหนดไว้";
            break;
          case "anyOf":
            t = 'ต้องตรงกับหนึ่งใน schema ที่กำหนดไว้ใน "anyOf"';
            break;
          case "const":
            t = "ต้องเท่ากับค่าคงที่";
            break;
          case "contains":
            t = "ต้องมีสมาชิกที่ผ่านเงื่อนไขอยู่";
            break;
          case "dependencies":
          case "dependentRequired":
            t = "";
            var r = n.params.depsCount;
            t += "เมื่อมี property " + n.params.property + " แล้วจะต้องมี property " + n.params.deps + " ด้วย";
            break;
          case "discriminator":
            switch (n.params.error) {
              case "tag":
                t = 'tag "' + n.params.tag + '" ต้องเป็น string';
                break;
              case "mapping":
                t = 'ต้องมีค่าของ tag "' + n.params.tag + '" ใน oneOf';
                break;
              default:
                t = 'ต้องผ่านคีย์เวิร์ด "' + n.keyword + '"';
            }
            break;
          case "enum":
            t = "ต้องตรงกับหนึ่งในค่าที่กำหนดไว้";
            break;
          case "false schema":
            t = "schema เป็น false";
            break;
          case "format":
            t = 'ต้องเป็นรูปแบบ "' + n.params.format + '"';
            break;
          case "formatMaximum":
          case "formatExclusiveMaximum":
            t = "";
            var i = n.params.comparison + " " + n.params.limit;
            t += "ต้อง " + i;
            break;
          case "formatMinimum":
          case "formatExclusiveMinimum":
            t = "";
            var i = n.params.comparison + " " + n.params.limit;
            t += "ต้อง " + i;
            break;
          case "if":
            t = 'ต้องตรงกับ schema "' + n.params.failingKeyword + '"';
            break;
          case "maximum":
          case "exclusiveMaximum":
            t = "";
            var i = n.params.comparison + " " + n.params.limit;
            t += "ต้อง " + i;
            break;
          case "maxItems":
            t = "";
            var r = n.params.limit;
            t += "ต้องมีสมาชิกไม่เกิน " + r;
            break;
          case "maxLength":
            t = "";
            var r = n.params.limit;
            t += "ต้องยาวไม่เกิน " + r + " ตัวอักษร";
            break;
          case "maxProperties":
            t = "";
            var r = n.params.limit;
            t += "ต้องมี property ไม่เกิน " + r + " ตัว";
            break;
          case "minimum":
          case "exclusiveMinimum":
            t = "";
            var i = n.params.comparison + " " + n.params.limit;
            t += "ต้อง " + i;
            break;
          case "minItems":
            t = "";
            var r = n.params.limit;
            t += "ควรมีสมาชิกไม่น้อยกว่า " + r;
            break;
          case "minLength":
            t = "";
            var r = n.params.limit;
            t += "ต้องมีอย่างน้อย " + r + " ตัวอักษร";
            break;
          case "minProperties":
            t = "";
            var r = n.params.limit;
            t += "ต้องมี property อย่างน้อย " + r + " ตัว";
            break;
          case "multipleOf":
            t = "ต้องเป็นเลขที่หาร " + n.params.multipleOf + " ลงตัว";
            break;
          case "not":
            t = 'ต้องไม่ผ่าน schema ที่กำหนดไว้ใน "not"';
            break;
          case "oneOf":
            t = 'ต้องตรงกับ schema ตัวเดียวใน "oneOf" เท่านั้น';
            break;
          case "pattern":
            t = 'ต้องตรงตาม pattern "' + n.params.pattern + '"';
            break;
          case "patternRequired":
            t = 'ต้องมี property ที่มีชื่อตรงตาม pattern "' + n.params.missingPattern + '"';
            break;
          case "propertyNames":
            t = "ชื่อ property ไม่ถูกต้อง";
            break;
          case "required":
            t = "ต้องมี property " + n.params.missingProperty + " ด้วย";
            break;
          case "type":
            t = "ต้องเป็น " + n.params.type;
            break;
          case "unevaluatedItems":
            t = "";
            var r = n.params.len;
            t += "ต้องมีไม่เกิน " + r + " ตัว";
            break;
          case "unevaluatedProperties":
            t = "ต้องไม่มี property ที่ยังไม่ได้ผ่านการตรวจสอบเงื่อนไขใดๆ";
            break;
          case "uniqueItems":
            t = "ต้องมีสมาชิกไม่ซ้ำักัน (ลำดับที่ " + n.params.j + " กับ " + n.params.i + " ซ้ำกัน)";
            break;
          default:
            t = 'ต้องผ่านคีย์เวิร์ด "' + n.keyword + '"';
        }
        n.message = t;
      }
  }), kl;
}
var wl, Cc;
function qy() {
  return Cc || (Cc = 1, wl = function(a) {
    if (a && a.length)
      for (const n of a) {
        let t;
        switch (n.keyword) {
          case "additionalItems":
          case "items":
            t = "";
            var r = n.params.limit;
            t += "不允许超过" + r + "个元素";
            break;
          case "additionalProperties":
            t = "不允许有额外的属性";
            break;
          case "anyOf":
            t = "数据应为 anyOf 所指定的其中一个";
            break;
          case "const":
            t = "应当等于常量";
            break;
          case "contains":
            t = "应当包含一个有效项";
            break;
          case "dependencies":
          case "dependentRequired":
            t = "";
            var r = n.params.depsCount;
            t += "应当拥有属性" + n.params.property + "的依赖属性" + n.params.deps;
            break;
          case "discriminator":
            switch (n.params.error) {
              case "tag":
                t = '标签 "' + n.params.tag + '" 的类型必须为字符串';
                break;
              case "mapping":
                t = '标签 "' + n.params.tag + '" 的值必须在 oneOf 之中';
                break;
              default:
                t = '应当通过 "' + n.keyword + ' 关键词校验"';
            }
            break;
          case "enum":
            t = "应当是预设定的枚举值之一";
            break;
          case "false schema":
            t = "布尔模式出错";
            break;
          case "format":
            t = '应当匹配格式 "' + n.params.format + '"';
            break;
          case "formatMaximum":
          case "formatExclusiveMaximum":
            t = "";
            var i = n.params.comparison + " " + n.params.limit;
            t += "应当是 " + i;
            break;
          case "formatMinimum":
          case "formatExclusiveMinimum":
            t = "";
            var i = n.params.comparison + " " + n.params.limit;
            t += "应当是 " + i;
            break;
          case "if":
            t = '应当匹配模式 "' + n.params.failingKeyword + '" ';
            break;
          case "maximum":
          case "exclusiveMaximum":
            t = "";
            var i = n.params.comparison + " " + n.params.limit;
            t += "应当为 " + i;
            break;
          case "maxItems":
            t = "";
            var r = n.params.limit;
            t += "不应多于 " + r + " 个项";
            break;
          case "maxLength":
            t = "";
            var r = n.params.limit;
            t += "不应多于 " + r + " 个字符";
            break;
          case "maxProperties":
            t = "";
            var r = n.params.limit;
            t += "不应有多于 " + r + " 个属性";
            break;
          case "minimum":
          case "exclusiveMinimum":
            t = "";
            var i = n.params.comparison + " " + n.params.limit;
            t += "应当为 " + i;
            break;
          case "minItems":
            t = "";
            var r = n.params.limit;
            t += "不应少于 " + r + " 个项";
            break;
          case "minLength":
            t = "";
            var r = n.params.limit;
            t += "不应少于 " + r + " 个字符";
            break;
          case "minProperties":
            t = "";
            var r = n.params.limit;
            t += "不应有少于 " + r + " 个属性";
            break;
          case "multipleOf":
            t = "应当是 " + n.params.multipleOf + " 的整数倍";
            break;
          case "not":
            t = '不应当匹配 "not" schema';
            break;
          case "oneOf":
            t = '只能匹配一个 "oneOf" 中的 schema';
            break;
          case "pattern":
            t = '应当匹配模式 "' + n.params.pattern + '"';
            break;
          case "patternRequired":
            t = "应当有属性匹配模式 " + n.params.missingPattern;
            break;
          case "propertyNames":
            t = "属性名 无效";
            break;
          case "required":
            t = "应当有必需属性 " + n.params.missingProperty;
            break;
          case "type":
            t = "应当是 " + n.params.type + " 类型";
            break;
          case "unevaluatedItems":
            t = "";
            var r = n.params.len;
            t += " 不允许有超过 " + r + " 个元素";
            break;
          case "unevaluatedProperties":
            t = "不允许存在未求值的属性";
            break;
          case "uniqueItems":
            t = "不应当含有重复项 (第 " + n.params.j + " 项与第 " + n.params.i + " 项是重复的)";
            break;
          default:
            t = '应当通过 "' + n.keyword + ' 关键词校验"';
        }
        n.message = t;
      }
  }), wl;
}
var Sl, xc;
function zy() {
  return xc || (xc = 1, Sl = function(a) {
    if (a && a.length)
      for (const n of a) {
        let t;
        switch (n.keyword) {
          case "additionalItems":
          case "items":
            t = "";
            var r = n.params.limit;
            t += "不可以超過" + r + "個元素";
            break;
          case "additionalProperties":
            t = "不可以有額外的屬性";
            break;
          case "anyOf":
            t = "不符合 anyOf 指定的模式";
            break;
          case "const":
            t = "應該等於常數";
            break;
          case "contains":
            t = "應該包含一個有效元素";
            break;
          case "dependencies":
          case "dependentRequired":
            t = "";
            var r = n.params.depsCount;
            t += "應該要有屬性" + n.params.property + "的依賴屬性" + n.params.deps;
            break;
          case "discriminator":
            switch (n.params.error) {
              case "tag":
                t = '標籤 "' + n.params.tag + '" 的類型必須是字串';
                break;
              case "mapping":
                t = '標籤 "' + n.params.tag + '" 必須在 oneOf 其中之一';
                break;
              default:
                t = '應該通過 "' + n.keyword + ' 關鍵詞檢驗"';
            }
            break;
          case "enum":
            t = "應該要在預設的值之中";
            break;
          case "false schema":
            t = "布林模式不正確";
            break;
          case "format":
            t = "應該要符合" + n.params.format + "格式";
            break;
          case "formatMaximum":
          case "formatExclusiveMaximum":
            t = "";
            var i = n.params.comparison + " " + n.params.limit;
            t += "應該是 " + i;
            break;
          case "formatMinimum":
          case "formatExclusiveMinimum":
            t = "";
            var i = n.params.comparison + " " + n.params.limit;
            t += "應該是 " + i;
            break;
          case "if":
            t = '應該符合 "' + n.params.failingKeyword + '" schema';
            break;
          case "maximum":
          case "exclusiveMaximum":
            t = "";
            var i = n.params.comparison + " " + n.params.limit;
            t += "應該要 " + i;
            break;
          case "maxItems":
            t = "";
            var r = n.params.limit;
            t += "不應該多於 " + r + " 個";
            break;
          case "maxLength":
            t = "";
            var r = n.params.limit;
            t += "不應該多於 " + r + " 個字元";
            break;
          case "maxProperties":
            t = "";
            var r = n.params.limit;
            t += "不應該多於 " + r + " 個屬性";
            break;
          case "minimum":
          case "exclusiveMinimum":
            t = "";
            var i = n.params.comparison + " " + n.params.limit;
            t += "應該要 " + i;
            break;
          case "minItems":
            t = "";
            var r = n.params.limit;
            t += "不應該少於 " + r + " 個";
            break;
          case "minLength":
            t = "";
            var r = n.params.limit;
            t += "不應該少於 " + r + " 個字元";
            break;
          case "minProperties":
            t = "";
            var r = n.params.limit;
            t += "不應該少於 " + r + " 個屬性";
            break;
          case "multipleOf":
            t = "應該是 " + n.params.multipleOf + " 的整數倍";
            break;
          case "not":
            t = '不應該符合 "not" schema';
            break;
          case "oneOf":
            t = '只能符合一個 "oneOf" 中的 schema';
            break;
          case "pattern":
            t = '應該符合模式 "' + n.params.pattern + '"';
            break;
          case "patternRequired":
            t = "應該有屬性對應模式 " + n.params.missingPattern;
            break;
          case "propertyNames":
            t = "属性名 無效";
            break;
          case "required":
            t = "應該有必須屬性 " + n.params.missingProperty;
            break;
          case "type":
            t = "應該是 " + n.params.type + " 類型";
            break;
          case "unevaluatedItems":
            t = "";
            var r = n.params.len;
            t += " 的元素不可以超過 " + r + " 個";
            break;
          case "unevaluatedProperties":
            t = "不應該有未驗證的屬性";
            break;
          case "uniqueItems":
            t = "不應該有重複項目 (第 " + n.params.j + " 項和第 " + n.params.i + " 項是重複的)";
            break;
          default:
            t = '應該通過 "' + n.keyword + ' 關鍵詞檢驗"';
        }
        n.message = t;
      }
  }), Sl;
}
var $l, Vc;
function By() {
  return Vc || (Vc = 1, $l = {
    en: by(),
    ar: ky(),
    ca: wy(),
    cs: Sy(),
    de: $y(),
    es: _y(),
    fi: Py(),
    fr: Cy(),
    hu: xy(),
    id: Vy(),
    it: Iy(),
    ja: Oy(),
    ko: Ey(),
    nb: Ay(),
    nl: Ty(),
    pl: jy(),
    "pt-BR": Dy(),
    ru: My(),
    sk: Ry(),
    sv: Ny(),
    th: Ly(),
    zh: qy(),
    "zh-TW": zy()
  }), $l;
}
var Fy = By();
const Ky = /* @__PURE__ */ xr(Fy);
function Hy(e) {
  return typeof e == "string";
}
function Uy(e) {
  return typeof e == "object" && "switch" in e;
}
function Wy(e) {
  return Array.isArray(e);
}
function Gy(e) {
  return typeof e != "string" && "children" in e;
}
function Ic(e) {
  return typeof e != "string" && ("text" in e || "markdown" in e || "name" in e);
}
function Yy(e) {
  return typeof e == "object" && !Array.isArray(e);
}
function Xy(e) {
  return typeof e == "string" || !!e.expr;
}
function _l(e) {
  return typeof e == "object";
}
function Ym(e) {
  return typeof e == "object" && !!e.url;
}
function Zy(e) {
  return typeof e == "object" && !!/** @type {any} */
  e.markdown;
}
function Jy(e) {
  return typeof e == "object" && !!/** @type {any} */
  e.text;
}
function Qy(e) {
  return typeof e == "object" && !!/** @type {any} */
  e.name;
}
function Ja(e) {
  return typeof e == "object" && "switch" in e;
}
function eg(e) {
  return !Ja(e);
}
function Xm(e) {
  return "comp" in e && "children" in e;
}
function tg(e) {
  return "comp" in e && e.comp === "slot";
}
function lr(e, a) {
  return !!a[e.comp]?.composite;
}
function Zm(e) {
  return e.comp === "list";
}
function ag(e, a) {
  return !!a[e.comp]?.focusable;
}
function or(e, a) {
  return !!a[e.comp]?.itemsBased;
}
function Xo(e) {
  return !!e.expr;
}
function Zo(e) {
  return !!e.url;
}
function Oc(e) {
  return !!e.text;
}
function ng(e) {
  return !!e.markdown;
}
function rg(e) {
  return !!e.name;
}
function ig(e) {
  return e.header;
}
function sg(e) {
  return !e.header;
}
const lg = [
  {
    name: "none"
  },
  {
    name: "slot"
  },
  {
    name: "composite-slot",
    composite: !0
  },
  {
    name: "section",
    composite: !0
  },
  {
    name: "tabs",
    composite: !0
  },
  {
    name: "vertical-tabs",
    composite: !0
  },
  {
    name: "expansion-panels",
    composite: !0
  },
  {
    name: "stepper",
    composite: !0
  },
  {
    name: "card",
    composite: !0
  },
  {
    name: "list",
    itemsBased: !0,
    schema: {
      required: ["listEditMode", "listActions"],
      properties: {
        title: { type: "string" },
        listEditMode: { type: "string", enum: ["inline", "inline-single", "menu", "dialog"] },
        listActions: { type: "array", items: { type: "string", enum: ["add", "edit", "delete", "sort", "duplicate", "copy", "paste"] } },
        clipboardKey: { type: "string" },
        itemTitle: { $ref: "https://json-layout.github.io/normalized-layout-keyword#/$defs/expression" },
        itemSubtitle: { $ref: "https://json-layout.github.io/normalized-layout-keyword#/$defs/expression" },
        itemCopy: { $ref: "https://json-layout.github.io/normalized-layout-keyword#/$defs/expression" },
        indexed: { type: "array", items: { type: "string" } },
        messages: {
          type: "object",
          additionalProperties: !1,
          properties: {
            addItem: { type: "string" },
            delete: { type: "string" },
            edit: { type: "string" },
            duplicate: { type: "string" },
            sort: { type: "string" }
          }
        }
      }
    }
  },
  {
    name: "text-field",
    shouldDebounce: !0,
    focusable: !0,
    emitsBlur: !0,
    schema: {
      properties: {
        placeholder: { type: "string" }
      }
    }
  },
  {
    name: "textarea",
    shouldDebounce: !0,
    focusable: !0,
    emitsBlur: !0,
    schema: {
      properties: {
        placeholder: { type: "string" },
        rows: { type: "number" }
      }
    }
  },
  {
    name: "number-field",
    shouldDebounce: !0,
    focusable: !0,
    // number inputs can emit blur events, but not always a specific event when clicking on up/down arrows
    // in this case updateOn: blur cannot be made to work properly, that is why we do not set emitsBlur to true
    // emitsBlur: true,
    schema: {
      properties: {
        step: { type: "number" },
        min: { type: "number" },
        max: { type: "number" },
        precision: { type: "number" },
        placeholder: { type: "string" }
      }
    }
  },
  {
    name: "checkbox"
  },
  {
    name: "switch"
  },
  {
    name: "slider",
    shouldDebounce: !0,
    schema: {
      properties: {
        step: { type: "number" },
        min: { type: "number" },
        max: { type: "number" }
      }
    }
  },
  {
    name: "date-picker",
    schema: {
      properties: {
        min: { type: "string", format: "date" },
        max: { type: "string", format: "date" },
        format: { type: "string", enum: ["date", "date-time"], default: "date" }
      }
    }
  },
  {
    name: "date-time-picker",
    schema: {
      properties: {
        min: { type: "string", format: "date-time" },
        max: { type: "string", format: "date-time" }
      }
    }
  },
  {
    name: "time-picker",
    schema: {
      properties: {
        min: { type: "string", format: "time" },
        max: { type: "string", format: "time" }
      }
    }
  },
  {
    name: "color-picker",
    shouldDebounce: !0
  },
  {
    name: "select",
    focusable: !0,
    itemsBased: !0,
    multipleCompat: !0,
    schema: {
      properties: {
        placeholder: { type: "string" }
      }
    }
  },
  {
    name: "autocomplete",
    focusable: !0,
    itemsBased: !0,
    multipleCompat: !0,
    schema: {
      properties: {
        placeholder: { type: "string" }
      }
    }
  },
  {
    name: "combobox",
    focusable: !0,
    itemsBased: !0,
    multipleCompat: !0,
    schema: {
      properties: {
        placeholder: { type: "string" }
      }
    }
  },
  {
    name: "number-combobox",
    focusable: !0,
    itemsBased: !0,
    multipleCompat: !0,
    schema: {
      properties: {
        placeholder: { type: "string" },
        step: { type: "number" },
        min: { type: "number" },
        max: { type: "number" }
      }
    }
  },
  {
    name: "checkbox-group",
    itemsBased: !0,
    multipleCompat: !0
  },
  {
    name: "switch-group",
    itemsBased: !0,
    multipleCompat: !0
  },
  {
    name: "radio-group",
    itemsBased: !0
  },
  {
    name: "file-input",
    focusable: !0,
    multipleCompat: !0,
    isFileInput: !0,
    schema: {
      properties: {
        accept: { type: "string" },
        placeholder: { type: "string" }
      }
    }
  },
  {
    name: "one-of-select",
    schema: {
      required: ["oneOfItems"],
      properties: {
        emptyData: { type: "boolean" },
        oneOfItems: {
          type: "array",
          items: {
            $ref: "https://json-layout.github.io/normalized-layout-keyword#/$defs/one-of-item"
          }
        }
      }
    }
  }
];
function og(e) {
  const a = {
    type: "object",
    title: e.name,
    $id: `https://json-layout.github.io/component/${e.name}#`,
    unevaluatedProperties: !1,
    allOf: [
      { properties: { comp: { const: e.name } } },
      { $ref: "https://json-layout.github.io/normalized-layout-keyword#/$defs/base-comp-object" }
    ]
  };
  return e.composite ? a.allOf.push({ $ref: "https://json-layout.github.io/normalized-layout-keyword#/$defs/composite-comp-object" }) : a.allOf.push({ $ref: "https://json-layout.github.io/normalized-layout-keyword#/$defs/simple-comp-object" }), e.focusable && a.allOf.push({ $ref: "https://json-layout.github.io/normalized-layout-keyword#/$defs/focusable-comp-object" }), e.itemsBased && a.allOf.push({ $ref: "https://json-layout.github.io/normalized-layout-keyword#/$defs/items-based-comp-object" }), e.multipleCompat && a.allOf.push({ $ref: "https://json-layout.github.io/normalized-layout-keyword#/$defs/multiple-compat-comp-object" }), e.schema && a.allOf.push(e.schema), a;
}
function Ec(e) {
  return e instanceof Buffer ? Buffer.from(e) : new e.constructor(e.buffer.slice(), e.byteOffset, e.length);
}
function ug() {
  return a;
  function e(i, r) {
    const n = Object.keys(i), t = new Array(n.length);
    for (let s = 0; s < n.length; s++) {
      const o = n[s], l = i[o];
      typeof l != "object" || l === null ? t[o] = l : l instanceof Date ? t[o] = new Date(l) : ArrayBuffer.isView(l) ? t[o] = Ec(l) : t[o] = r(l);
    }
    return t;
  }
  function a(i) {
    if (typeof i != "object" || i === null) return i;
    if (i instanceof Date) return new Date(i);
    if (Array.isArray(i)) return e(i, a);
    if (i instanceof Map) return new Map(e(Array.from(i), a));
    if (i instanceof Set) return new Set(e(Array.from(i), a));
    const r = {};
    for (const n in i) {
      if (Object.hasOwnProperty.call(i, n) === !1) continue;
      const t = i[n];
      typeof t != "object" || t === null ? r[n] = t : t instanceof Date ? r[n] = new Date(t) : t instanceof Map ? r[n] = new Map(e(Array.from(t), a)) : t instanceof Set ? r[n] = new Set(e(Array.from(t), a)) : ArrayBuffer.isView(t) ? r[n] = Ec(t) : r[n] = a(t);
    }
    return r;
  }
}
const na = ug(), Jm = {
  $id: "https://json-layout.github.io/layout-keyword",
  $defs: {
    "layout-keyword": {
      title: "layout keyword",
      errorMessage: {
        anyOf: "layout keyword must be a string with a valid component name, or a more complete object definition, or an array of children, or a switch structure"
      },
      anyOf: [
        {
          $ref: "#/$defs/comp-name"
        },
        {
          $ref: "#/$defs/partial-children"
        },
        {
          $ref: "#/$defs/partial-comp-object"
        },
        {
          $ref: "#/$defs/partial-switch"
        }
      ]
    },
    "partial-switch": {
      type: "object",
      required: [
        "switch"
      ],
      additionalProperties: !1,
      properties: {
        switch: {
          type: "array",
          items: {
            $ref: "#/$defs/partial-comp-object"
          }
        }
      }
    },
    "partial-comp-object": {
      title: "partial comp object",
      type: "object",
      properties: {
        comp: {
          $ref: "#/$defs/comp-name"
        },
        help: {
          type: "string"
        },
        children: {
          $ref: "#/$defs/partial-children"
        },
        label: {
          type: "string"
        },
        hint: {
          type: [
            "string",
            "null"
          ]
        },
        title: {
          type: [
            "string",
            "null"
          ]
        },
        subtitle: {
          type: [
            "string",
            "null"
          ]
        },
        step: {
          type: "number"
        },
        if: {
          $ref: "#/$defs/partial-expression"
        },
        itemTitle: {
          $ref: "#/$defs/partial-expression"
        },
        itemSubtitle: {
          $ref: "#/$defs/partial-expression"
        },
        itemCopy: {
          $ref: "#/$defs/partial-expression"
        },
        items: {
          type: "array",
          items: {
            $ref: "#/$defs/partial-select-item"
          }
        },
        oneOfItems: {
          type: "array",
          items: {
            $ref: "#/$defs/partial-one-of-item"
          }
        },
        getItems: {
          $ref: "#/$defs/partial-get-items"
        },
        listEditMode: {
          type: "string",
          enum: [
            "inline",
            "inline-single",
            "menu",
            "dialog"
          ]
        },
        listActions: {
          type: "array",
          items: {
            type: "string",
            enum: [
              "add",
              "edit",
              "delete",
              "sort",
              "duplicate",
              "copy",
              "paste"
            ]
          }
        },
        clipboardKey: {
          type: "string"
        },
        cols: {
          $ref: "#/$defs/partial-cols"
        },
        props: {
          type: "object"
        },
        getProps: {
          $ref: "#/$defs/partial-expression"
        },
        slots: {
          type: "object",
          patternProperties: {
            ".*": {
              $ref: "#/$defs/partial-slot"
            }
          }
        },
        options: {
          type: "object"
        },
        getOptions: {
          $ref: "#/$defs/partial-expression"
        },
        messages: {
          type: "object"
        },
        defaultData: {},
        getDefaultData: {
          $ref: "#/$defs/partial-expression"
        },
        constData: {},
        getConstData: {
          $ref: "#/$defs/partial-expression"
        },
        transformData: {
          $ref: "#/$defs/partial-expression"
        },
        autofocus: {
          type: "boolean"
        },
        separator: {
          type: "string"
        }
      }
    },
    "comp-name": {
      title: "component name",
      type: "string"
    },
    "partial-child-ref": {
      type: "object",
      required: [
        "key"
      ],
      additionalProperties: !1,
      properties: {
        key: {
          type: [
            "string",
            "integer"
          ]
        },
        cols: {
          $ref: "#/$defs/partial-cols"
        },
        if: {
          $ref: "#/$defs/partial-expression"
        },
        slots: {
          type: "object",
          patternProperties: {
            ".*": {
              $ref: "#/$defs/partial-slot"
            }
          }
        }
      }
    },
    "partial-child-composite": {
      type: "object",
      required: [
        "children"
      ],
      properties: {
        comp: {
          type: "string"
        },
        title: {
          type: [
            "string",
            "null"
          ]
        },
        subtitle: {
          type: [
            "string",
            "null"
          ]
        },
        children: {
          $ref: "#/$defs/partial-children"
        },
        cols: {
          $ref: "#/$defs/partial-cols"
        },
        if: {
          $ref: "#/$defs/partial-expression"
        },
        props: {
          type: "object"
        },
        getProps: {
          $ref: "#/$defs/partial-expression"
        },
        slots: {
          type: "object",
          patternProperties: {
            ".*": {
              $ref: "#/$defs/partial-slot"
            }
          }
        }
      }
    },
    "partial-child-slot": {
      type: "object",
      properties: {
        cols: {
          $ref: "#/$defs/partial-cols"
        },
        if: {
          $ref: "#/$defs/partial-expression"
        }
      },
      oneOf: [
        {
          $ref: "#/$defs/partial-slot-text"
        },
        {
          $ref: "#/$defs/partial-slot-markdown"
        },
        {
          $ref: "#/$defs/partial-slot-name"
        }
      ]
    },
    "partial-child": {
      anyOf: [
        {
          type: "string"
        },
        {
          type: "array",
          items: {
            $ref: "#/$defs/partial-child"
          }
        },
        {
          $ref: "#/$defs/partial-child-ref"
        },
        {
          $ref: "#/$defs/partial-child-composite"
        },
        {
          $ref: "#/$defs/partial-child-slot"
        }
      ]
    },
    "partial-children": {
      type: "array",
      items: {
        $ref: "#/$defs/partial-child"
      }
    },
    "partial-expression": {
      oneOf: [
        {
          type: "string"
        },
        {
          $ref: "#/$defs/partial-expression-obj"
        }
      ]
    },
    "partial-expression-obj": {
      type: "object",
      required: [
        "expr"
      ],
      properties: {
        type: {
          type: "string",
          enum: [
            "js-fn",
            "js-eval",
            "js-tpl"
          ]
        },
        expr: {
          type: "string"
        }
      }
    },
    "partial-select-item": {
      oneOf: [
        {
          type: "string"
        },
        {
          type: "object",
          properties: {
            header: {
              type: "string"
            },
            key: {
              type: "string"
            },
            title: {
              type: "string"
            },
            icon: {
              type: "string"
            },
            value: {}
          }
        }
      ]
    },
    "partial-get-items": {
      oneOf: [
        {
          type: "string"
        },
        {
          $ref: "#/$defs/partial-get-items-obj"
        }
      ]
    },
    "partial-get-items-obj": {
      type: "object",
      allOf: [
        {
          properties: {
            itemHeader: {
              $ref: "#/$defs/partial-expression"
            },
            itemTitle: {
              $ref: "#/$defs/partial-expression"
            },
            itemKey: {
              $ref: "#/$defs/partial-expression"
            },
            itemValue: {
              $ref: "#/$defs/partial-expression"
            },
            itemIcon: {
              $ref: "#/$defs/partial-expression"
            },
            itemsResults: {
              $ref: "#/$defs/partial-expression"
            }
          }
        },
        {
          anyOf: [
            {
              type: "object"
            },
            {
              $ref: "#/$defs/partial-expression-obj"
            },
            {
              $ref: "#/$defs/partial-get-items-fetch"
            }
          ]
        }
      ]
    },
    "partial-get-items-fetch": {
      type: "object",
      required: [
        "url"
      ],
      properties: {
        url: {
          $ref: "#/$defs/partial-expression"
        },
        searchParams: {
          type: "object",
          patternProperties: {
            ".*": {
              $ref: "#/$defs/partial-expression"
            }
          }
        },
        headers: {
          type: "object",
          patternProperties: {
            ".*": {
              $ref: "#/$defs/partial-expression"
            }
          }
        }
      }
    },
    "partial-one-of-item": {
      oneOf: [
        {
          type: "string"
        },
        {
          type: "object",
          properties: {
            header: {
              type: "string"
            },
            key: {
              type: "number"
            },
            title: {
              type: "string"
            },
            icon: {
              type: "string"
            }
          }
        }
      ]
    },
    "partial-cols": {
      oneOf: [
        {
          $ref: "#/$defs/partial-cols-number"
        },
        {
          $ref: "#/$defs/partial-cols-obj"
        }
      ]
    },
    "partial-cols-obj": {
      type: "object",
      additionalProperties: !1,
      properties: {
        xs: {
          $ref: "#/$defs/partial-cols-number"
        },
        sm: {
          $ref: "#/$defs/partial-cols-number"
        },
        md: {
          $ref: "#/$defs/partial-cols-number"
        },
        lg: {
          $ref: "#/$defs/partial-cols-number"
        },
        xl: {
          $ref: "#/$defs/partial-cols-number"
        },
        xxl: {
          $ref: "#/$defs/partial-cols-number"
        }
      }
    },
    "partial-cols-number": {
      type: "integer",
      minimum: 0,
      maximum: 12
    },
    "partial-slot": {
      oneOf: [
        {
          type: "string"
        },
        {
          $ref: "#/$defs/partial-slot-text"
        },
        {
          $ref: "#/$defs/partial-slot-markdown"
        },
        {
          $ref: "#/$defs/partial-slot-name"
        }
      ]
    },
    "partial-slot-text": {
      type: "object",
      additionalProperties: !1,
      required: [
        "text"
      ],
      properties: {
        text: {
          type: "string"
        }
      }
    },
    "partial-slot-markdown": {
      type: "object",
      additionalProperties: !1,
      required: [
        "markdown"
      ],
      properties: {
        markdown: {
          type: "string"
        }
      }
    },
    "partial-slot-name": {
      type: "object",
      additionalProperties: !1,
      required: [
        "name"
      ],
      properties: {
        name: {
          type: "string"
        },
        props: {
          type: "object"
        }
      }
    }
  }
};
var Fr = { exports: {} }, Pl = {}, ka = {}, Ha = {}, Cl = {}, xl = {}, Vl = {}, Ac;
function fr() {
  return Ac || (Ac = 1, (function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.regexpCode = e.getEsmExportName = e.getProperty = e.safeStringify = e.stringify = e.strConcat = e.addCodeArg = e.str = e._ = e.nil = e._Code = e.Name = e.IDENTIFIER = e._CodeOrName = void 0;
    class a {
    }
    e._CodeOrName = a, e.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
    class i extends a {
      constructor(p) {
        if (super(), !e.IDENTIFIER.test(p))
          throw new Error("CodeGen: name must be a valid identifier");
        this.str = p;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        return !1;
      }
      get names() {
        return { [this.str]: 1 };
      }
    }
    e.Name = i;
    class r extends a {
      constructor(p) {
        super(), this._items = typeof p == "string" ? [p] : p;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        if (this._items.length > 1)
          return !1;
        const p = this._items[0];
        return p === "" || p === '""';
      }
      get str() {
        var p;
        return (p = this._str) !== null && p !== void 0 ? p : this._str = this._items.reduce((b, w) => `${b}${w}`, "");
      }
      get names() {
        var p;
        return (p = this._names) !== null && p !== void 0 ? p : this._names = this._items.reduce((b, w) => (w instanceof i && (b[w.str] = (b[w.str] || 0) + 1), b), {});
      }
    }
    e._Code = r, e.nil = new r("");
    function n(m, ...p) {
      const b = [m[0]];
      let w = 0;
      for (; w < p.length; )
        o(b, p[w]), b.push(m[++w]);
      return new r(b);
    }
    e._ = n;
    const t = new r("+");
    function s(m, ...p) {
      const b = [v(m[0])];
      let w = 0;
      for (; w < p.length; )
        b.push(t), o(b, p[w]), b.push(t, v(m[++w]));
      return l(b), new r(b);
    }
    e.str = s;
    function o(m, p) {
      p instanceof r ? m.push(...p._items) : p instanceof i ? m.push(p) : m.push(d(p));
    }
    e.addCodeArg = o;
    function l(m) {
      let p = 1;
      for (; p < m.length - 1; ) {
        if (m[p] === t) {
          const b = u(m[p - 1], m[p + 1]);
          if (b !== void 0) {
            m.splice(p - 1, 3, b);
            continue;
          }
          m[p++] = "+";
        }
        p++;
      }
    }
    function u(m, p) {
      if (p === '""')
        return m;
      if (m === '""')
        return p;
      if (typeof m == "string")
        return p instanceof i || m[m.length - 1] !== '"' ? void 0 : typeof p != "string" ? `${m.slice(0, -1)}${p}"` : p[0] === '"' ? m.slice(0, -1) + p.slice(1) : void 0;
      if (typeof p == "string" && p[0] === '"' && !(m instanceof i))
        return `"${m}${p.slice(1)}`;
    }
    function c(m, p) {
      return p.emptyStr() ? m : m.emptyStr() ? p : s`${m}${p}`;
    }
    e.strConcat = c;
    function d(m) {
      return typeof m == "number" || typeof m == "boolean" || m === null ? m : v(Array.isArray(m) ? m.join(",") : m);
    }
    function f(m) {
      return new r(v(m));
    }
    e.stringify = f;
    function v(m) {
      return JSON.stringify(m).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
    }
    e.safeStringify = v;
    function g(m) {
      return typeof m == "string" && e.IDENTIFIER.test(m) ? new r(`.${m}`) : n`[${m}]`;
    }
    e.getProperty = g;
    function h(m) {
      if (typeof m == "string" && e.IDENTIFIER.test(m))
        return new r(`${m}`);
      throw new Error(`CodeGen: invalid export name: ${m}, use explicit $id name mapping`);
    }
    e.getEsmExportName = h;
    function y(m) {
      return new r(m.toString());
    }
    e.regexpCode = y;
  })(Vl)), Vl;
}
var Il = {}, Tc;
function jc() {
  return Tc || (Tc = 1, (function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.ValueScope = e.ValueScopeName = e.Scope = e.varKinds = e.UsedValueState = void 0;
    const a = fr();
    class i extends Error {
      constructor(u) {
        super(`CodeGen: "code" for ${u} not defined`), this.value = u.value;
      }
    }
    var r;
    (function(l) {
      l[l.Started = 0] = "Started", l[l.Completed = 1] = "Completed";
    })(r || (e.UsedValueState = r = {})), e.varKinds = {
      const: new a.Name("const"),
      let: new a.Name("let"),
      var: new a.Name("var")
    };
    class n {
      constructor({ prefixes: u, parent: c } = {}) {
        this._names = {}, this._prefixes = u, this._parent = c;
      }
      toName(u) {
        return u instanceof a.Name ? u : this.name(u);
      }
      name(u) {
        return new a.Name(this._newName(u));
      }
      _newName(u) {
        const c = this._names[u] || this._nameGroup(u);
        return `${u}${c.index++}`;
      }
      _nameGroup(u) {
        var c, d;
        if (!((d = (c = this._parent) === null || c === void 0 ? void 0 : c._prefixes) === null || d === void 0) && d.has(u) || this._prefixes && !this._prefixes.has(u))
          throw new Error(`CodeGen: prefix "${u}" is not allowed in this scope`);
        return this._names[u] = { prefix: u, index: 0 };
      }
    }
    e.Scope = n;
    class t extends a.Name {
      constructor(u, c) {
        super(c), this.prefix = u;
      }
      setValue(u, { property: c, itemIndex: d }) {
        this.value = u, this.scopePath = (0, a._)`.${new a.Name(c)}[${d}]`;
      }
    }
    e.ValueScopeName = t;
    const s = (0, a._)`\n`;
    class o extends n {
      constructor(u) {
        super(u), this._values = {}, this._scope = u.scope, this.opts = { ...u, _n: u.lines ? s : a.nil };
      }
      get() {
        return this._scope;
      }
      name(u) {
        return new t(u, this._newName(u));
      }
      value(u, c) {
        var d;
        if (c.ref === void 0)
          throw new Error("CodeGen: ref must be passed in value");
        const f = this.toName(u), { prefix: v } = f, g = (d = c.key) !== null && d !== void 0 ? d : c.ref;
        let h = this._values[v];
        if (h) {
          const p = h.get(g);
          if (p)
            return p;
        } else
          h = this._values[v] = /* @__PURE__ */ new Map();
        h.set(g, f);
        const y = this._scope[v] || (this._scope[v] = []), m = y.length;
        return y[m] = c.ref, f.setValue(c, { property: v, itemIndex: m }), f;
      }
      getValue(u, c) {
        const d = this._values[u];
        if (d)
          return d.get(c);
      }
      scopeRefs(u, c = this._values) {
        return this._reduceValues(c, (d) => {
          if (d.scopePath === void 0)
            throw new Error(`CodeGen: name "${d}" has no value`);
          return (0, a._)`${u}${d.scopePath}`;
        });
      }
      scopeCode(u = this._values, c, d) {
        return this._reduceValues(u, (f) => {
          if (f.value === void 0)
            throw new Error(`CodeGen: name "${f}" has no value`);
          return f.value.code;
        }, c, d);
      }
      _reduceValues(u, c, d = {}, f) {
        let v = a.nil;
        for (const g in u) {
          const h = u[g];
          if (!h)
            continue;
          const y = d[g] = d[g] || /* @__PURE__ */ new Map();
          h.forEach((m) => {
            if (y.has(m))
              return;
            y.set(m, r.Started);
            let p = c(m);
            if (p) {
              const b = this.opts.es5 ? e.varKinds.var : e.varKinds.const;
              v = (0, a._)`${v}${b} ${m} = ${p};${this.opts._n}`;
            } else if (p = f?.(m))
              v = (0, a._)`${v}${p}${this.opts._n}`;
            else
              throw new i(m);
            y.set(m, r.Completed);
          });
        }
        return v;
      }
    }
    e.ValueScope = o;
  })(Il)), Il;
}
var Dc;
function Ie() {
  return Dc || (Dc = 1, (function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.or = e.and = e.not = e.CodeGen = e.operators = e.varKinds = e.ValueScopeName = e.ValueScope = e.Scope = e.Name = e.regexpCode = e.stringify = e.getProperty = e.nil = e.strConcat = e.str = e._ = void 0;
    const a = fr(), i = jc();
    var r = fr();
    Object.defineProperty(e, "_", { enumerable: !0, get: function() {
      return r._;
    } }), Object.defineProperty(e, "str", { enumerable: !0, get: function() {
      return r.str;
    } }), Object.defineProperty(e, "strConcat", { enumerable: !0, get: function() {
      return r.strConcat;
    } }), Object.defineProperty(e, "nil", { enumerable: !0, get: function() {
      return r.nil;
    } }), Object.defineProperty(e, "getProperty", { enumerable: !0, get: function() {
      return r.getProperty;
    } }), Object.defineProperty(e, "stringify", { enumerable: !0, get: function() {
      return r.stringify;
    } }), Object.defineProperty(e, "regexpCode", { enumerable: !0, get: function() {
      return r.regexpCode;
    } }), Object.defineProperty(e, "Name", { enumerable: !0, get: function() {
      return r.Name;
    } });
    var n = jc();
    Object.defineProperty(e, "Scope", { enumerable: !0, get: function() {
      return n.Scope;
    } }), Object.defineProperty(e, "ValueScope", { enumerable: !0, get: function() {
      return n.ValueScope;
    } }), Object.defineProperty(e, "ValueScopeName", { enumerable: !0, get: function() {
      return n.ValueScopeName;
    } }), Object.defineProperty(e, "varKinds", { enumerable: !0, get: function() {
      return n.varKinds;
    } }), e.operators = {
      GT: new a._Code(">"),
      GTE: new a._Code(">="),
      LT: new a._Code("<"),
      LTE: new a._Code("<="),
      EQ: new a._Code("==="),
      NEQ: new a._Code("!=="),
      NOT: new a._Code("!"),
      OR: new a._Code("||"),
      AND: new a._Code("&&"),
      ADD: new a._Code("+")
    };
    class t {
      optimizeNodes() {
        return this;
      }
      optimizeNames($, V) {
        return this;
      }
    }
    class s extends t {
      constructor($, V, F) {
        super(), this.varKind = $, this.name = V, this.rhs = F;
      }
      render({ es5: $, _n: V }) {
        const F = $ ? i.varKinds.var : this.varKind, z = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
        return `${F} ${this.name}${z};` + V;
      }
      optimizeNames($, V) {
        if ($[this.name.str])
          return this.rhs && (this.rhs = B(this.rhs, $, V)), this;
      }
      get names() {
        return this.rhs instanceof a._CodeOrName ? this.rhs.names : {};
      }
    }
    class o extends t {
      constructor($, V, F) {
        super(), this.lhs = $, this.rhs = V, this.sideEffects = F;
      }
      render({ _n: $ }) {
        return `${this.lhs} = ${this.rhs};` + $;
      }
      optimizeNames($, V) {
        if (!(this.lhs instanceof a.Name && !$[this.lhs.str] && !this.sideEffects))
          return this.rhs = B(this.rhs, $, V), this;
      }
      get names() {
        const $ = this.lhs instanceof a.Name ? {} : { ...this.lhs.names };
        return H($, this.rhs);
      }
    }
    class l extends o {
      constructor($, V, F, z) {
        super($, F, z), this.op = V;
      }
      render({ _n: $ }) {
        return `${this.lhs} ${this.op}= ${this.rhs};` + $;
      }
    }
    class u extends t {
      constructor($) {
        super(), this.label = $, this.names = {};
      }
      render({ _n: $ }) {
        return `${this.label}:` + $;
      }
    }
    class c extends t {
      constructor($) {
        super(), this.label = $, this.names = {};
      }
      render({ _n: $ }) {
        return `break${this.label ? ` ${this.label}` : ""};` + $;
      }
    }
    class d extends t {
      constructor($) {
        super(), this.error = $;
      }
      render({ _n: $ }) {
        return `throw ${this.error};` + $;
      }
      get names() {
        return this.error.names;
      }
    }
    class f extends t {
      constructor($) {
        super(), this.code = $;
      }
      render({ _n: $ }) {
        return `${this.code};` + $;
      }
      optimizeNodes() {
        return `${this.code}` ? this : void 0;
      }
      optimizeNames($, V) {
        return this.code = B(this.code, $, V), this;
      }
      get names() {
        return this.code instanceof a._CodeOrName ? this.code.names : {};
      }
    }
    class v extends t {
      constructor($ = []) {
        super(), this.nodes = $;
      }
      render($) {
        return this.nodes.reduce((V, F) => V + F.render($), "");
      }
      optimizeNodes() {
        const { nodes: $ } = this;
        let V = $.length;
        for (; V--; ) {
          const F = $[V].optimizeNodes();
          Array.isArray(F) ? $.splice(V, 1, ...F) : F ? $[V] = F : $.splice(V, 1);
        }
        return $.length > 0 ? this : void 0;
      }
      optimizeNames($, V) {
        const { nodes: F } = this;
        let z = F.length;
        for (; z--; ) {
          const X = F[z];
          X.optimizeNames($, V) || (L($, X.names), F.splice(z, 1));
        }
        return F.length > 0 ? this : void 0;
      }
      get names() {
        return this.nodes.reduce(($, V) => j($, V.names), {});
      }
    }
    class g extends v {
      render($) {
        return "{" + $._n + super.render($) + "}" + $._n;
      }
    }
    class h extends v {
    }
    class y extends g {
    }
    y.kind = "else";
    class m extends g {
      constructor($, V) {
        super(V), this.condition = $;
      }
      render($) {
        let V = `if(${this.condition})` + super.render($);
        return this.else && (V += "else " + this.else.render($)), V;
      }
      optimizeNodes() {
        super.optimizeNodes();
        const $ = this.condition;
        if ($ === !0)
          return this.nodes;
        let V = this.else;
        if (V) {
          const F = V.optimizeNodes();
          V = this.else = Array.isArray(F) ? new y(F) : F;
        }
        if (V)
          return $ === !1 ? V instanceof m ? V : V.nodes : this.nodes.length ? this : new m(O($), V instanceof m ? [V] : V.nodes);
        if (!($ === !1 || !this.nodes.length))
          return this;
      }
      optimizeNames($, V) {
        var F;
        if (this.else = (F = this.else) === null || F === void 0 ? void 0 : F.optimizeNames($, V), !!(super.optimizeNames($, V) || this.else))
          return this.condition = B(this.condition, $, V), this;
      }
      get names() {
        const $ = super.names;
        return H($, this.condition), this.else && j($, this.else.names), $;
      }
    }
    m.kind = "if";
    class p extends g {
    }
    p.kind = "for";
    class b extends p {
      constructor($) {
        super(), this.iteration = $;
      }
      render($) {
        return `for(${this.iteration})` + super.render($);
      }
      optimizeNames($, V) {
        if (super.optimizeNames($, V))
          return this.iteration = B(this.iteration, $, V), this;
      }
      get names() {
        return j(super.names, this.iteration.names);
      }
    }
    class w extends p {
      constructor($, V, F, z) {
        super(), this.varKind = $, this.name = V, this.from = F, this.to = z;
      }
      render($) {
        const V = $.es5 ? i.varKinds.var : this.varKind, { name: F, from: z, to: X } = this;
        return `for(${V} ${F}=${z}; ${F}<${X}; ${F}++)` + super.render($);
      }
      get names() {
        const $ = H(super.names, this.from);
        return H($, this.to);
      }
    }
    class k extends p {
      constructor($, V, F, z) {
        super(), this.loop = $, this.varKind = V, this.name = F, this.iterable = z;
      }
      render($) {
        return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render($);
      }
      optimizeNames($, V) {
        if (super.optimizeNames($, V))
          return this.iterable = B(this.iterable, $, V), this;
      }
      get names() {
        return j(super.names, this.iterable.names);
      }
    }
    class S extends g {
      constructor($, V, F) {
        super(), this.name = $, this.args = V, this.async = F;
      }
      render($) {
        return `${this.async ? "async " : ""}function ${this.name}(${this.args})` + super.render($);
      }
    }
    S.kind = "func";
    class _ extends v {
      render($) {
        return "return " + super.render($);
      }
    }
    _.kind = "return";
    class P extends g {
      render($) {
        let V = "try" + super.render($);
        return this.catch && (V += this.catch.render($)), this.finally && (V += this.finally.render($)), V;
      }
      optimizeNodes() {
        var $, V;
        return super.optimizeNodes(), ($ = this.catch) === null || $ === void 0 || $.optimizeNodes(), (V = this.finally) === null || V === void 0 || V.optimizeNodes(), this;
      }
      optimizeNames($, V) {
        var F, z;
        return super.optimizeNames($, V), (F = this.catch) === null || F === void 0 || F.optimizeNames($, V), (z = this.finally) === null || z === void 0 || z.optimizeNames($, V), this;
      }
      get names() {
        const $ = super.names;
        return this.catch && j($, this.catch.names), this.finally && j($, this.finally.names), $;
      }
    }
    class M extends g {
      constructor($) {
        super(), this.error = $;
      }
      render($) {
        return `catch(${this.error})` + super.render($);
      }
    }
    M.kind = "catch";
    class q extends g {
      render($) {
        return "finally" + super.render($);
      }
    }
    q.kind = "finally";
    class K {
      constructor($, V = {}) {
        this._values = {}, this._blockStarts = [], this._constants = {}, this.opts = { ...V, _n: V.lines ? `
` : "" }, this._extScope = $, this._scope = new i.Scope({ parent: $ }), this._nodes = [new h()];
      }
      toString() {
        return this._root.render(this.opts);
      }
      // returns unique name in the internal scope
      name($) {
        return this._scope.name($);
      }
      // reserves unique name in the external scope
      scopeName($) {
        return this._extScope.name($);
      }
      // reserves unique name in the external scope and assigns value to it
      scopeValue($, V) {
        const F = this._extScope.value($, V);
        return (this._values[F.prefix] || (this._values[F.prefix] = /* @__PURE__ */ new Set())).add(F), F;
      }
      getScopeValue($, V) {
        return this._extScope.getValue($, V);
      }
      // return code that assigns values in the external scope to the names that are used internally
      // (same names that were returned by gen.scopeName or gen.scopeValue)
      scopeRefs($) {
        return this._extScope.scopeRefs($, this._values);
      }
      scopeCode() {
        return this._extScope.scopeCode(this._values);
      }
      _def($, V, F, z) {
        const X = this._scope.toName(V);
        return F !== void 0 && z && (this._constants[X.str] = F), this._leafNode(new s($, X, F)), X;
      }
      // `const` declaration (`var` in es5 mode)
      const($, V, F) {
        return this._def(i.varKinds.const, $, V, F);
      }
      // `let` declaration with optional assignment (`var` in es5 mode)
      let($, V, F) {
        return this._def(i.varKinds.let, $, V, F);
      }
      // `var` declaration with optional assignment
      var($, V, F) {
        return this._def(i.varKinds.var, $, V, F);
      }
      // assignment code
      assign($, V, F) {
        return this._leafNode(new o($, V, F));
      }
      // `+=` code
      add($, V) {
        return this._leafNode(new l($, e.operators.ADD, V));
      }
      // appends passed SafeExpr to code or executes Block
      code($) {
        return typeof $ == "function" ? $() : $ !== a.nil && this._leafNode(new f($)), this;
      }
      // returns code for object literal for the passed argument list of key-value pairs
      object(...$) {
        const V = ["{"];
        for (const [F, z] of $)
          V.length > 1 && V.push(","), V.push(F), (F !== z || this.opts.es5) && (V.push(":"), (0, a.addCodeArg)(V, z));
        return V.push("}"), new a._Code(V);
      }
      // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
      if($, V, F) {
        if (this._blockNode(new m($)), V && F)
          this.code(V).else().code(F).endIf();
        else if (V)
          this.code(V).endIf();
        else if (F)
          throw new Error('CodeGen: "else" body without "then" body');
        return this;
      }
      // `else if` clause - invalid without `if` or after `else` clauses
      elseIf($) {
        return this._elseNode(new m($));
      }
      // `else` clause - only valid after `if` or `else if` clauses
      else() {
        return this._elseNode(new y());
      }
      // end `if` statement (needed if gen.if was used only with condition)
      endIf() {
        return this._endBlockNode(m, y);
      }
      _for($, V) {
        return this._blockNode($), V && this.code(V).endFor(), this;
      }
      // a generic `for` clause (or statement if `forBody` is passed)
      for($, V) {
        return this._for(new b($), V);
      }
      // `for` statement for a range of values
      forRange($, V, F, z, X = this.opts.es5 ? i.varKinds.var : i.varKinds.let) {
        const Q = this._scope.toName($);
        return this._for(new w(X, Q, V, F), () => z(Q));
      }
      // `for-of` statement (in es5 mode replace with a normal for loop)
      forOf($, V, F, z = i.varKinds.const) {
        const X = this._scope.toName($);
        if (this.opts.es5) {
          const Q = V instanceof a.Name ? V : this.var("_arr", V);
          return this.forRange("_i", 0, (0, a._)`${Q}.length`, (te) => {
            this.var(X, (0, a._)`${Q}[${te}]`), F(X);
          });
        }
        return this._for(new k("of", z, X, V), () => F(X));
      }
      // `for-in` statement.
      // With option `ownProperties` replaced with a `for-of` loop for object keys
      forIn($, V, F, z = this.opts.es5 ? i.varKinds.var : i.varKinds.const) {
        if (this.opts.ownProperties)
          return this.forOf($, (0, a._)`Object.keys(${V})`, F);
        const X = this._scope.toName($);
        return this._for(new k("in", z, X, V), () => F(X));
      }
      // end `for` loop
      endFor() {
        return this._endBlockNode(p);
      }
      // `label` statement
      label($) {
        return this._leafNode(new u($));
      }
      // `break` statement
      break($) {
        return this._leafNode(new c($));
      }
      // `return` statement
      return($) {
        const V = new _();
        if (this._blockNode(V), this.code($), V.nodes.length !== 1)
          throw new Error('CodeGen: "return" should have one node');
        return this._endBlockNode(_);
      }
      // `try` statement
      try($, V, F) {
        if (!V && !F)
          throw new Error('CodeGen: "try" without "catch" and "finally"');
        const z = new P();
        if (this._blockNode(z), this.code($), V) {
          const X = this.name("e");
          this._currNode = z.catch = new M(X), V(X);
        }
        return F && (this._currNode = z.finally = new q(), this.code(F)), this._endBlockNode(M, q);
      }
      // `throw` statement
      throw($) {
        return this._leafNode(new d($));
      }
      // start self-balancing block
      block($, V) {
        return this._blockStarts.push(this._nodes.length), $ && this.code($).endBlock(V), this;
      }
      // end the current self-balancing block
      endBlock($) {
        const V = this._blockStarts.pop();
        if (V === void 0)
          throw new Error("CodeGen: not in self-balancing block");
        const F = this._nodes.length - V;
        if (F < 0 || $ !== void 0 && F !== $)
          throw new Error(`CodeGen: wrong number of nodes: ${F} vs ${$} expected`);
        return this._nodes.length = V, this;
      }
      // `function` heading (or definition if funcBody is passed)
      func($, V = a.nil, F, z) {
        return this._blockNode(new S($, V, F)), z && this.code(z).endFunc(), this;
      }
      // end function definition
      endFunc() {
        return this._endBlockNode(S);
      }
      optimize($ = 1) {
        for (; $-- > 0; )
          this._root.optimizeNodes(), this._root.optimizeNames(this._root.names, this._constants);
      }
      _leafNode($) {
        return this._currNode.nodes.push($), this;
      }
      _blockNode($) {
        this._currNode.nodes.push($), this._nodes.push($);
      }
      _endBlockNode($, V) {
        const F = this._currNode;
        if (F instanceof $ || V && F instanceof V)
          return this._nodes.pop(), this;
        throw new Error(`CodeGen: not in block "${V ? `${$.kind}/${V.kind}` : $.kind}"`);
      }
      _elseNode($) {
        const V = this._currNode;
        if (!(V instanceof m))
          throw new Error('CodeGen: "else" without "if"');
        return this._currNode = V.else = $, this;
      }
      get _root() {
        return this._nodes[0];
      }
      get _currNode() {
        const $ = this._nodes;
        return $[$.length - 1];
      }
      set _currNode($) {
        const V = this._nodes;
        V[V.length - 1] = $;
      }
    }
    e.CodeGen = K;
    function j(x, $) {
      for (const V in $)
        x[V] = (x[V] || 0) + ($[V] || 0);
      return x;
    }
    function H(x, $) {
      return $ instanceof a._CodeOrName ? j(x, $.names) : x;
    }
    function B(x, $, V) {
      if (x instanceof a.Name)
        return F(x);
      if (!z(x))
        return x;
      return new a._Code(x._items.reduce((X, Q) => (Q instanceof a.Name && (Q = F(Q)), Q instanceof a._Code ? X.push(...Q._items) : X.push(Q), X), []));
      function F(X) {
        const Q = V[X.str];
        return Q === void 0 || $[X.str] !== 1 ? X : (delete $[X.str], Q);
      }
      function z(X) {
        return X instanceof a._Code && X._items.some((Q) => Q instanceof a.Name && $[Q.str] === 1 && V[Q.str] !== void 0);
      }
    }
    function L(x, $) {
      for (const V in $)
        x[V] = (x[V] || 0) - ($[V] || 0);
    }
    function O(x) {
      return typeof x == "boolean" || typeof x == "number" || x === null ? !x : (0, a._)`!${E(x)}`;
    }
    e.not = O;
    const U = T(e.operators.AND);
    function Z(...x) {
      return x.reduce(U);
    }
    e.and = Z;
    const J = T(e.operators.OR);
    function A(...x) {
      return x.reduce(J);
    }
    e.or = A;
    function T(x) {
      return ($, V) => $ === a.nil ? V : V === a.nil ? $ : (0, a._)`${E($)} ${x} ${E(V)}`;
    }
    function E(x) {
      return x instanceof a.Name ? x : (0, a._)`(${x})`;
    }
  })(xl)), xl;
}
var Ae = {}, Mc;
function Me() {
  if (Mc) return Ae;
  Mc = 1, Object.defineProperty(Ae, "__esModule", { value: !0 }), Ae.checkStrictMode = Ae.getErrorPath = Ae.Type = Ae.useFunc = Ae.setEvaluated = Ae.evaluatedPropsToName = Ae.mergeEvaluated = Ae.eachItem = Ae.unescapeJsonPointer = Ae.escapeJsonPointer = Ae.escapeFragment = Ae.unescapeFragment = Ae.schemaRefOrVal = Ae.schemaHasRulesButRef = Ae.schemaHasRules = Ae.checkUnknownRules = Ae.alwaysValidSchema = Ae.toHash = void 0;
  const e = Ie(), a = fr();
  function i(k) {
    const S = {};
    for (const _ of k)
      S[_] = !0;
    return S;
  }
  Ae.toHash = i;
  function r(k, S) {
    return typeof S == "boolean" ? S : Object.keys(S).length === 0 ? !0 : (n(k, S), !t(S, k.self.RULES.all));
  }
  Ae.alwaysValidSchema = r;
  function n(k, S = k.schema) {
    const { opts: _, self: P } = k;
    if (!_.strictSchema || typeof S == "boolean")
      return;
    const M = P.RULES.keywords;
    for (const q in S)
      M[q] || w(k, `unknown keyword: "${q}"`);
  }
  Ae.checkUnknownRules = n;
  function t(k, S) {
    if (typeof k == "boolean")
      return !k;
    for (const _ in k)
      if (S[_])
        return !0;
    return !1;
  }
  Ae.schemaHasRules = t;
  function s(k, S) {
    if (typeof k == "boolean")
      return !k;
    for (const _ in k)
      if (_ !== "$ref" && S.all[_])
        return !0;
    return !1;
  }
  Ae.schemaHasRulesButRef = s;
  function o({ topSchemaRef: k, schemaPath: S }, _, P, M) {
    if (!M) {
      if (typeof _ == "number" || typeof _ == "boolean")
        return _;
      if (typeof _ == "string")
        return (0, e._)`${_}`;
    }
    return (0, e._)`${k}${S}${(0, e.getProperty)(P)}`;
  }
  Ae.schemaRefOrVal = o;
  function l(k) {
    return d(decodeURIComponent(k));
  }
  Ae.unescapeFragment = l;
  function u(k) {
    return encodeURIComponent(c(k));
  }
  Ae.escapeFragment = u;
  function c(k) {
    return typeof k == "number" ? `${k}` : k.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  Ae.escapeJsonPointer = c;
  function d(k) {
    return k.replace(/~1/g, "/").replace(/~0/g, "~");
  }
  Ae.unescapeJsonPointer = d;
  function f(k, S) {
    if (Array.isArray(k))
      for (const _ of k)
        S(_);
    else
      S(k);
  }
  Ae.eachItem = f;
  function v({ mergeNames: k, mergeToName: S, mergeValues: _, resultToName: P }) {
    return (M, q, K, j) => {
      const H = K === void 0 ? q : K instanceof e.Name ? (q instanceof e.Name ? k(M, q, K) : S(M, q, K), K) : q instanceof e.Name ? (S(M, K, q), q) : _(q, K);
      return j === e.Name && !(H instanceof e.Name) ? P(M, H) : H;
    };
  }
  Ae.mergeEvaluated = {
    props: v({
      mergeNames: (k, S, _) => k.if((0, e._)`${_} !== true && ${S} !== undefined`, () => {
        k.if((0, e._)`${S} === true`, () => k.assign(_, !0), () => k.assign(_, (0, e._)`${_} || {}`).code((0, e._)`Object.assign(${_}, ${S})`));
      }),
      mergeToName: (k, S, _) => k.if((0, e._)`${_} !== true`, () => {
        S === !0 ? k.assign(_, !0) : (k.assign(_, (0, e._)`${_} || {}`), h(k, _, S));
      }),
      mergeValues: (k, S) => k === !0 ? !0 : { ...k, ...S },
      resultToName: g
    }),
    items: v({
      mergeNames: (k, S, _) => k.if((0, e._)`${_} !== true && ${S} !== undefined`, () => k.assign(_, (0, e._)`${S} === true ? true : ${_} > ${S} ? ${_} : ${S}`)),
      mergeToName: (k, S, _) => k.if((0, e._)`${_} !== true`, () => k.assign(_, S === !0 ? !0 : (0, e._)`${_} > ${S} ? ${_} : ${S}`)),
      mergeValues: (k, S) => k === !0 ? !0 : Math.max(k, S),
      resultToName: (k, S) => k.var("items", S)
    })
  };
  function g(k, S) {
    if (S === !0)
      return k.var("props", !0);
    const _ = k.var("props", (0, e._)`{}`);
    return S !== void 0 && h(k, _, S), _;
  }
  Ae.evaluatedPropsToName = g;
  function h(k, S, _) {
    Object.keys(_).forEach((P) => k.assign((0, e._)`${S}${(0, e.getProperty)(P)}`, !0));
  }
  Ae.setEvaluated = h;
  const y = {};
  function m(k, S) {
    return k.scopeValue("func", {
      ref: S,
      code: y[S.code] || (y[S.code] = new a._Code(S.code))
    });
  }
  Ae.useFunc = m;
  var p;
  (function(k) {
    k[k.Num = 0] = "Num", k[k.Str = 1] = "Str";
  })(p || (Ae.Type = p = {}));
  function b(k, S, _) {
    if (k instanceof e.Name) {
      const P = S === p.Num;
      return _ ? P ? (0, e._)`"[" + ${k} + "]"` : (0, e._)`"['" + ${k} + "']"` : P ? (0, e._)`"/" + ${k}` : (0, e._)`"/" + ${k}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
    }
    return _ ? (0, e.getProperty)(k).toString() : "/" + c(k);
  }
  Ae.getErrorPath = b;
  function w(k, S, _ = k.opts.strictSchema) {
    if (_) {
      if (S = `strict mode: ${S}`, _ === !0)
        throw new Error(S);
      k.self.logger.warn(S);
    }
  }
  return Ae.checkStrictMode = w, Ae;
}
var Kr = {}, Rc;
function Zt() {
  if (Rc) return Kr;
  Rc = 1, Object.defineProperty(Kr, "__esModule", { value: !0 });
  const e = Ie(), a = {
    // validation function arguments
    data: new e.Name("data"),
    // data passed to validation function
    // args passed from referencing schema
    valCxt: new e.Name("valCxt"),
    // validation/data context - should not be used directly, it is destructured to the names below
    instancePath: new e.Name("instancePath"),
    parentData: new e.Name("parentData"),
    parentDataProperty: new e.Name("parentDataProperty"),
    rootData: new e.Name("rootData"),
    // root data - same as the data passed to the first/top validation function
    dynamicAnchors: new e.Name("dynamicAnchors"),
    // used to support recursiveRef and dynamicRef
    // function scoped variables
    vErrors: new e.Name("vErrors"),
    // null or array of validation errors
    errors: new e.Name("errors"),
    // counter of validation errors
    this: new e.Name("this"),
    // "globals"
    self: new e.Name("self"),
    scope: new e.Name("scope"),
    // JTD serialize/parse name for JSON string and position
    json: new e.Name("json"),
    jsonPos: new e.Name("jsonPos"),
    jsonLen: new e.Name("jsonLen"),
    jsonPart: new e.Name("jsonPart")
  };
  return Kr.default = a, Kr;
}
var Nc;
function Vr() {
  return Nc || (Nc = 1, (function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.extendErrors = e.resetErrorsCount = e.reportExtraError = e.reportError = e.keyword$DataError = e.keywordError = void 0;
    const a = Ie(), i = Me(), r = Zt();
    e.keywordError = {
      message: ({ keyword: y }) => (0, a.str)`must pass "${y}" keyword validation`
    }, e.keyword$DataError = {
      message: ({ keyword: y, schemaType: m }) => m ? (0, a.str)`"${y}" keyword must be ${m} ($data)` : (0, a.str)`"${y}" keyword is invalid ($data)`
    };
    function n(y, m = e.keywordError, p, b) {
      const { it: w } = y, { gen: k, compositeRule: S, allErrors: _ } = w, P = d(y, m, p);
      b ?? (S || _) ? l(k, P) : u(w, (0, a._)`[${P}]`);
    }
    e.reportError = n;
    function t(y, m = e.keywordError, p) {
      const { it: b } = y, { gen: w, compositeRule: k, allErrors: S } = b, _ = d(y, m, p);
      l(w, _), k || S || u(b, r.default.vErrors);
    }
    e.reportExtraError = t;
    function s(y, m) {
      y.assign(r.default.errors, m), y.if((0, a._)`${r.default.vErrors} !== null`, () => y.if(m, () => y.assign((0, a._)`${r.default.vErrors}.length`, m), () => y.assign(r.default.vErrors, null)));
    }
    e.resetErrorsCount = s;
    function o({ gen: y, keyword: m, schemaValue: p, data: b, errsCount: w, it: k }) {
      if (w === void 0)
        throw new Error("ajv implementation error");
      const S = y.name("err");
      y.forRange("i", w, r.default.errors, (_) => {
        y.const(S, (0, a._)`${r.default.vErrors}[${_}]`), y.if((0, a._)`${S}.instancePath === undefined`, () => y.assign((0, a._)`${S}.instancePath`, (0, a.strConcat)(r.default.instancePath, k.errorPath))), y.assign((0, a._)`${S}.schemaPath`, (0, a.str)`${k.errSchemaPath}/${m}`), k.opts.verbose && (y.assign((0, a._)`${S}.schema`, p), y.assign((0, a._)`${S}.data`, b));
      });
    }
    e.extendErrors = o;
    function l(y, m) {
      const p = y.const("err", m);
      y.if((0, a._)`${r.default.vErrors} === null`, () => y.assign(r.default.vErrors, (0, a._)`[${p}]`), (0, a._)`${r.default.vErrors}.push(${p})`), y.code((0, a._)`${r.default.errors}++`);
    }
    function u(y, m) {
      const { gen: p, validateName: b, schemaEnv: w } = y;
      w.$async ? p.throw((0, a._)`new ${y.ValidationError}(${m})`) : (p.assign((0, a._)`${b}.errors`, m), p.return(!1));
    }
    const c = {
      keyword: new a.Name("keyword"),
      schemaPath: new a.Name("schemaPath"),
      // also used in JTD errors
      params: new a.Name("params"),
      propertyName: new a.Name("propertyName"),
      message: new a.Name("message"),
      schema: new a.Name("schema"),
      parentSchema: new a.Name("parentSchema")
    };
    function d(y, m, p) {
      const { createErrors: b } = y.it;
      return b === !1 ? (0, a._)`{}` : f(y, m, p);
    }
    function f(y, m, p = {}) {
      const { gen: b, it: w } = y, k = [
        v(w, p),
        g(y, p)
      ];
      return h(y, m, k), b.object(...k);
    }
    function v({ errorPath: y }, { instancePath: m }) {
      const p = m ? (0, a.str)`${y}${(0, i.getErrorPath)(m, i.Type.Str)}` : y;
      return [r.default.instancePath, (0, a.strConcat)(r.default.instancePath, p)];
    }
    function g({ keyword: y, it: { errSchemaPath: m } }, { schemaPath: p, parentSchema: b }) {
      let w = b ? m : (0, a.str)`${m}/${y}`;
      return p && (w = (0, a.str)`${w}${(0, i.getErrorPath)(p, i.Type.Str)}`), [c.schemaPath, w];
    }
    function h(y, { params: m, message: p }, b) {
      const { keyword: w, data: k, schemaValue: S, it: _ } = y, { opts: P, propertyName: M, topSchemaRef: q, schemaPath: K } = _;
      b.push([c.keyword, w], [c.params, typeof m == "function" ? m(y) : m || (0, a._)`{}`]), P.messages && b.push([c.message, typeof p == "function" ? p(y) : p]), P.verbose && b.push([c.schema, S], [c.parentSchema, (0, a._)`${q}${K}`], [r.default.data, k]), M && b.push([c.propertyName, M]);
    }
  })(Cl)), Cl;
}
var Lc;
function cg() {
  if (Lc) return Ha;
  Lc = 1, Object.defineProperty(Ha, "__esModule", { value: !0 }), Ha.boolOrEmptySchema = Ha.topBoolOrEmptySchema = void 0;
  const e = Vr(), a = Ie(), i = Zt(), r = {
    message: "boolean schema is false"
  };
  function n(o) {
    const { gen: l, schema: u, validateName: c } = o;
    u === !1 ? s(o, !1) : typeof u == "object" && u.$async === !0 ? l.return(i.default.data) : (l.assign((0, a._)`${c}.errors`, null), l.return(!0));
  }
  Ha.topBoolOrEmptySchema = n;
  function t(o, l) {
    const { gen: u, schema: c } = o;
    c === !1 ? (u.var(l, !1), s(o)) : u.var(l, !0);
  }
  Ha.boolOrEmptySchema = t;
  function s(o, l) {
    const { gen: u, data: c } = o, d = {
      gen: u,
      keyword: "false schema",
      data: c,
      schema: !1,
      schemaCode: !1,
      schemaValue: !1,
      params: {},
      it: o
    };
    (0, e.reportError)(d, r, void 0, l);
  }
  return Ha;
}
var yt = {}, Ua = {}, qc;
function Qm() {
  if (qc) return Ua;
  qc = 1, Object.defineProperty(Ua, "__esModule", { value: !0 }), Ua.getRules = Ua.isJSONType = void 0;
  const e = ["string", "number", "integer", "boolean", "null", "object", "array"], a = new Set(e);
  function i(n) {
    return typeof n == "string" && a.has(n);
  }
  Ua.isJSONType = i;
  function r() {
    const n = {
      number: { type: "number", rules: [] },
      string: { type: "string", rules: [] },
      array: { type: "array", rules: [] },
      object: { type: "object", rules: [] }
    };
    return {
      types: { ...n, integer: !0, boolean: !0, null: !0 },
      rules: [{ rules: [] }, n.number, n.string, n.array, n.object],
      post: { rules: [] },
      all: {},
      keywords: {}
    };
  }
  return Ua.getRules = r, Ua;
}
var wa = {}, zc;
function ev() {
  if (zc) return wa;
  zc = 1, Object.defineProperty(wa, "__esModule", { value: !0 }), wa.shouldUseRule = wa.shouldUseGroup = wa.schemaHasRulesForType = void 0;
  function e({ schema: r, self: n }, t) {
    const s = n.RULES.types[t];
    return s && s !== !0 && a(r, s);
  }
  wa.schemaHasRulesForType = e;
  function a(r, n) {
    return n.rules.some((t) => i(r, t));
  }
  wa.shouldUseGroup = a;
  function i(r, n) {
    var t;
    return r[n.keyword] !== void 0 || ((t = n.definition.implements) === null || t === void 0 ? void 0 : t.some((s) => r[s] !== void 0));
  }
  return wa.shouldUseRule = i, wa;
}
var Bc;
function rs() {
  if (Bc) return yt;
  Bc = 1, Object.defineProperty(yt, "__esModule", { value: !0 }), yt.reportTypeError = yt.checkDataTypes = yt.checkDataType = yt.coerceAndCheckDataType = yt.getJSONTypes = yt.getSchemaTypes = yt.DataType = void 0;
  const e = Qm(), a = ev(), i = Vr(), r = Ie(), n = Me();
  var t;
  (function(p) {
    p[p.Correct = 0] = "Correct", p[p.Wrong = 1] = "Wrong";
  })(t || (yt.DataType = t = {}));
  function s(p) {
    const b = o(p.type);
    if (b.includes("null")) {
      if (p.nullable === !1)
        throw new Error("type: null contradicts nullable: false");
    } else {
      if (!b.length && p.nullable !== void 0)
        throw new Error('"nullable" cannot be used without "type"');
      p.nullable === !0 && b.push("null");
    }
    return b;
  }
  yt.getSchemaTypes = s;
  function o(p) {
    const b = Array.isArray(p) ? p : p ? [p] : [];
    if (b.every(e.isJSONType))
      return b;
    throw new Error("type must be JSONType or JSONType[]: " + b.join(","));
  }
  yt.getJSONTypes = o;
  function l(p, b) {
    const { gen: w, data: k, opts: S } = p, _ = c(b, S.coerceTypes), P = b.length > 0 && !(_.length === 0 && b.length === 1 && (0, a.schemaHasRulesForType)(p, b[0]));
    if (P) {
      const M = g(b, k, S.strictNumbers, t.Wrong);
      w.if(M, () => {
        _.length ? d(p, b, _) : y(p);
      });
    }
    return P;
  }
  yt.coerceAndCheckDataType = l;
  const u = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
  function c(p, b) {
    return b ? p.filter((w) => u.has(w) || b === "array" && w === "array") : [];
  }
  function d(p, b, w) {
    const { gen: k, data: S, opts: _ } = p, P = k.let("dataType", (0, r._)`typeof ${S}`), M = k.let("coerced", (0, r._)`undefined`);
    _.coerceTypes === "array" && k.if((0, r._)`${P} == 'object' && Array.isArray(${S}) && ${S}.length == 1`, () => k.assign(S, (0, r._)`${S}[0]`).assign(P, (0, r._)`typeof ${S}`).if(g(b, S, _.strictNumbers), () => k.assign(M, S))), k.if((0, r._)`${M} !== undefined`);
    for (const K of w)
      (u.has(K) || K === "array" && _.coerceTypes === "array") && q(K);
    k.else(), y(p), k.endIf(), k.if((0, r._)`${M} !== undefined`, () => {
      k.assign(S, M), f(p, M);
    });
    function q(K) {
      switch (K) {
        case "string":
          k.elseIf((0, r._)`${P} == "number" || ${P} == "boolean"`).assign(M, (0, r._)`"" + ${S}`).elseIf((0, r._)`${S} === null`).assign(M, (0, r._)`""`);
          return;
        case "number":
          k.elseIf((0, r._)`${P} == "boolean" || ${S} === null
              || (${P} == "string" && ${S} && ${S} == +${S})`).assign(M, (0, r._)`+${S}`);
          return;
        case "integer":
          k.elseIf((0, r._)`${P} === "boolean" || ${S} === null
              || (${P} === "string" && ${S} && ${S} == +${S} && !(${S} % 1))`).assign(M, (0, r._)`+${S}`);
          return;
        case "boolean":
          k.elseIf((0, r._)`${S} === "false" || ${S} === 0 || ${S} === null`).assign(M, !1).elseIf((0, r._)`${S} === "true" || ${S} === 1`).assign(M, !0);
          return;
        case "null":
          k.elseIf((0, r._)`${S} === "" || ${S} === 0 || ${S} === false`), k.assign(M, null);
          return;
        case "array":
          k.elseIf((0, r._)`${P} === "string" || ${P} === "number"
              || ${P} === "boolean" || ${S} === null`).assign(M, (0, r._)`[${S}]`);
      }
    }
  }
  function f({ gen: p, parentData: b, parentDataProperty: w }, k) {
    p.if((0, r._)`${b} !== undefined`, () => p.assign((0, r._)`${b}[${w}]`, k));
  }
  function v(p, b, w, k = t.Correct) {
    const S = k === t.Correct ? r.operators.EQ : r.operators.NEQ;
    let _;
    switch (p) {
      case "null":
        return (0, r._)`${b} ${S} null`;
      case "array":
        _ = (0, r._)`Array.isArray(${b})`;
        break;
      case "object":
        _ = (0, r._)`${b} && typeof ${b} == "object" && !Array.isArray(${b})`;
        break;
      case "integer":
        _ = P((0, r._)`!(${b} % 1) && !isNaN(${b})`);
        break;
      case "number":
        _ = P();
        break;
      default:
        return (0, r._)`typeof ${b} ${S} ${p}`;
    }
    return k === t.Correct ? _ : (0, r.not)(_);
    function P(M = r.nil) {
      return (0, r.and)((0, r._)`typeof ${b} == "number"`, M, w ? (0, r._)`isFinite(${b})` : r.nil);
    }
  }
  yt.checkDataType = v;
  function g(p, b, w, k) {
    if (p.length === 1)
      return v(p[0], b, w, k);
    let S;
    const _ = (0, n.toHash)(p);
    if (_.array && _.object) {
      const P = (0, r._)`typeof ${b} != "object"`;
      S = _.null ? P : (0, r._)`!${b} || ${P}`, delete _.null, delete _.array, delete _.object;
    } else
      S = r.nil;
    _.number && delete _.integer;
    for (const P in _)
      S = (0, r.and)(S, v(P, b, w, k));
    return S;
  }
  yt.checkDataTypes = g;
  const h = {
    message: ({ schema: p }) => `must be ${p}`,
    params: ({ schema: p, schemaValue: b }) => typeof p == "string" ? (0, r._)`{type: ${p}}` : (0, r._)`{type: ${b}}`
  };
  function y(p) {
    const b = m(p);
    (0, i.reportError)(b, h);
  }
  yt.reportTypeError = y;
  function m(p) {
    const { gen: b, data: w, schema: k } = p, S = (0, n.schemaRefOrVal)(p, k, "type");
    return {
      gen: b,
      keyword: "type",
      data: w,
      schema: k.type,
      schemaCode: S,
      schemaValue: S,
      parentSchema: k,
      params: {},
      it: p
    };
  }
  return yt;
}
var Jn = {}, Fc;
function dg() {
  if (Fc) return Jn;
  Fc = 1, Object.defineProperty(Jn, "__esModule", { value: !0 }), Jn.assignDefaults = void 0;
  const e = Ie(), a = Me();
  function i(n, t) {
    const { properties: s, items: o } = n.schema;
    if (t === "object" && s)
      for (const l in s)
        r(n, l, s[l].default);
    else t === "array" && Array.isArray(o) && o.forEach((l, u) => r(n, u, l.default));
  }
  Jn.assignDefaults = i;
  function r(n, t, s) {
    const { gen: o, compositeRule: l, data: u, opts: c } = n;
    if (s === void 0)
      return;
    const d = (0, e._)`${u}${(0, e.getProperty)(t)}`;
    if (l) {
      (0, a.checkStrictMode)(n, `default is ignored for: ${d}`);
      return;
    }
    let f = (0, e._)`${d} === undefined`;
    c.useDefaults === "empty" && (f = (0, e._)`${f} || ${d} === null || ${d} === ""`), o.if(f, (0, e._)`${d} = ${(0, e.stringify)(s)}`);
  }
  return Jn;
}
var aa = {}, He = {}, Kc;
function ca() {
  if (Kc) return He;
  Kc = 1, Object.defineProperty(He, "__esModule", { value: !0 }), He.validateUnion = He.validateArray = He.usePattern = He.callValidateCode = He.schemaProperties = He.allSchemaProperties = He.noPropertyInData = He.propertyInData = He.isOwnProperty = He.hasPropFunc = He.reportMissingProp = He.checkMissingProp = He.checkReportMissingProp = void 0;
  const e = Ie(), a = Me(), i = Zt(), r = Me();
  function n(p, b) {
    const { gen: w, data: k, it: S } = p;
    w.if(c(w, k, b, S.opts.ownProperties), () => {
      p.setParams({ missingProperty: (0, e._)`${b}` }, !0), p.error();
    });
  }
  He.checkReportMissingProp = n;
  function t({ gen: p, data: b, it: { opts: w } }, k, S) {
    return (0, e.or)(...k.map((_) => (0, e.and)(c(p, b, _, w.ownProperties), (0, e._)`${S} = ${_}`)));
  }
  He.checkMissingProp = t;
  function s(p, b) {
    p.setParams({ missingProperty: b }, !0), p.error();
  }
  He.reportMissingProp = s;
  function o(p) {
    return p.scopeValue("func", {
      // eslint-disable-next-line @typescript-eslint/unbound-method
      ref: Object.prototype.hasOwnProperty,
      code: (0, e._)`Object.prototype.hasOwnProperty`
    });
  }
  He.hasPropFunc = o;
  function l(p, b, w) {
    return (0, e._)`${o(p)}.call(${b}, ${w})`;
  }
  He.isOwnProperty = l;
  function u(p, b, w, k) {
    const S = (0, e._)`${b}${(0, e.getProperty)(w)} !== undefined`;
    return k ? (0, e._)`${S} && ${l(p, b, w)}` : S;
  }
  He.propertyInData = u;
  function c(p, b, w, k) {
    const S = (0, e._)`${b}${(0, e.getProperty)(w)} === undefined`;
    return k ? (0, e.or)(S, (0, e.not)(l(p, b, w))) : S;
  }
  He.noPropertyInData = c;
  function d(p) {
    return p ? Object.keys(p).filter((b) => b !== "__proto__") : [];
  }
  He.allSchemaProperties = d;
  function f(p, b) {
    return d(b).filter((w) => !(0, a.alwaysValidSchema)(p, b[w]));
  }
  He.schemaProperties = f;
  function v({ schemaCode: p, data: b, it: { gen: w, topSchemaRef: k, schemaPath: S, errorPath: _ }, it: P }, M, q, K) {
    const j = K ? (0, e._)`${p}, ${b}, ${k}${S}` : b, H = [
      [i.default.instancePath, (0, e.strConcat)(i.default.instancePath, _)],
      [i.default.parentData, P.parentData],
      [i.default.parentDataProperty, P.parentDataProperty],
      [i.default.rootData, i.default.rootData]
    ];
    P.opts.dynamicRef && H.push([i.default.dynamicAnchors, i.default.dynamicAnchors]);
    const B = (0, e._)`${j}, ${w.object(...H)}`;
    return q !== e.nil ? (0, e._)`${M}.call(${q}, ${B})` : (0, e._)`${M}(${B})`;
  }
  He.callValidateCode = v;
  const g = (0, e._)`new RegExp`;
  function h({ gen: p, it: { opts: b } }, w) {
    const k = b.unicodeRegExp ? "u" : "", { regExp: S } = b.code, _ = S(w, k);
    return p.scopeValue("pattern", {
      key: _.toString(),
      ref: _,
      code: (0, e._)`${S.code === "new RegExp" ? g : (0, r.useFunc)(p, S)}(${w}, ${k})`
    });
  }
  He.usePattern = h;
  function y(p) {
    const { gen: b, data: w, keyword: k, it: S } = p, _ = b.name("valid");
    if (S.allErrors) {
      const M = b.let("valid", !0);
      return P(() => b.assign(M, !1)), M;
    }
    return b.var(_, !0), P(() => b.break()), _;
    function P(M) {
      const q = b.const("len", (0, e._)`${w}.length`);
      b.forRange("i", 0, q, (K) => {
        p.subschema({
          keyword: k,
          dataProp: K,
          dataPropType: a.Type.Num
        }, _), b.if((0, e.not)(_), M);
      });
    }
  }
  He.validateArray = y;
  function m(p) {
    const { gen: b, schema: w, keyword: k, it: S } = p;
    if (!Array.isArray(w))
      throw new Error("ajv implementation error");
    if (w.some((q) => (0, a.alwaysValidSchema)(S, q)) && !S.opts.unevaluated)
      return;
    const P = b.let("valid", !1), M = b.name("_valid");
    b.block(() => w.forEach((q, K) => {
      const j = p.subschema({
        keyword: k,
        schemaProp: K,
        compositeRule: !0
      }, M);
      b.assign(P, (0, e._)`${P} || ${M}`), p.mergeValidEvaluated(j, M) || b.if((0, e.not)(P));
    })), p.result(P, () => p.reset(), () => p.error(!0));
  }
  return He.validateUnion = m, He;
}
var Hc;
function fg() {
  if (Hc) return aa;
  Hc = 1, Object.defineProperty(aa, "__esModule", { value: !0 }), aa.validateKeywordUsage = aa.validSchemaType = aa.funcKeywordCode = aa.macroKeywordCode = void 0;
  const e = Ie(), a = Zt(), i = ca(), r = Vr();
  function n(f, v) {
    const { gen: g, keyword: h, schema: y, parentSchema: m, it: p } = f, b = v.macro.call(p.self, y, m, p), w = u(g, h, b);
    p.opts.validateSchema !== !1 && p.self.validateSchema(b, !0);
    const k = g.name("valid");
    f.subschema({
      schema: b,
      schemaPath: e.nil,
      errSchemaPath: `${p.errSchemaPath}/${h}`,
      topSchemaRef: w,
      compositeRule: !0
    }, k), f.pass(k, () => f.error(!0));
  }
  aa.macroKeywordCode = n;
  function t(f, v) {
    var g;
    const { gen: h, keyword: y, schema: m, parentSchema: p, $data: b, it: w } = f;
    l(w, v);
    const k = !b && v.compile ? v.compile.call(w.self, m, p, w) : v.validate, S = u(h, y, k), _ = h.let("valid");
    f.block$data(_, P), f.ok((g = v.valid) !== null && g !== void 0 ? g : _);
    function P() {
      if (v.errors === !1)
        K(), v.modifying && s(f), j(() => f.error());
      else {
        const H = v.async ? M() : q();
        v.modifying && s(f), j(() => o(f, H));
      }
    }
    function M() {
      const H = h.let("ruleErrs", null);
      return h.try(() => K((0, e._)`await `), (B) => h.assign(_, !1).if((0, e._)`${B} instanceof ${w.ValidationError}`, () => h.assign(H, (0, e._)`${B}.errors`), () => h.throw(B))), H;
    }
    function q() {
      const H = (0, e._)`${S}.errors`;
      return h.assign(H, null), K(e.nil), H;
    }
    function K(H = v.async ? (0, e._)`await ` : e.nil) {
      const B = w.opts.passContext ? a.default.this : a.default.self, L = !("compile" in v && !b || v.schema === !1);
      h.assign(_, (0, e._)`${H}${(0, i.callValidateCode)(f, S, B, L)}`, v.modifying);
    }
    function j(H) {
      var B;
      h.if((0, e.not)((B = v.valid) !== null && B !== void 0 ? B : _), H);
    }
  }
  aa.funcKeywordCode = t;
  function s(f) {
    const { gen: v, data: g, it: h } = f;
    v.if(h.parentData, () => v.assign(g, (0, e._)`${h.parentData}[${h.parentDataProperty}]`));
  }
  function o(f, v) {
    const { gen: g } = f;
    g.if((0, e._)`Array.isArray(${v})`, () => {
      g.assign(a.default.vErrors, (0, e._)`${a.default.vErrors} === null ? ${v} : ${a.default.vErrors}.concat(${v})`).assign(a.default.errors, (0, e._)`${a.default.vErrors}.length`), (0, r.extendErrors)(f);
    }, () => f.error());
  }
  function l({ schemaEnv: f }, v) {
    if (v.async && !f.$async)
      throw new Error("async keyword in sync schema");
  }
  function u(f, v, g) {
    if (g === void 0)
      throw new Error(`keyword "${v}" failed to compile`);
    return f.scopeValue("keyword", typeof g == "function" ? { ref: g } : { ref: g, code: (0, e.stringify)(g) });
  }
  function c(f, v, g = !1) {
    return !v.length || v.some((h) => h === "array" ? Array.isArray(f) : h === "object" ? f && typeof f == "object" && !Array.isArray(f) : typeof f == h || g && typeof f > "u");
  }
  aa.validSchemaType = c;
  function d({ schema: f, opts: v, self: g, errSchemaPath: h }, y, m) {
    if (Array.isArray(y.keyword) ? !y.keyword.includes(m) : y.keyword !== m)
      throw new Error("ajv implementation error");
    const p = y.dependencies;
    if (p?.some((b) => !Object.prototype.hasOwnProperty.call(f, b)))
      throw new Error(`parent schema must have dependencies of ${m}: ${p.join(",")}`);
    if (y.validateSchema && !y.validateSchema(f[m])) {
      const w = `keyword "${m}" value is invalid at path "${h}": ` + g.errorsText(y.validateSchema.errors);
      if (v.validateSchema === "log")
        g.logger.error(w);
      else
        throw new Error(w);
    }
  }
  return aa.validateKeywordUsage = d, aa;
}
var Sa = {}, Uc;
function mg() {
  if (Uc) return Sa;
  Uc = 1, Object.defineProperty(Sa, "__esModule", { value: !0 }), Sa.extendSubschemaMode = Sa.extendSubschemaData = Sa.getSubschema = void 0;
  const e = Ie(), a = Me();
  function i(t, { keyword: s, schemaProp: o, schema: l, schemaPath: u, errSchemaPath: c, topSchemaRef: d }) {
    if (s !== void 0 && l !== void 0)
      throw new Error('both "keyword" and "schema" passed, only one allowed');
    if (s !== void 0) {
      const f = t.schema[s];
      return o === void 0 ? {
        schema: f,
        schemaPath: (0, e._)`${t.schemaPath}${(0, e.getProperty)(s)}`,
        errSchemaPath: `${t.errSchemaPath}/${s}`
      } : {
        schema: f[o],
        schemaPath: (0, e._)`${t.schemaPath}${(0, e.getProperty)(s)}${(0, e.getProperty)(o)}`,
        errSchemaPath: `${t.errSchemaPath}/${s}/${(0, a.escapeFragment)(o)}`
      };
    }
    if (l !== void 0) {
      if (u === void 0 || c === void 0 || d === void 0)
        throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
      return {
        schema: l,
        schemaPath: u,
        topSchemaRef: d,
        errSchemaPath: c
      };
    }
    throw new Error('either "keyword" or "schema" must be passed');
  }
  Sa.getSubschema = i;
  function r(t, s, { dataProp: o, dataPropType: l, data: u, dataTypes: c, propertyName: d }) {
    if (u !== void 0 && o !== void 0)
      throw new Error('both "data" and "dataProp" passed, only one allowed');
    const { gen: f } = s;
    if (o !== void 0) {
      const { errorPath: g, dataPathArr: h, opts: y } = s, m = f.let("data", (0, e._)`${s.data}${(0, e.getProperty)(o)}`, !0);
      v(m), t.errorPath = (0, e.str)`${g}${(0, a.getErrorPath)(o, l, y.jsPropertySyntax)}`, t.parentDataProperty = (0, e._)`${o}`, t.dataPathArr = [...h, t.parentDataProperty];
    }
    if (u !== void 0) {
      const g = u instanceof e.Name ? u : f.let("data", u, !0);
      v(g), d !== void 0 && (t.propertyName = d);
    }
    c && (t.dataTypes = c);
    function v(g) {
      t.data = g, t.dataLevel = s.dataLevel + 1, t.dataTypes = [], s.definedProperties = /* @__PURE__ */ new Set(), t.parentData = s.data, t.dataNames = [...s.dataNames, g];
    }
  }
  Sa.extendSubschemaData = r;
  function n(t, { jtdDiscriminator: s, jtdMetadata: o, compositeRule: l, createErrors: u, allErrors: c }) {
    l !== void 0 && (t.compositeRule = l), u !== void 0 && (t.createErrors = u), c !== void 0 && (t.allErrors = c), t.jtdDiscriminator = s, t.jtdMetadata = o;
  }
  return Sa.extendSubschemaMode = n, Sa;
}
var xt = {}, Ol, Wc;
function tv() {
  return Wc || (Wc = 1, Ol = function e(a, i) {
    if (a === i) return !0;
    if (a && i && typeof a == "object" && typeof i == "object") {
      if (a.constructor !== i.constructor) return !1;
      var r, n, t;
      if (Array.isArray(a)) {
        if (r = a.length, r != i.length) return !1;
        for (n = r; n-- !== 0; )
          if (!e(a[n], i[n])) return !1;
        return !0;
      }
      if (a.constructor === RegExp) return a.source === i.source && a.flags === i.flags;
      if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === i.valueOf();
      if (a.toString !== Object.prototype.toString) return a.toString() === i.toString();
      if (t = Object.keys(a), r = t.length, r !== Object.keys(i).length) return !1;
      for (n = r; n-- !== 0; )
        if (!Object.prototype.hasOwnProperty.call(i, t[n])) return !1;
      for (n = r; n-- !== 0; ) {
        var s = t[n];
        if (!e(a[s], i[s])) return !1;
      }
      return !0;
    }
    return a !== a && i !== i;
  }), Ol;
}
var El = { exports: {} }, Gc;
function vg() {
  if (Gc) return El.exports;
  Gc = 1;
  var e = El.exports = function(r, n, t) {
    typeof n == "function" && (t = n, n = {}), t = n.cb || t;
    var s = typeof t == "function" ? t : t.pre || function() {
    }, o = t.post || function() {
    };
    a(n, s, o, r, "", r);
  };
  e.keywords = {
    additionalItems: !0,
    items: !0,
    contains: !0,
    additionalProperties: !0,
    propertyNames: !0,
    not: !0,
    if: !0,
    then: !0,
    else: !0
  }, e.arrayKeywords = {
    items: !0,
    allOf: !0,
    anyOf: !0,
    oneOf: !0
  }, e.propsKeywords = {
    $defs: !0,
    definitions: !0,
    properties: !0,
    patternProperties: !0,
    dependencies: !0
  }, e.skipKeywords = {
    default: !0,
    enum: !0,
    const: !0,
    required: !0,
    maximum: !0,
    minimum: !0,
    exclusiveMaximum: !0,
    exclusiveMinimum: !0,
    multipleOf: !0,
    maxLength: !0,
    minLength: !0,
    pattern: !0,
    format: !0,
    maxItems: !0,
    minItems: !0,
    uniqueItems: !0,
    maxProperties: !0,
    minProperties: !0
  };
  function a(r, n, t, s, o, l, u, c, d, f) {
    if (s && typeof s == "object" && !Array.isArray(s)) {
      n(s, o, l, u, c, d, f);
      for (var v in s) {
        var g = s[v];
        if (Array.isArray(g)) {
          if (v in e.arrayKeywords)
            for (var h = 0; h < g.length; h++)
              a(r, n, t, g[h], o + "/" + v + "/" + h, l, o, v, s, h);
        } else if (v in e.propsKeywords) {
          if (g && typeof g == "object")
            for (var y in g)
              a(r, n, t, g[y], o + "/" + v + "/" + i(y), l, o, v, s, y);
        } else (v in e.keywords || r.allKeys && !(v in e.skipKeywords)) && a(r, n, t, g, o + "/" + v, l, o, v, s);
      }
      t(s, o, l, u, c, d, f);
    }
  }
  function i(r) {
    return r.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  return El.exports;
}
var Yc;
function Vs() {
  if (Yc) return xt;
  Yc = 1, Object.defineProperty(xt, "__esModule", { value: !0 }), xt.getSchemaRefs = xt.resolveUrl = xt.normalizeId = xt._getFullPath = xt.getFullPath = xt.inlineRef = void 0;
  const e = Me(), a = tv(), i = vg(), r = /* @__PURE__ */ new Set([
    "type",
    "format",
    "pattern",
    "maxLength",
    "minLength",
    "maxProperties",
    "minProperties",
    "maxItems",
    "minItems",
    "maximum",
    "minimum",
    "uniqueItems",
    "multipleOf",
    "required",
    "enum",
    "const"
  ]);
  function n(h, y = !0) {
    return typeof h == "boolean" ? !0 : y === !0 ? !s(h) : y ? o(h) <= y : !1;
  }
  xt.inlineRef = n;
  const t = /* @__PURE__ */ new Set([
    "$ref",
    "$recursiveRef",
    "$recursiveAnchor",
    "$dynamicRef",
    "$dynamicAnchor"
  ]);
  function s(h) {
    for (const y in h) {
      if (t.has(y))
        return !0;
      const m = h[y];
      if (Array.isArray(m) && m.some(s) || typeof m == "object" && s(m))
        return !0;
    }
    return !1;
  }
  function o(h) {
    let y = 0;
    for (const m in h) {
      if (m === "$ref")
        return 1 / 0;
      if (y++, !r.has(m) && (typeof h[m] == "object" && (0, e.eachItem)(h[m], (p) => y += o(p)), y === 1 / 0))
        return 1 / 0;
    }
    return y;
  }
  function l(h, y = "", m) {
    m !== !1 && (y = d(y));
    const p = h.parse(y);
    return u(h, p);
  }
  xt.getFullPath = l;
  function u(h, y) {
    return h.serialize(y).split("#")[0] + "#";
  }
  xt._getFullPath = u;
  const c = /#\/?$/;
  function d(h) {
    return h ? h.replace(c, "") : "";
  }
  xt.normalizeId = d;
  function f(h, y, m) {
    return m = d(m), h.resolve(y, m);
  }
  xt.resolveUrl = f;
  const v = /^[a-z_][-a-z0-9._]*$/i;
  function g(h, y) {
    if (typeof h == "boolean")
      return {};
    const { schemaId: m, uriResolver: p } = this.opts, b = d(h[m] || y), w = { "": b }, k = l(p, b, !1), S = {}, _ = /* @__PURE__ */ new Set();
    return i(h, { allKeys: !0 }, (q, K, j, H) => {
      if (H === void 0)
        return;
      const B = k + K;
      let L = w[H];
      typeof q[m] == "string" && (L = O.call(this, q[m])), U.call(this, q.$anchor), U.call(this, q.$dynamicAnchor), w[K] = L;
      function O(Z) {
        const J = this.opts.uriResolver.resolve;
        if (Z = d(L ? J(L, Z) : Z), _.has(Z))
          throw M(Z);
        _.add(Z);
        let A = this.refs[Z];
        return typeof A == "string" && (A = this.refs[A]), typeof A == "object" ? P(q, A.schema, Z) : Z !== d(B) && (Z[0] === "#" ? (P(q, S[Z], Z), S[Z] = q) : this.refs[Z] = B), Z;
      }
      function U(Z) {
        if (typeof Z == "string") {
          if (!v.test(Z))
            throw new Error(`invalid anchor "${Z}"`);
          O.call(this, `#${Z}`);
        }
      }
    }), S;
    function P(q, K, j) {
      if (K !== void 0 && !a(q, K))
        throw M(j);
    }
    function M(q) {
      return new Error(`reference "${q}" resolves to more than one schema`);
    }
  }
  return xt.getSchemaRefs = g, xt;
}
var Xc;
function zn() {
  if (Xc) return ka;
  Xc = 1, Object.defineProperty(ka, "__esModule", { value: !0 }), ka.getData = ka.KeywordCxt = ka.validateFunctionCode = void 0;
  const e = cg(), a = rs(), i = ev(), r = rs(), n = dg(), t = fg(), s = mg(), o = Ie(), l = Zt(), u = Vs(), c = Me(), d = Vr();
  function f(N) {
    if (k(N) && (_(N), w(N))) {
      y(N);
      return;
    }
    v(N, () => (0, e.topBoolOrEmptySchema)(N));
  }
  ka.validateFunctionCode = f;
  function v({ gen: N, validateName: R, schema: G, schemaEnv: ae, opts: ve }, ne) {
    ve.code.es5 ? N.func(R, (0, o._)`${l.default.data}, ${l.default.valCxt}`, ae.$async, () => {
      N.code((0, o._)`"use strict"; ${p(G, ve)}`), h(N, ve), N.code(ne);
    }) : N.func(R, (0, o._)`${l.default.data}, ${g(ve)}`, ae.$async, () => N.code(p(G, ve)).code(ne));
  }
  function g(N) {
    return (0, o._)`{${l.default.instancePath}="", ${l.default.parentData}, ${l.default.parentDataProperty}, ${l.default.rootData}=${l.default.data}${N.dynamicRef ? (0, o._)`, ${l.default.dynamicAnchors}={}` : o.nil}}={}`;
  }
  function h(N, R) {
    N.if(l.default.valCxt, () => {
      N.var(l.default.instancePath, (0, o._)`${l.default.valCxt}.${l.default.instancePath}`), N.var(l.default.parentData, (0, o._)`${l.default.valCxt}.${l.default.parentData}`), N.var(l.default.parentDataProperty, (0, o._)`${l.default.valCxt}.${l.default.parentDataProperty}`), N.var(l.default.rootData, (0, o._)`${l.default.valCxt}.${l.default.rootData}`), R.dynamicRef && N.var(l.default.dynamicAnchors, (0, o._)`${l.default.valCxt}.${l.default.dynamicAnchors}`);
    }, () => {
      N.var(l.default.instancePath, (0, o._)`""`), N.var(l.default.parentData, (0, o._)`undefined`), N.var(l.default.parentDataProperty, (0, o._)`undefined`), N.var(l.default.rootData, l.default.data), R.dynamicRef && N.var(l.default.dynamicAnchors, (0, o._)`{}`);
    });
  }
  function y(N) {
    const { schema: R, opts: G, gen: ae } = N;
    v(N, () => {
      G.$comment && R.$comment && H(N), q(N), ae.let(l.default.vErrors, null), ae.let(l.default.errors, 0), G.unevaluated && m(N), P(N), B(N);
    });
  }
  function m(N) {
    const { gen: R, validateName: G } = N;
    N.evaluated = R.const("evaluated", (0, o._)`${G}.evaluated`), R.if((0, o._)`${N.evaluated}.dynamicProps`, () => R.assign((0, o._)`${N.evaluated}.props`, (0, o._)`undefined`)), R.if((0, o._)`${N.evaluated}.dynamicItems`, () => R.assign((0, o._)`${N.evaluated}.items`, (0, o._)`undefined`));
  }
  function p(N, R) {
    const G = typeof N == "object" && N[R.schemaId];
    return G && (R.code.source || R.code.process) ? (0, o._)`/*# sourceURL=${G} */` : o.nil;
  }
  function b(N, R) {
    if (k(N) && (_(N), w(N))) {
      S(N, R);
      return;
    }
    (0, e.boolOrEmptySchema)(N, R);
  }
  function w({ schema: N, self: R }) {
    if (typeof N == "boolean")
      return !N;
    for (const G in N)
      if (R.RULES.all[G])
        return !0;
    return !1;
  }
  function k(N) {
    return typeof N.schema != "boolean";
  }
  function S(N, R) {
    const { schema: G, gen: ae, opts: ve } = N;
    ve.$comment && G.$comment && H(N), K(N), j(N);
    const ne = ae.const("_errs", l.default.errors);
    P(N, ne), ae.var(R, (0, o._)`${ne} === ${l.default.errors}`);
  }
  function _(N) {
    (0, c.checkUnknownRules)(N), M(N);
  }
  function P(N, R) {
    if (N.opts.jtd)
      return O(N, [], !1, R);
    const G = (0, a.getSchemaTypes)(N.schema), ae = (0, a.coerceAndCheckDataType)(N, G);
    O(N, G, !ae, R);
  }
  function M(N) {
    const { schema: R, errSchemaPath: G, opts: ae, self: ve } = N;
    R.$ref && ae.ignoreKeywordsWithRef && (0, c.schemaHasRulesButRef)(R, ve.RULES) && ve.logger.warn(`$ref: keywords ignored in schema at path "${G}"`);
  }
  function q(N) {
    const { schema: R, opts: G } = N;
    R.default !== void 0 && G.useDefaults && G.strictSchema && (0, c.checkStrictMode)(N, "default is ignored in the schema root");
  }
  function K(N) {
    const R = N.schema[N.opts.schemaId];
    R && (N.baseId = (0, u.resolveUrl)(N.opts.uriResolver, N.baseId, R));
  }
  function j(N) {
    if (N.schema.$async && !N.schemaEnv.$async)
      throw new Error("async schema in sync schema");
  }
  function H({ gen: N, schemaEnv: R, schema: G, errSchemaPath: ae, opts: ve }) {
    const ne = G.$comment;
    if (ve.$comment === !0)
      N.code((0, o._)`${l.default.self}.logger.log(${ne})`);
    else if (typeof ve.$comment == "function") {
      const _e = (0, o.str)`${ae}/$comment`, Ce = N.scopeValue("root", { ref: R.root });
      N.code((0, o._)`${l.default.self}.opts.$comment(${ne}, ${_e}, ${Ce}.schema)`);
    }
  }
  function B(N) {
    const { gen: R, schemaEnv: G, validateName: ae, ValidationError: ve, opts: ne } = N;
    G.$async ? R.if((0, o._)`${l.default.errors} === 0`, () => R.return(l.default.data), () => R.throw((0, o._)`new ${ve}(${l.default.vErrors})`)) : (R.assign((0, o._)`${ae}.errors`, l.default.vErrors), ne.unevaluated && L(N), R.return((0, o._)`${l.default.errors} === 0`));
  }
  function L({ gen: N, evaluated: R, props: G, items: ae }) {
    G instanceof o.Name && N.assign((0, o._)`${R}.props`, G), ae instanceof o.Name && N.assign((0, o._)`${R}.items`, ae);
  }
  function O(N, R, G, ae) {
    const { gen: ve, schema: ne, data: _e, allErrors: Ce, opts: se, self: ge } = N, { RULES: we } = ge;
    if (ne.$ref && (se.ignoreKeywordsWithRef || !(0, c.schemaHasRulesButRef)(ne, we))) {
      ve.block(() => z(N, "$ref", we.all.$ref.definition));
      return;
    }
    se.jtd || Z(N, R), ve.block(() => {
      for (const ze of we.rules)
        ke(ze);
      ke(we.post);
    });
    function ke(ze) {
      (0, i.shouldUseGroup)(ne, ze) && (ze.type ? (ve.if((0, r.checkDataType)(ze.type, _e, se.strictNumbers)), U(N, ze), R.length === 1 && R[0] === ze.type && G && (ve.else(), (0, r.reportTypeError)(N)), ve.endIf()) : U(N, ze), Ce || ve.if((0, o._)`${l.default.errors} === ${ae || 0}`));
    }
  }
  function U(N, R) {
    const { gen: G, schema: ae, opts: { useDefaults: ve } } = N;
    ve && (0, n.assignDefaults)(N, R.type), G.block(() => {
      for (const ne of R.rules)
        (0, i.shouldUseRule)(ae, ne) && z(N, ne.keyword, ne.definition, R.type);
    });
  }
  function Z(N, R) {
    N.schemaEnv.meta || !N.opts.strictTypes || (J(N, R), N.opts.allowUnionTypes || A(N, R), T(N, N.dataTypes));
  }
  function J(N, R) {
    if (R.length) {
      if (!N.dataTypes.length) {
        N.dataTypes = R;
        return;
      }
      R.forEach((G) => {
        x(N.dataTypes, G) || V(N, `type "${G}" not allowed by context "${N.dataTypes.join(",")}"`);
      }), $(N, R);
    }
  }
  function A(N, R) {
    R.length > 1 && !(R.length === 2 && R.includes("null")) && V(N, "use allowUnionTypes to allow union type keyword");
  }
  function T(N, R) {
    const G = N.self.RULES.all;
    for (const ae in G) {
      const ve = G[ae];
      if (typeof ve == "object" && (0, i.shouldUseRule)(N.schema, ve)) {
        const { type: ne } = ve.definition;
        ne.length && !ne.some((_e) => E(R, _e)) && V(N, `missing type "${ne.join(",")}" for keyword "${ae}"`);
      }
    }
  }
  function E(N, R) {
    return N.includes(R) || R === "number" && N.includes("integer");
  }
  function x(N, R) {
    return N.includes(R) || R === "integer" && N.includes("number");
  }
  function $(N, R) {
    const G = [];
    for (const ae of N.dataTypes)
      x(R, ae) ? G.push(ae) : R.includes("integer") && ae === "number" && G.push("integer");
    N.dataTypes = G;
  }
  function V(N, R) {
    const G = N.schemaEnv.baseId + N.errSchemaPath;
    R += ` at "${G}" (strictTypes)`, (0, c.checkStrictMode)(N, R, N.opts.strictTypes);
  }
  class F {
    constructor(R, G, ae) {
      if ((0, t.validateKeywordUsage)(R, G, ae), this.gen = R.gen, this.allErrors = R.allErrors, this.keyword = ae, this.data = R.data, this.schema = R.schema[ae], this.$data = G.$data && R.opts.$data && this.schema && this.schema.$data, this.schemaValue = (0, c.schemaRefOrVal)(R, this.schema, ae, this.$data), this.schemaType = G.schemaType, this.parentSchema = R.schema, this.params = {}, this.it = R, this.def = G, this.$data)
        this.schemaCode = R.gen.const("vSchema", te(this.$data, R));
      else if (this.schemaCode = this.schemaValue, !(0, t.validSchemaType)(this.schema, G.schemaType, G.allowUndefined))
        throw new Error(`${ae} value must be ${JSON.stringify(G.schemaType)}`);
      ("code" in G ? G.trackErrors : G.errors !== !1) && (this.errsCount = R.gen.const("_errs", l.default.errors));
    }
    result(R, G, ae) {
      this.failResult((0, o.not)(R), G, ae);
    }
    failResult(R, G, ae) {
      this.gen.if(R), ae ? ae() : this.error(), G ? (this.gen.else(), G(), this.allErrors && this.gen.endIf()) : this.allErrors ? this.gen.endIf() : this.gen.else();
    }
    pass(R, G) {
      this.failResult((0, o.not)(R), void 0, G);
    }
    fail(R) {
      if (R === void 0) {
        this.error(), this.allErrors || this.gen.if(!1);
        return;
      }
      this.gen.if(R), this.error(), this.allErrors ? this.gen.endIf() : this.gen.else();
    }
    fail$data(R) {
      if (!this.$data)
        return this.fail(R);
      const { schemaCode: G } = this;
      this.fail((0, o._)`${G} !== undefined && (${(0, o.or)(this.invalid$data(), R)})`);
    }
    error(R, G, ae) {
      if (G) {
        this.setParams(G), this._error(R, ae), this.setParams({});
        return;
      }
      this._error(R, ae);
    }
    _error(R, G) {
      (R ? d.reportExtraError : d.reportError)(this, this.def.error, G);
    }
    $dataError() {
      (0, d.reportError)(this, this.def.$dataError || d.keyword$DataError);
    }
    reset() {
      if (this.errsCount === void 0)
        throw new Error('add "trackErrors" to keyword definition');
      (0, d.resetErrorsCount)(this.gen, this.errsCount);
    }
    ok(R) {
      this.allErrors || this.gen.if(R);
    }
    setParams(R, G) {
      G ? Object.assign(this.params, R) : this.params = R;
    }
    block$data(R, G, ae = o.nil) {
      this.gen.block(() => {
        this.check$data(R, ae), G();
      });
    }
    check$data(R = o.nil, G = o.nil) {
      if (!this.$data)
        return;
      const { gen: ae, schemaCode: ve, schemaType: ne, def: _e } = this;
      ae.if((0, o.or)((0, o._)`${ve} === undefined`, G)), R !== o.nil && ae.assign(R, !0), (ne.length || _e.validateSchema) && (ae.elseIf(this.invalid$data()), this.$dataError(), R !== o.nil && ae.assign(R, !1)), ae.else();
    }
    invalid$data() {
      const { gen: R, schemaCode: G, schemaType: ae, def: ve, it: ne } = this;
      return (0, o.or)(_e(), Ce());
      function _e() {
        if (ae.length) {
          if (!(G instanceof o.Name))
            throw new Error("ajv implementation error");
          const se = Array.isArray(ae) ? ae : [ae];
          return (0, o._)`${(0, r.checkDataTypes)(se, G, ne.opts.strictNumbers, r.DataType.Wrong)}`;
        }
        return o.nil;
      }
      function Ce() {
        if (ve.validateSchema) {
          const se = R.scopeValue("validate$data", { ref: ve.validateSchema });
          return (0, o._)`!${se}(${G})`;
        }
        return o.nil;
      }
    }
    subschema(R, G) {
      const ae = (0, s.getSubschema)(this.it, R);
      (0, s.extendSubschemaData)(ae, this.it, R), (0, s.extendSubschemaMode)(ae, R);
      const ve = { ...this.it, ...ae, items: void 0, props: void 0 };
      return b(ve, G), ve;
    }
    mergeEvaluated(R, G) {
      const { it: ae, gen: ve } = this;
      ae.opts.unevaluated && (ae.props !== !0 && R.props !== void 0 && (ae.props = c.mergeEvaluated.props(ve, R.props, ae.props, G)), ae.items !== !0 && R.items !== void 0 && (ae.items = c.mergeEvaluated.items(ve, R.items, ae.items, G)));
    }
    mergeValidEvaluated(R, G) {
      const { it: ae, gen: ve } = this;
      if (ae.opts.unevaluated && (ae.props !== !0 || ae.items !== !0))
        return ve.if(G, () => this.mergeEvaluated(R, o.Name)), !0;
    }
  }
  ka.KeywordCxt = F;
  function z(N, R, G, ae) {
    const ve = new F(N, G, R);
    "code" in G ? G.code(ve, ae) : ve.$data && G.validate ? (0, t.funcKeywordCode)(ve, G) : "macro" in G ? (0, t.macroKeywordCode)(ve, G) : (G.compile || G.validate) && (0, t.funcKeywordCode)(ve, G);
  }
  const X = /^\/(?:[^~]|~0|~1)*$/, Q = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
  function te(N, { dataLevel: R, dataNames: G, dataPathArr: ae }) {
    let ve, ne;
    if (N === "")
      return l.default.rootData;
    if (N[0] === "/") {
      if (!X.test(N))
        throw new Error(`Invalid JSON-pointer: ${N}`);
      ve = N, ne = l.default.rootData;
    } else {
      const ge = Q.exec(N);
      if (!ge)
        throw new Error(`Invalid JSON-pointer: ${N}`);
      const we = +ge[1];
      if (ve = ge[2], ve === "#") {
        if (we >= R)
          throw new Error(se("property/index", we));
        return ae[R - we];
      }
      if (we > R)
        throw new Error(se("data", we));
      if (ne = G[R - we], !ve)
        return ne;
    }
    let _e = ne;
    const Ce = ve.split("/");
    for (const ge of Ce)
      ge && (ne = (0, o._)`${ne}${(0, o.getProperty)((0, c.unescapeJsonPointer)(ge))}`, _e = (0, o._)`${_e} && ${ne}`);
    return _e;
    function se(ge, we) {
      return `Cannot access ${ge} ${we} levels up, current level is ${R}`;
    }
  }
  return ka.getData = te, ka;
}
var Hr = {}, Zc;
function Is() {
  if (Zc) return Hr;
  Zc = 1, Object.defineProperty(Hr, "__esModule", { value: !0 });
  class e extends Error {
    constructor(i) {
      super("validation failed"), this.errors = i, this.ajv = this.validation = !0;
    }
  }
  return Hr.default = e, Hr;
}
var Ur = {}, Jc;
function Ir() {
  if (Jc) return Ur;
  Jc = 1, Object.defineProperty(Ur, "__esModule", { value: !0 });
  const e = Vs();
  class a extends Error {
    constructor(r, n, t, s) {
      super(s || `can't resolve reference ${t} from id ${n}`), this.missingRef = (0, e.resolveUrl)(r, n, t), this.missingSchema = (0, e.normalizeId)((0, e.getFullPath)(r, this.missingRef));
    }
  }
  return Ur.default = a, Ur;
}
var Nt = {}, Qc;
function Os() {
  if (Qc) return Nt;
  Qc = 1, Object.defineProperty(Nt, "__esModule", { value: !0 }), Nt.resolveSchema = Nt.getCompilingSchema = Nt.resolveRef = Nt.compileSchema = Nt.SchemaEnv = void 0;
  const e = Ie(), a = Is(), i = Zt(), r = Vs(), n = Me(), t = zn();
  class s {
    constructor(m) {
      var p;
      this.refs = {}, this.dynamicAnchors = {};
      let b;
      typeof m.schema == "object" && (b = m.schema), this.schema = m.schema, this.schemaId = m.schemaId, this.root = m.root || this, this.baseId = (p = m.baseId) !== null && p !== void 0 ? p : (0, r.normalizeId)(b?.[m.schemaId || "$id"]), this.schemaPath = m.schemaPath, this.localRefs = m.localRefs, this.meta = m.meta, this.$async = b?.$async, this.refs = {};
    }
  }
  Nt.SchemaEnv = s;
  function o(y) {
    const m = c.call(this, y);
    if (m)
      return m;
    const p = (0, r.getFullPath)(this.opts.uriResolver, y.root.baseId), { es5: b, lines: w } = this.opts.code, { ownProperties: k } = this.opts, S = new e.CodeGen(this.scope, { es5: b, lines: w, ownProperties: k });
    let _;
    y.$async && (_ = S.scopeValue("Error", {
      ref: a.default,
      code: (0, e._)`require("ajv/dist/runtime/validation_error").default`
    }));
    const P = S.scopeName("validate");
    y.validateName = P;
    const M = {
      gen: S,
      allErrors: this.opts.allErrors,
      data: i.default.data,
      parentData: i.default.parentData,
      parentDataProperty: i.default.parentDataProperty,
      dataNames: [i.default.data],
      dataPathArr: [e.nil],
      // TODO can its length be used as dataLevel if nil is removed?
      dataLevel: 0,
      dataTypes: [],
      definedProperties: /* @__PURE__ */ new Set(),
      topSchemaRef: S.scopeValue("schema", this.opts.code.source === !0 ? { ref: y.schema, code: (0, e.stringify)(y.schema) } : { ref: y.schema }),
      validateName: P,
      ValidationError: _,
      schema: y.schema,
      schemaEnv: y,
      rootId: p,
      baseId: y.baseId || p,
      schemaPath: e.nil,
      errSchemaPath: y.schemaPath || (this.opts.jtd ? "" : "#"),
      errorPath: (0, e._)`""`,
      opts: this.opts,
      self: this
    };
    let q;
    try {
      this._compilations.add(y), (0, t.validateFunctionCode)(M), S.optimize(this.opts.code.optimize);
      const K = S.toString();
      q = `${S.scopeRefs(i.default.scope)}return ${K}`, this.opts.code.process && (q = this.opts.code.process(q, y));
      const H = new Function(`${i.default.self}`, `${i.default.scope}`, q)(this, this.scope.get());
      if (this.scope.value(P, { ref: H }), H.errors = null, H.schema = y.schema, H.schemaEnv = y, y.$async && (H.$async = !0), this.opts.code.source === !0 && (H.source = { validateName: P, validateCode: K, scopeValues: S._values }), this.opts.unevaluated) {
        const { props: B, items: L } = M;
        H.evaluated = {
          props: B instanceof e.Name ? void 0 : B,
          items: L instanceof e.Name ? void 0 : L,
          dynamicProps: B instanceof e.Name,
          dynamicItems: L instanceof e.Name
        }, H.source && (H.source.evaluated = (0, e.stringify)(H.evaluated));
      }
      return y.validate = H, y;
    } catch (K) {
      throw delete y.validate, delete y.validateName, q && this.logger.error("Error compiling schema, function code:", q), K;
    } finally {
      this._compilations.delete(y);
    }
  }
  Nt.compileSchema = o;
  function l(y, m, p) {
    var b;
    p = (0, r.resolveUrl)(this.opts.uriResolver, m, p);
    const w = y.refs[p];
    if (w)
      return w;
    let k = f.call(this, y, p);
    if (k === void 0) {
      const S = (b = y.localRefs) === null || b === void 0 ? void 0 : b[p], { schemaId: _ } = this.opts;
      S && (k = new s({ schema: S, schemaId: _, root: y, baseId: m }));
    }
    if (k !== void 0)
      return y.refs[p] = u.call(this, k);
  }
  Nt.resolveRef = l;
  function u(y) {
    return (0, r.inlineRef)(y.schema, this.opts.inlineRefs) ? y.schema : y.validate ? y : o.call(this, y);
  }
  function c(y) {
    for (const m of this._compilations)
      if (d(m, y))
        return m;
  }
  Nt.getCompilingSchema = c;
  function d(y, m) {
    return y.schema === m.schema && y.root === m.root && y.baseId === m.baseId;
  }
  function f(y, m) {
    let p;
    for (; typeof (p = this.refs[m]) == "string"; )
      m = p;
    return p || this.schemas[m] || v.call(this, y, m);
  }
  function v(y, m) {
    const p = this.opts.uriResolver.parse(m), b = (0, r._getFullPath)(this.opts.uriResolver, p);
    let w = (0, r.getFullPath)(this.opts.uriResolver, y.baseId, void 0);
    if (Object.keys(y.schema).length > 0 && b === w)
      return h.call(this, p, y);
    const k = (0, r.normalizeId)(b), S = this.refs[k] || this.schemas[k];
    if (typeof S == "string") {
      const _ = v.call(this, y, S);
      return typeof _?.schema != "object" ? void 0 : h.call(this, p, _);
    }
    if (typeof S?.schema == "object") {
      if (S.validate || o.call(this, S), k === (0, r.normalizeId)(m)) {
        const { schema: _ } = S, { schemaId: P } = this.opts, M = _[P];
        return M && (w = (0, r.resolveUrl)(this.opts.uriResolver, w, M)), new s({ schema: _, schemaId: P, root: y, baseId: w });
      }
      return h.call(this, p, S);
    }
  }
  Nt.resolveSchema = v;
  const g = /* @__PURE__ */ new Set([
    "properties",
    "patternProperties",
    "enum",
    "dependencies",
    "definitions"
  ]);
  function h(y, { baseId: m, schema: p, root: b }) {
    var w;
    if (((w = y.fragment) === null || w === void 0 ? void 0 : w[0]) !== "/")
      return;
    for (const _ of y.fragment.slice(1).split("/")) {
      if (typeof p == "boolean")
        return;
      const P = p[(0, n.unescapeFragment)(_)];
      if (P === void 0)
        return;
      p = P;
      const M = typeof p == "object" && p[this.opts.schemaId];
      !g.has(_) && M && (m = (0, r.resolveUrl)(this.opts.uriResolver, m, M));
    }
    let k;
    if (typeof p != "boolean" && p.$ref && !(0, n.schemaHasRulesButRef)(p, this.RULES)) {
      const _ = (0, r.resolveUrl)(this.opts.uriResolver, m, p.$ref);
      k = v.call(this, b, _);
    }
    const { schemaId: S } = this.opts;
    if (k = k || new s({ schema: p, schemaId: S, root: b, baseId: m }), k.schema !== k.root.schema)
      return k;
  }
  return Nt;
}
const pg = "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#", hg = "Meta-schema for $data reference (JSON AnySchema extension proposal)", yg = "object", gg = ["$data"], bg = { $data: { type: "string", anyOf: [{ format: "relative-json-pointer" }, { format: "json-pointer" }] } }, kg = !1, wg = {
  $id: pg,
  description: hg,
  type: yg,
  required: gg,
  properties: bg,
  additionalProperties: kg
};
var Wr = {}, Qn = { exports: {} }, Al, ed;
function av() {
  if (ed) return Al;
  ed = 1;
  const e = RegExp.prototype.test.bind(/^[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}$/iu), a = RegExp.prototype.test.bind(/^(?:(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)$/u);
  function i(f) {
    let v = "", g = 0, h = 0;
    for (h = 0; h < f.length; h++)
      if (g = f[h].charCodeAt(0), g !== 48) {
        if (!(g >= 48 && g <= 57 || g >= 65 && g <= 70 || g >= 97 && g <= 102))
          return "";
        v += f[h];
        break;
      }
    for (h += 1; h < f.length; h++) {
      if (g = f[h].charCodeAt(0), !(g >= 48 && g <= 57 || g >= 65 && g <= 70 || g >= 97 && g <= 102))
        return "";
      v += f[h];
    }
    return v;
  }
  const r = RegExp.prototype.test.bind(/[^!"$&'()*+,\-.;=_`a-z{}~]/u);
  function n(f) {
    return f.length = 0, !0;
  }
  function t(f, v, g) {
    if (f.length) {
      const h = i(f);
      if (h !== "")
        v.push(h);
      else
        return g.error = !0, !1;
      f.length = 0;
    }
    return !0;
  }
  function s(f) {
    let v = 0;
    const g = { error: !1, address: "", zone: "" }, h = [], y = [];
    let m = !1, p = !1, b = t;
    for (let w = 0; w < f.length; w++) {
      const k = f[w];
      if (!(k === "[" || k === "]"))
        if (k === ":") {
          if (m === !0 && (p = !0), !b(y, h, g))
            break;
          if (++v > 7) {
            g.error = !0;
            break;
          }
          w > 0 && f[w - 1] === ":" && (m = !0), h.push(":");
          continue;
        } else if (k === "%") {
          if (!b(y, h, g))
            break;
          b = n;
        } else {
          y.push(k);
          continue;
        }
    }
    return y.length && (b === n ? g.zone = y.join("") : p ? h.push(y.join("")) : h.push(i(y))), g.address = h.join(""), g;
  }
  function o(f) {
    if (l(f, ":") < 2)
      return { host: f, isIPV6: !1 };
    const v = s(f);
    if (v.error)
      return { host: f, isIPV6: !1 };
    {
      let g = v.address, h = v.address;
      return v.zone && (g += "%" + v.zone, h += "%25" + v.zone), { host: g, isIPV6: !0, escapedHost: h };
    }
  }
  function l(f, v) {
    let g = 0;
    for (let h = 0; h < f.length; h++)
      f[h] === v && g++;
    return g;
  }
  function u(f) {
    let v = f;
    const g = [];
    let h = -1, y = 0;
    for (; y = v.length; ) {
      if (y === 1) {
        if (v === ".")
          break;
        if (v === "/") {
          g.push("/");
          break;
        } else {
          g.push(v);
          break;
        }
      } else if (y === 2) {
        if (v[0] === ".") {
          if (v[1] === ".")
            break;
          if (v[1] === "/") {
            v = v.slice(2);
            continue;
          }
        } else if (v[0] === "/" && (v[1] === "." || v[1] === "/")) {
          g.push("/");
          break;
        }
      } else if (y === 3 && v === "/..") {
        g.length !== 0 && g.pop(), g.push("/");
        break;
      }
      if (v[0] === ".") {
        if (v[1] === ".") {
          if (v[2] === "/") {
            v = v.slice(3);
            continue;
          }
        } else if (v[1] === "/") {
          v = v.slice(2);
          continue;
        }
      } else if (v[0] === "/" && v[1] === ".") {
        if (v[2] === "/") {
          v = v.slice(2);
          continue;
        } else if (v[2] === "." && v[3] === "/") {
          v = v.slice(3), g.length !== 0 && g.pop();
          continue;
        }
      }
      if ((h = v.indexOf("/", 1)) === -1) {
        g.push(v);
        break;
      } else
        g.push(v.slice(0, h)), v = v.slice(h);
    }
    return g.join("");
  }
  function c(f, v) {
    const g = v !== !0 ? escape : unescape;
    return f.scheme !== void 0 && (f.scheme = g(f.scheme)), f.userinfo !== void 0 && (f.userinfo = g(f.userinfo)), f.host !== void 0 && (f.host = g(f.host)), f.path !== void 0 && (f.path = g(f.path)), f.query !== void 0 && (f.query = g(f.query)), f.fragment !== void 0 && (f.fragment = g(f.fragment)), f;
  }
  function d(f) {
    const v = [];
    if (f.userinfo !== void 0 && (v.push(f.userinfo), v.push("@")), f.host !== void 0) {
      let g = unescape(f.host);
      if (!a(g)) {
        const h = o(g);
        h.isIPV6 === !0 ? g = `[${h.escapedHost}]` : g = f.host;
      }
      v.push(g);
    }
    return (typeof f.port == "number" || typeof f.port == "string") && (v.push(":"), v.push(String(f.port))), v.length ? v.join("") : void 0;
  }
  return Al = {
    nonSimpleDomain: r,
    recomposeAuthority: d,
    normalizeComponentEncoding: c,
    removeDotSegments: u,
    isIPv4: a,
    isUUID: e,
    normalizeIPv6: o,
    stringArrayToHexStripped: i
  }, Al;
}
var Tl, td;
function Sg() {
  if (td) return Tl;
  td = 1;
  const { isUUID: e } = av(), a = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu, i = (
    /** @type {const} */
    [
      "http",
      "https",
      "ws",
      "wss",
      "urn",
      "urn:uuid"
    ]
  );
  function r(k) {
    return i.indexOf(
      /** @type {*} */
      k
    ) !== -1;
  }
  function n(k) {
    return k.secure === !0 ? !0 : k.secure === !1 ? !1 : k.scheme ? k.scheme.length === 3 && (k.scheme[0] === "w" || k.scheme[0] === "W") && (k.scheme[1] === "s" || k.scheme[1] === "S") && (k.scheme[2] === "s" || k.scheme[2] === "S") : !1;
  }
  function t(k) {
    return k.host || (k.error = k.error || "HTTP URIs must have a host."), k;
  }
  function s(k) {
    const S = String(k.scheme).toLowerCase() === "https";
    return (k.port === (S ? 443 : 80) || k.port === "") && (k.port = void 0), k.path || (k.path = "/"), k;
  }
  function o(k) {
    return k.secure = n(k), k.resourceName = (k.path || "/") + (k.query ? "?" + k.query : ""), k.path = void 0, k.query = void 0, k;
  }
  function l(k) {
    if ((k.port === (n(k) ? 443 : 80) || k.port === "") && (k.port = void 0), typeof k.secure == "boolean" && (k.scheme = k.secure ? "wss" : "ws", k.secure = void 0), k.resourceName) {
      const [S, _] = k.resourceName.split("?");
      k.path = S && S !== "/" ? S : void 0, k.query = _, k.resourceName = void 0;
    }
    return k.fragment = void 0, k;
  }
  function u(k, S) {
    if (!k.path)
      return k.error = "URN can not be parsed", k;
    const _ = k.path.match(a);
    if (_) {
      const P = S.scheme || k.scheme || "urn";
      k.nid = _[1].toLowerCase(), k.nss = _[2];
      const M = `${P}:${S.nid || k.nid}`, q = w(M);
      k.path = void 0, q && (k = q.parse(k, S));
    } else
      k.error = k.error || "URN can not be parsed.";
    return k;
  }
  function c(k, S) {
    if (k.nid === void 0)
      throw new Error("URN without nid cannot be serialized");
    const _ = S.scheme || k.scheme || "urn", P = k.nid.toLowerCase(), M = `${_}:${S.nid || P}`, q = w(M);
    q && (k = q.serialize(k, S));
    const K = k, j = k.nss;
    return K.path = `${P || S.nid}:${j}`, S.skipEscape = !0, K;
  }
  function d(k, S) {
    const _ = k;
    return _.uuid = _.nss, _.nss = void 0, !S.tolerant && (!_.uuid || !e(_.uuid)) && (_.error = _.error || "UUID is not valid."), _;
  }
  function f(k) {
    const S = k;
    return S.nss = (k.uuid || "").toLowerCase(), S;
  }
  const v = (
    /** @type {SchemeHandler} */
    {
      scheme: "http",
      domainHost: !0,
      parse: t,
      serialize: s
    }
  ), g = (
    /** @type {SchemeHandler} */
    {
      scheme: "https",
      domainHost: v.domainHost,
      parse: t,
      serialize: s
    }
  ), h = (
    /** @type {SchemeHandler} */
    {
      scheme: "ws",
      domainHost: !0,
      parse: o,
      serialize: l
    }
  ), y = (
    /** @type {SchemeHandler} */
    {
      scheme: "wss",
      domainHost: h.domainHost,
      parse: h.parse,
      serialize: h.serialize
    }
  ), b = (
    /** @type {Record<SchemeName, SchemeHandler>} */
    {
      http: v,
      https: g,
      ws: h,
      wss: y,
      urn: (
        /** @type {SchemeHandler} */
        {
          scheme: "urn",
          parse: u,
          serialize: c,
          skipNormalize: !0
        }
      ),
      "urn:uuid": (
        /** @type {SchemeHandler} */
        {
          scheme: "urn:uuid",
          parse: d,
          serialize: f,
          skipNormalize: !0
        }
      )
    }
  );
  Object.setPrototypeOf(b, null);
  function w(k) {
    return k && (b[
      /** @type {SchemeName} */
      k
    ] || b[
      /** @type {SchemeName} */
      k.toLowerCase()
    ]) || void 0;
  }
  return Tl = {
    wsIsSecure: n,
    SCHEMES: b,
    isValidSchemeName: r,
    getSchemeHandler: w
  }, Tl;
}
var ad;
function $g() {
  if (ad) return Qn.exports;
  ad = 1;
  const { normalizeIPv6: e, removeDotSegments: a, recomposeAuthority: i, normalizeComponentEncoding: r, isIPv4: n, nonSimpleDomain: t } = av(), { SCHEMES: s, getSchemeHandler: o } = Sg();
  function l(y, m) {
    return typeof y == "string" ? y = /** @type {T} */
    f(g(y, m), m) : typeof y == "object" && (y = /** @type {T} */
    g(f(y, m), m)), y;
  }
  function u(y, m, p) {
    const b = p ? Object.assign({ scheme: "null" }, p) : { scheme: "null" }, w = c(g(y, b), g(m, b), b, !0);
    return b.skipEscape = !0, f(w, b);
  }
  function c(y, m, p, b) {
    const w = {};
    return b || (y = g(f(y, p), p), m = g(f(m, p), p)), p = p || {}, !p.tolerant && m.scheme ? (w.scheme = m.scheme, w.userinfo = m.userinfo, w.host = m.host, w.port = m.port, w.path = a(m.path || ""), w.query = m.query) : (m.userinfo !== void 0 || m.host !== void 0 || m.port !== void 0 ? (w.userinfo = m.userinfo, w.host = m.host, w.port = m.port, w.path = a(m.path || ""), w.query = m.query) : (m.path ? (m.path[0] === "/" ? w.path = a(m.path) : ((y.userinfo !== void 0 || y.host !== void 0 || y.port !== void 0) && !y.path ? w.path = "/" + m.path : y.path ? w.path = y.path.slice(0, y.path.lastIndexOf("/") + 1) + m.path : w.path = m.path, w.path = a(w.path)), w.query = m.query) : (w.path = y.path, m.query !== void 0 ? w.query = m.query : w.query = y.query), w.userinfo = y.userinfo, w.host = y.host, w.port = y.port), w.scheme = y.scheme), w.fragment = m.fragment, w;
  }
  function d(y, m, p) {
    return typeof y == "string" ? (y = unescape(y), y = f(r(g(y, p), !0), { ...p, skipEscape: !0 })) : typeof y == "object" && (y = f(r(y, !0), { ...p, skipEscape: !0 })), typeof m == "string" ? (m = unescape(m), m = f(r(g(m, p), !0), { ...p, skipEscape: !0 })) : typeof m == "object" && (m = f(r(m, !0), { ...p, skipEscape: !0 })), y.toLowerCase() === m.toLowerCase();
  }
  function f(y, m) {
    const p = {
      host: y.host,
      scheme: y.scheme,
      userinfo: y.userinfo,
      port: y.port,
      path: y.path,
      query: y.query,
      nid: y.nid,
      nss: y.nss,
      uuid: y.uuid,
      fragment: y.fragment,
      reference: y.reference,
      resourceName: y.resourceName,
      secure: y.secure,
      error: ""
    }, b = Object.assign({}, m), w = [], k = o(b.scheme || p.scheme);
    k && k.serialize && k.serialize(p, b), p.path !== void 0 && (b.skipEscape ? p.path = unescape(p.path) : (p.path = escape(p.path), p.scheme !== void 0 && (p.path = p.path.split("%3A").join(":")))), b.reference !== "suffix" && p.scheme && w.push(p.scheme, ":");
    const S = i(p);
    if (S !== void 0 && (b.reference !== "suffix" && w.push("//"), w.push(S), p.path && p.path[0] !== "/" && w.push("/")), p.path !== void 0) {
      let _ = p.path;
      !b.absolutePath && (!k || !k.absolutePath) && (_ = a(_)), S === void 0 && _[0] === "/" && _[1] === "/" && (_ = "/%2F" + _.slice(2)), w.push(_);
    }
    return p.query !== void 0 && w.push("?", p.query), p.fragment !== void 0 && w.push("#", p.fragment), w.join("");
  }
  const v = /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;
  function g(y, m) {
    const p = Object.assign({}, m), b = {
      scheme: void 0,
      userinfo: void 0,
      host: "",
      port: void 0,
      path: "",
      query: void 0,
      fragment: void 0
    };
    let w = !1;
    p.reference === "suffix" && (p.scheme ? y = p.scheme + ":" + y : y = "//" + y);
    const k = y.match(v);
    if (k) {
      if (b.scheme = k[1], b.userinfo = k[3], b.host = k[4], b.port = parseInt(k[5], 10), b.path = k[6] || "", b.query = k[7], b.fragment = k[8], isNaN(b.port) && (b.port = k[5]), b.host)
        if (n(b.host) === !1) {
          const P = e(b.host);
          b.host = P.host.toLowerCase(), w = P.isIPV6;
        } else
          w = !0;
      b.scheme === void 0 && b.userinfo === void 0 && b.host === void 0 && b.port === void 0 && b.query === void 0 && !b.path ? b.reference = "same-document" : b.scheme === void 0 ? b.reference = "relative" : b.fragment === void 0 ? b.reference = "absolute" : b.reference = "uri", p.reference && p.reference !== "suffix" && p.reference !== b.reference && (b.error = b.error || "URI is not a " + p.reference + " reference.");
      const S = o(p.scheme || b.scheme);
      if (!p.unicodeSupport && (!S || !S.unicodeSupport) && b.host && (p.domainHost || S && S.domainHost) && w === !1 && t(b.host))
        try {
          b.host = URL.domainToASCII(b.host.toLowerCase());
        } catch (_) {
          b.error = b.error || "Host's domain name can not be converted to ASCII: " + _;
        }
      (!S || S && !S.skipNormalize) && (y.indexOf("%") !== -1 && (b.scheme !== void 0 && (b.scheme = unescape(b.scheme)), b.host !== void 0 && (b.host = unescape(b.host))), b.path && (b.path = escape(unescape(b.path))), b.fragment && (b.fragment = encodeURI(decodeURIComponent(b.fragment)))), S && S.parse && S.parse(b, p);
    } else
      b.error = b.error || "URI can not be parsed.";
    return b;
  }
  const h = {
    SCHEMES: s,
    normalize: l,
    resolve: u,
    resolveComponent: c,
    equal: d,
    serialize: f,
    parse: g
  };
  return Qn.exports = h, Qn.exports.default = h, Qn.exports.fastUri = h, Qn.exports;
}
var nd;
function _g() {
  if (nd) return Wr;
  nd = 1, Object.defineProperty(Wr, "__esModule", { value: !0 });
  const e = $g();
  return e.code = 'require("ajv/dist/runtime/uri").default', Wr.default = e, Wr;
}
var rd;
function nv() {
  return rd || (rd = 1, (function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.CodeGen = e.Name = e.nil = e.stringify = e.str = e._ = e.KeywordCxt = void 0;
    var a = zn();
    Object.defineProperty(e, "KeywordCxt", { enumerable: !0, get: function() {
      return a.KeywordCxt;
    } });
    var i = Ie();
    Object.defineProperty(e, "_", { enumerable: !0, get: function() {
      return i._;
    } }), Object.defineProperty(e, "str", { enumerable: !0, get: function() {
      return i.str;
    } }), Object.defineProperty(e, "stringify", { enumerable: !0, get: function() {
      return i.stringify;
    } }), Object.defineProperty(e, "nil", { enumerable: !0, get: function() {
      return i.nil;
    } }), Object.defineProperty(e, "Name", { enumerable: !0, get: function() {
      return i.Name;
    } }), Object.defineProperty(e, "CodeGen", { enumerable: !0, get: function() {
      return i.CodeGen;
    } });
    const r = Is(), n = Ir(), t = Qm(), s = Os(), o = Ie(), l = Vs(), u = rs(), c = Me(), d = wg, f = _g(), v = (A, T) => new RegExp(A, T);
    v.code = "new RegExp";
    const g = ["removeAdditional", "useDefaults", "coerceTypes"], h = /* @__PURE__ */ new Set([
      "validate",
      "serialize",
      "parse",
      "wrapper",
      "root",
      "schema",
      "keyword",
      "pattern",
      "formats",
      "validate$data",
      "func",
      "obj",
      "Error"
    ]), y = {
      errorDataPath: "",
      format: "`validateFormats: false` can be used instead.",
      nullable: '"nullable" keyword is supported by default.',
      jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
      extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
      missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
      processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
      sourceCode: "Use option `code: {source: true}`",
      strictDefaults: "It is default now, see option `strict`.",
      strictKeywords: "It is default now, see option `strict`.",
      uniqueItems: '"uniqueItems" keyword is always validated.',
      unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
      cache: "Map is used as cache, schema object as key.",
      serialize: "Map is used as cache, schema object as key.",
      ajvErrors: "It is default now."
    }, m = {
      ignoreKeywordsWithRef: "",
      jsPropertySyntax: "",
      unicode: '"minLength"/"maxLength" account for unicode characters by default.'
    }, p = 200;
    function b(A) {
      var T, E, x, $, V, F, z, X, Q, te, N, R, G, ae, ve, ne, _e, Ce, se, ge, we, ke, ze, Ne, Re;
      const rt = A.strict, tt = (T = A.code) === null || T === void 0 ? void 0 : T.optimize, fa = tt === !0 || tt === void 0 ? 1 : tt || 0, Da = (x = (E = A.code) === null || E === void 0 ? void 0 : E.regExp) !== null && x !== void 0 ? x : v, Ct = ($ = A.uriResolver) !== null && $ !== void 0 ? $ : f.default;
      return {
        strictSchema: (F = (V = A.strictSchema) !== null && V !== void 0 ? V : rt) !== null && F !== void 0 ? F : !0,
        strictNumbers: (X = (z = A.strictNumbers) !== null && z !== void 0 ? z : rt) !== null && X !== void 0 ? X : !0,
        strictTypes: (te = (Q = A.strictTypes) !== null && Q !== void 0 ? Q : rt) !== null && te !== void 0 ? te : "log",
        strictTuples: (R = (N = A.strictTuples) !== null && N !== void 0 ? N : rt) !== null && R !== void 0 ? R : "log",
        strictRequired: (ae = (G = A.strictRequired) !== null && G !== void 0 ? G : rt) !== null && ae !== void 0 ? ae : !1,
        code: A.code ? { ...A.code, optimize: fa, regExp: Da } : { optimize: fa, regExp: Da },
        loopRequired: (ve = A.loopRequired) !== null && ve !== void 0 ? ve : p,
        loopEnum: (ne = A.loopEnum) !== null && ne !== void 0 ? ne : p,
        meta: (_e = A.meta) !== null && _e !== void 0 ? _e : !0,
        messages: (Ce = A.messages) !== null && Ce !== void 0 ? Ce : !0,
        inlineRefs: (se = A.inlineRefs) !== null && se !== void 0 ? se : !0,
        schemaId: (ge = A.schemaId) !== null && ge !== void 0 ? ge : "$id",
        addUsedSchema: (we = A.addUsedSchema) !== null && we !== void 0 ? we : !0,
        validateSchema: (ke = A.validateSchema) !== null && ke !== void 0 ? ke : !0,
        validateFormats: (ze = A.validateFormats) !== null && ze !== void 0 ? ze : !0,
        unicodeRegExp: (Ne = A.unicodeRegExp) !== null && Ne !== void 0 ? Ne : !0,
        int32range: (Re = A.int32range) !== null && Re !== void 0 ? Re : !0,
        uriResolver: Ct
      };
    }
    class w {
      constructor(T = {}) {
        this.schemas = {}, this.refs = {}, this.formats = {}, this._compilations = /* @__PURE__ */ new Set(), this._loading = {}, this._cache = /* @__PURE__ */ new Map(), T = this.opts = { ...T, ...b(T) };
        const { es5: E, lines: x } = this.opts.code;
        this.scope = new o.ValueScope({ scope: {}, prefixes: h, es5: E, lines: x }), this.logger = j(T.logger);
        const $ = T.validateFormats;
        T.validateFormats = !1, this.RULES = (0, t.getRules)(), k.call(this, y, T, "NOT SUPPORTED"), k.call(this, m, T, "DEPRECATED", "warn"), this._metaOpts = q.call(this), T.formats && P.call(this), this._addVocabularies(), this._addDefaultMetaSchema(), T.keywords && M.call(this, T.keywords), typeof T.meta == "object" && this.addMetaSchema(T.meta), _.call(this), T.validateFormats = $;
      }
      _addVocabularies() {
        this.addKeyword("$async");
      }
      _addDefaultMetaSchema() {
        const { $data: T, meta: E, schemaId: x } = this.opts;
        let $ = d;
        x === "id" && ($ = { ...d }, $.id = $.$id, delete $.$id), E && T && this.addMetaSchema($, $[x], !1);
      }
      defaultMeta() {
        const { meta: T, schemaId: E } = this.opts;
        return this.opts.defaultMeta = typeof T == "object" ? T[E] || T : void 0;
      }
      validate(T, E) {
        let x;
        if (typeof T == "string") {
          if (x = this.getSchema(T), !x)
            throw new Error(`no schema with key or ref "${T}"`);
        } else
          x = this.compile(T);
        const $ = x(E);
        return "$async" in x || (this.errors = x.errors), $;
      }
      compile(T, E) {
        const x = this._addSchema(T, E);
        return x.validate || this._compileSchemaEnv(x);
      }
      compileAsync(T, E) {
        if (typeof this.opts.loadSchema != "function")
          throw new Error("options.loadSchema should be a function");
        const { loadSchema: x } = this.opts;
        return $.call(this, T, E);
        async function $(te, N) {
          await V.call(this, te.$schema);
          const R = this._addSchema(te, N);
          return R.validate || F.call(this, R);
        }
        async function V(te) {
          te && !this.getSchema(te) && await $.call(this, { $ref: te }, !0);
        }
        async function F(te) {
          try {
            return this._compileSchemaEnv(te);
          } catch (N) {
            if (!(N instanceof n.default))
              throw N;
            return z.call(this, N), await X.call(this, N.missingSchema), F.call(this, te);
          }
        }
        function z({ missingSchema: te, missingRef: N }) {
          if (this.refs[te])
            throw new Error(`AnySchema ${te} is loaded but ${N} cannot be resolved`);
        }
        async function X(te) {
          const N = await Q.call(this, te);
          this.refs[te] || await V.call(this, N.$schema), this.refs[te] || this.addSchema(N, te, E);
        }
        async function Q(te) {
          const N = this._loading[te];
          if (N)
            return N;
          try {
            return await (this._loading[te] = x(te));
          } finally {
            delete this._loading[te];
          }
        }
      }
      // Adds schema to the instance
      addSchema(T, E, x, $ = this.opts.validateSchema) {
        if (Array.isArray(T)) {
          for (const F of T)
            this.addSchema(F, void 0, x, $);
          return this;
        }
        let V;
        if (typeof T == "object") {
          const { schemaId: F } = this.opts;
          if (V = T[F], V !== void 0 && typeof V != "string")
            throw new Error(`schema ${F} must be string`);
        }
        return E = (0, l.normalizeId)(E || V), this._checkUnique(E), this.schemas[E] = this._addSchema(T, x, E, $, !0), this;
      }
      // Add schema that will be used to validate other schemas
      // options in META_IGNORE_OPTIONS are alway set to false
      addMetaSchema(T, E, x = this.opts.validateSchema) {
        return this.addSchema(T, E, !0, x), this;
      }
      //  Validate schema against its meta-schema
      validateSchema(T, E) {
        if (typeof T == "boolean")
          return !0;
        let x;
        if (x = T.$schema, x !== void 0 && typeof x != "string")
          throw new Error("$schema must be a string");
        if (x = x || this.opts.defaultMeta || this.defaultMeta(), !x)
          return this.logger.warn("meta-schema not available"), this.errors = null, !0;
        const $ = this.validate(x, T);
        if (!$ && E) {
          const V = "schema is invalid: " + this.errorsText();
          if (this.opts.validateSchema === "log")
            this.logger.error(V);
          else
            throw new Error(V);
        }
        return $;
      }
      // Get compiled schema by `key` or `ref`.
      // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
      getSchema(T) {
        let E;
        for (; typeof (E = S.call(this, T)) == "string"; )
          T = E;
        if (E === void 0) {
          const { schemaId: x } = this.opts, $ = new s.SchemaEnv({ schema: {}, schemaId: x });
          if (E = s.resolveSchema.call(this, $, T), !E)
            return;
          this.refs[T] = E;
        }
        return E.validate || this._compileSchemaEnv(E);
      }
      // Remove cached schema(s).
      // If no parameter is passed all schemas but meta-schemas are removed.
      // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
      // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
      removeSchema(T) {
        if (T instanceof RegExp)
          return this._removeAllSchemas(this.schemas, T), this._removeAllSchemas(this.refs, T), this;
        switch (typeof T) {
          case "undefined":
            return this._removeAllSchemas(this.schemas), this._removeAllSchemas(this.refs), this._cache.clear(), this;
          case "string": {
            const E = S.call(this, T);
            return typeof E == "object" && this._cache.delete(E.schema), delete this.schemas[T], delete this.refs[T], this;
          }
          case "object": {
            const E = T;
            this._cache.delete(E);
            let x = T[this.opts.schemaId];
            return x && (x = (0, l.normalizeId)(x), delete this.schemas[x], delete this.refs[x]), this;
          }
          default:
            throw new Error("ajv.removeSchema: invalid parameter");
        }
      }
      // add "vocabulary" - a collection of keywords
      addVocabulary(T) {
        for (const E of T)
          this.addKeyword(E);
        return this;
      }
      addKeyword(T, E) {
        let x;
        if (typeof T == "string")
          x = T, typeof E == "object" && (this.logger.warn("these parameters are deprecated, see docs for addKeyword"), E.keyword = x);
        else if (typeof T == "object" && E === void 0) {
          if (E = T, x = E.keyword, Array.isArray(x) && !x.length)
            throw new Error("addKeywords: keyword must be string or non-empty array");
        } else
          throw new Error("invalid addKeywords parameters");
        if (B.call(this, x, E), !E)
          return (0, c.eachItem)(x, (V) => L.call(this, V)), this;
        U.call(this, E);
        const $ = {
          ...E,
          type: (0, u.getJSONTypes)(E.type),
          schemaType: (0, u.getJSONTypes)(E.schemaType)
        };
        return (0, c.eachItem)(x, $.type.length === 0 ? (V) => L.call(this, V, $) : (V) => $.type.forEach((F) => L.call(this, V, $, F))), this;
      }
      getKeyword(T) {
        const E = this.RULES.all[T];
        return typeof E == "object" ? E.definition : !!E;
      }
      // Remove keyword
      removeKeyword(T) {
        const { RULES: E } = this;
        delete E.keywords[T], delete E.all[T];
        for (const x of E.rules) {
          const $ = x.rules.findIndex((V) => V.keyword === T);
          $ >= 0 && x.rules.splice($, 1);
        }
        return this;
      }
      // Add format
      addFormat(T, E) {
        return typeof E == "string" && (E = new RegExp(E)), this.formats[T] = E, this;
      }
      errorsText(T = this.errors, { separator: E = ", ", dataVar: x = "data" } = {}) {
        return !T || T.length === 0 ? "No errors" : T.map(($) => `${x}${$.instancePath} ${$.message}`).reduce(($, V) => $ + E + V);
      }
      $dataMetaSchema(T, E) {
        const x = this.RULES.all;
        T = JSON.parse(JSON.stringify(T));
        for (const $ of E) {
          const V = $.split("/").slice(1);
          let F = T;
          for (const z of V)
            F = F[z];
          for (const z in x) {
            const X = x[z];
            if (typeof X != "object")
              continue;
            const { $data: Q } = X.definition, te = F[z];
            Q && te && (F[z] = J(te));
          }
        }
        return T;
      }
      _removeAllSchemas(T, E) {
        for (const x in T) {
          const $ = T[x];
          (!E || E.test(x)) && (typeof $ == "string" ? delete T[x] : $ && !$.meta && (this._cache.delete($.schema), delete T[x]));
        }
      }
      _addSchema(T, E, x, $ = this.opts.validateSchema, V = this.opts.addUsedSchema) {
        let F;
        const { schemaId: z } = this.opts;
        if (typeof T == "object")
          F = T[z];
        else {
          if (this.opts.jtd)
            throw new Error("schema must be object");
          if (typeof T != "boolean")
            throw new Error("schema must be object or boolean");
        }
        let X = this._cache.get(T);
        if (X !== void 0)
          return X;
        x = (0, l.normalizeId)(F || x);
        const Q = l.getSchemaRefs.call(this, T, x);
        return X = new s.SchemaEnv({ schema: T, schemaId: z, meta: E, baseId: x, localRefs: Q }), this._cache.set(X.schema, X), V && !x.startsWith("#") && (x && this._checkUnique(x), this.refs[x] = X), $ && this.validateSchema(T, !0), X;
      }
      _checkUnique(T) {
        if (this.schemas[T] || this.refs[T])
          throw new Error(`schema with key or id "${T}" already exists`);
      }
      _compileSchemaEnv(T) {
        if (T.meta ? this._compileMetaSchema(T) : s.compileSchema.call(this, T), !T.validate)
          throw new Error("ajv implementation error");
        return T.validate;
      }
      _compileMetaSchema(T) {
        const E = this.opts;
        this.opts = this._metaOpts;
        try {
          s.compileSchema.call(this, T);
        } finally {
          this.opts = E;
        }
      }
    }
    w.ValidationError = r.default, w.MissingRefError = n.default, e.default = w;
    function k(A, T, E, x = "error") {
      for (const $ in A) {
        const V = $;
        V in T && this.logger[x](`${E}: option ${$}. ${A[V]}`);
      }
    }
    function S(A) {
      return A = (0, l.normalizeId)(A), this.schemas[A] || this.refs[A];
    }
    function _() {
      const A = this.opts.schemas;
      if (A)
        if (Array.isArray(A))
          this.addSchema(A);
        else
          for (const T in A)
            this.addSchema(A[T], T);
    }
    function P() {
      for (const A in this.opts.formats) {
        const T = this.opts.formats[A];
        T && this.addFormat(A, T);
      }
    }
    function M(A) {
      if (Array.isArray(A)) {
        this.addVocabulary(A);
        return;
      }
      this.logger.warn("keywords option as map is deprecated, pass array");
      for (const T in A) {
        const E = A[T];
        E.keyword || (E.keyword = T), this.addKeyword(E);
      }
    }
    function q() {
      const A = { ...this.opts };
      for (const T of g)
        delete A[T];
      return A;
    }
    const K = { log() {
    }, warn() {
    }, error() {
    } };
    function j(A) {
      if (A === !1)
        return K;
      if (A === void 0)
        return console;
      if (A.log && A.warn && A.error)
        return A;
      throw new Error("logger must implement log, warn and error methods");
    }
    const H = /^[a-z_$][a-z0-9_$:-]*$/i;
    function B(A, T) {
      const { RULES: E } = this;
      if ((0, c.eachItem)(A, (x) => {
        if (E.keywords[x])
          throw new Error(`Keyword ${x} is already defined`);
        if (!H.test(x))
          throw new Error(`Keyword ${x} has invalid name`);
      }), !!T && T.$data && !("code" in T || "validate" in T))
        throw new Error('$data keyword must have "code" or "validate" function');
    }
    function L(A, T, E) {
      var x;
      const $ = T?.post;
      if (E && $)
        throw new Error('keyword with "post" flag cannot have "type"');
      const { RULES: V } = this;
      let F = $ ? V.post : V.rules.find(({ type: X }) => X === E);
      if (F || (F = { type: E, rules: [] }, V.rules.push(F)), V.keywords[A] = !0, !T)
        return;
      const z = {
        keyword: A,
        definition: {
          ...T,
          type: (0, u.getJSONTypes)(T.type),
          schemaType: (0, u.getJSONTypes)(T.schemaType)
        }
      };
      T.before ? O.call(this, F, z, T.before) : F.rules.push(z), V.all[A] = z, (x = T.implements) === null || x === void 0 || x.forEach((X) => this.addKeyword(X));
    }
    function O(A, T, E) {
      const x = A.rules.findIndex(($) => $.keyword === E);
      x >= 0 ? A.rules.splice(x, 0, T) : (A.rules.push(T), this.logger.warn(`rule ${E} is not defined`));
    }
    function U(A) {
      let { metaSchema: T } = A;
      T !== void 0 && (A.$data && this.opts.$data && (T = J(T)), A.validateSchema = this.compile(T, !0));
    }
    const Z = {
      $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
    };
    function J(A) {
      return { anyOf: [A, Z] };
    }
  })(Pl)), Pl;
}
var Gr = {}, Yr = {}, Xr = {}, id;
function Pg() {
  if (id) return Xr;
  id = 1, Object.defineProperty(Xr, "__esModule", { value: !0 });
  const e = {
    keyword: "id",
    code() {
      throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
    }
  };
  return Xr.default = e, Xr;
}
var Ma = {}, sd;
function Jo() {
  if (sd) return Ma;
  sd = 1, Object.defineProperty(Ma, "__esModule", { value: !0 }), Ma.callRef = Ma.getValidate = void 0;
  const e = Ir(), a = ca(), i = Ie(), r = Zt(), n = Os(), t = Me(), s = {
    keyword: "$ref",
    schemaType: "string",
    code(u) {
      const { gen: c, schema: d, it: f } = u, { baseId: v, schemaEnv: g, validateName: h, opts: y, self: m } = f, { root: p } = g;
      if ((d === "#" || d === "#/") && v === p.baseId)
        return w();
      const b = n.resolveRef.call(m, p, v, d);
      if (b === void 0)
        throw new e.default(f.opts.uriResolver, v, d);
      if (b instanceof n.SchemaEnv)
        return k(b);
      return S(b);
      function w() {
        if (g === p)
          return l(u, h, g, g.$async);
        const _ = c.scopeValue("root", { ref: p });
        return l(u, (0, i._)`${_}.validate`, p, p.$async);
      }
      function k(_) {
        const P = o(u, _);
        l(u, P, _, _.$async);
      }
      function S(_) {
        const P = c.scopeValue("schema", y.code.source === !0 ? { ref: _, code: (0, i.stringify)(_) } : { ref: _ }), M = c.name("valid"), q = u.subschema({
          schema: _,
          dataTypes: [],
          schemaPath: i.nil,
          topSchemaRef: P,
          errSchemaPath: d
        }, M);
        u.mergeEvaluated(q), u.ok(M);
      }
    }
  };
  function o(u, c) {
    const { gen: d } = u;
    return c.validate ? d.scopeValue("validate", { ref: c.validate }) : (0, i._)`${d.scopeValue("wrapper", { ref: c })}.validate`;
  }
  Ma.getValidate = o;
  function l(u, c, d, f) {
    const { gen: v, it: g } = u, { allErrors: h, schemaEnv: y, opts: m } = g, p = m.passContext ? r.default.this : i.nil;
    f ? b() : w();
    function b() {
      if (!y.$async)
        throw new Error("async schema referenced by sync schema");
      const _ = v.let("valid");
      v.try(() => {
        v.code((0, i._)`await ${(0, a.callValidateCode)(u, c, p)}`), S(c), h || v.assign(_, !0);
      }, (P) => {
        v.if((0, i._)`!(${P} instanceof ${g.ValidationError})`, () => v.throw(P)), k(P), h || v.assign(_, !1);
      }), u.ok(_);
    }
    function w() {
      u.result((0, a.callValidateCode)(u, c, p), () => S(c), () => k(c));
    }
    function k(_) {
      const P = (0, i._)`${_}.errors`;
      v.assign(r.default.vErrors, (0, i._)`${r.default.vErrors} === null ? ${P} : ${r.default.vErrors}.concat(${P})`), v.assign(r.default.errors, (0, i._)`${r.default.vErrors}.length`);
    }
    function S(_) {
      var P;
      if (!g.opts.unevaluated)
        return;
      const M = (P = d?.validate) === null || P === void 0 ? void 0 : P.evaluated;
      if (g.props !== !0)
        if (M && !M.dynamicProps)
          M.props !== void 0 && (g.props = t.mergeEvaluated.props(v, M.props, g.props));
        else {
          const q = v.var("props", (0, i._)`${_}.evaluated.props`);
          g.props = t.mergeEvaluated.props(v, q, g.props, i.Name);
        }
      if (g.items !== !0)
        if (M && !M.dynamicItems)
          M.items !== void 0 && (g.items = t.mergeEvaluated.items(v, M.items, g.items));
        else {
          const q = v.var("items", (0, i._)`${_}.evaluated.items`);
          g.items = t.mergeEvaluated.items(v, q, g.items, i.Name);
        }
    }
  }
  return Ma.callRef = l, Ma.default = s, Ma;
}
var ld;
function Cg() {
  if (ld) return Yr;
  ld = 1, Object.defineProperty(Yr, "__esModule", { value: !0 });
  const e = Pg(), a = Jo(), i = [
    "$schema",
    "$id",
    "$defs",
    "$vocabulary",
    { keyword: "$comment" },
    "definitions",
    e.default,
    a.default
  ];
  return Yr.default = i, Yr;
}
var Zr = {}, Jr = {}, od;
function xg() {
  if (od) return Jr;
  od = 1, Object.defineProperty(Jr, "__esModule", { value: !0 });
  const e = Ie(), a = e.operators, i = {
    maximum: { okStr: "<=", ok: a.LTE, fail: a.GT },
    minimum: { okStr: ">=", ok: a.GTE, fail: a.LT },
    exclusiveMaximum: { okStr: "<", ok: a.LT, fail: a.GTE },
    exclusiveMinimum: { okStr: ">", ok: a.GT, fail: a.LTE }
  }, r = {
    message: ({ keyword: t, schemaCode: s }) => (0, e.str)`must be ${i[t].okStr} ${s}`,
    params: ({ keyword: t, schemaCode: s }) => (0, e._)`{comparison: ${i[t].okStr}, limit: ${s}}`
  }, n = {
    keyword: Object.keys(i),
    type: "number",
    schemaType: "number",
    $data: !0,
    error: r,
    code(t) {
      const { keyword: s, data: o, schemaCode: l } = t;
      t.fail$data((0, e._)`${o} ${i[s].fail} ${l} || isNaN(${o})`);
    }
  };
  return Jr.default = n, Jr;
}
var Qr = {}, ud;
function Vg() {
  if (ud) return Qr;
  ud = 1, Object.defineProperty(Qr, "__esModule", { value: !0 });
  const e = Ie(), i = {
    keyword: "multipleOf",
    type: "number",
    schemaType: "number",
    $data: !0,
    error: {
      message: ({ schemaCode: r }) => (0, e.str)`must be multiple of ${r}`,
      params: ({ schemaCode: r }) => (0, e._)`{multipleOf: ${r}}`
    },
    code(r) {
      const { gen: n, data: t, schemaCode: s, it: o } = r, l = o.opts.multipleOfPrecision, u = n.let("res"), c = l ? (0, e._)`Math.abs(Math.round(${u}) - ${u}) > 1e-${l}` : (0, e._)`${u} !== parseInt(${u})`;
      r.fail$data((0, e._)`(${s} === 0 || (${u} = ${t}/${s}, ${c}))`);
    }
  };
  return Qr.default = i, Qr;
}
var ei = {}, ti = {}, cd;
function Ig() {
  if (cd) return ti;
  cd = 1, Object.defineProperty(ti, "__esModule", { value: !0 });
  function e(a) {
    const i = a.length;
    let r = 0, n = 0, t;
    for (; n < i; )
      r++, t = a.charCodeAt(n++), t >= 55296 && t <= 56319 && n < i && (t = a.charCodeAt(n), (t & 64512) === 56320 && n++);
    return r;
  }
  return ti.default = e, e.code = 'require("ajv/dist/runtime/ucs2length").default', ti;
}
var dd;
function Og() {
  if (dd) return ei;
  dd = 1, Object.defineProperty(ei, "__esModule", { value: !0 });
  const e = Ie(), a = Me(), i = Ig(), n = {
    keyword: ["maxLength", "minLength"],
    type: "string",
    schemaType: "number",
    $data: !0,
    error: {
      message({ keyword: t, schemaCode: s }) {
        const o = t === "maxLength" ? "more" : "fewer";
        return (0, e.str)`must NOT have ${o} than ${s} characters`;
      },
      params: ({ schemaCode: t }) => (0, e._)`{limit: ${t}}`
    },
    code(t) {
      const { keyword: s, data: o, schemaCode: l, it: u } = t, c = s === "maxLength" ? e.operators.GT : e.operators.LT, d = u.opts.unicode === !1 ? (0, e._)`${o}.length` : (0, e._)`${(0, a.useFunc)(t.gen, i.default)}(${o})`;
      t.fail$data((0, e._)`${d} ${c} ${l}`);
    }
  };
  return ei.default = n, ei;
}
var ai = {}, fd;
function Eg() {
  if (fd) return ai;
  fd = 1, Object.defineProperty(ai, "__esModule", { value: !0 });
  const e = ca(), a = Ie(), r = {
    keyword: "pattern",
    type: "string",
    schemaType: "string",
    $data: !0,
    error: {
      message: ({ schemaCode: n }) => (0, a.str)`must match pattern "${n}"`,
      params: ({ schemaCode: n }) => (0, a._)`{pattern: ${n}}`
    },
    code(n) {
      const { data: t, $data: s, schema: o, schemaCode: l, it: u } = n, c = u.opts.unicodeRegExp ? "u" : "", d = s ? (0, a._)`(new RegExp(${l}, ${c}))` : (0, e.usePattern)(n, o);
      n.fail$data((0, a._)`!${d}.test(${t})`);
    }
  };
  return ai.default = r, ai;
}
var ni = {}, md;
function Ag() {
  if (md) return ni;
  md = 1, Object.defineProperty(ni, "__esModule", { value: !0 });
  const e = Ie(), i = {
    keyword: ["maxProperties", "minProperties"],
    type: "object",
    schemaType: "number",
    $data: !0,
    error: {
      message({ keyword: r, schemaCode: n }) {
        const t = r === "maxProperties" ? "more" : "fewer";
        return (0, e.str)`must NOT have ${t} than ${n} properties`;
      },
      params: ({ schemaCode: r }) => (0, e._)`{limit: ${r}}`
    },
    code(r) {
      const { keyword: n, data: t, schemaCode: s } = r, o = n === "maxProperties" ? e.operators.GT : e.operators.LT;
      r.fail$data((0, e._)`Object.keys(${t}).length ${o} ${s}`);
    }
  };
  return ni.default = i, ni;
}
var ri = {}, vd;
function Tg() {
  if (vd) return ri;
  vd = 1, Object.defineProperty(ri, "__esModule", { value: !0 });
  const e = ca(), a = Ie(), i = Me(), n = {
    keyword: "required",
    type: "object",
    schemaType: "array",
    $data: !0,
    error: {
      message: ({ params: { missingProperty: t } }) => (0, a.str)`must have required property '${t}'`,
      params: ({ params: { missingProperty: t } }) => (0, a._)`{missingProperty: ${t}}`
    },
    code(t) {
      const { gen: s, schema: o, schemaCode: l, data: u, $data: c, it: d } = t, { opts: f } = d;
      if (!c && o.length === 0)
        return;
      const v = o.length >= f.loopRequired;
      if (d.allErrors ? g() : h(), f.strictRequired) {
        const p = t.parentSchema.properties, { definedProperties: b } = t.it;
        for (const w of o)
          if (p?.[w] === void 0 && !b.has(w)) {
            const k = d.schemaEnv.baseId + d.errSchemaPath, S = `required property "${w}" is not defined at "${k}" (strictRequired)`;
            (0, i.checkStrictMode)(d, S, d.opts.strictRequired);
          }
      }
      function g() {
        if (v || c)
          t.block$data(a.nil, y);
        else
          for (const p of o)
            (0, e.checkReportMissingProp)(t, p);
      }
      function h() {
        const p = s.let("missing");
        if (v || c) {
          const b = s.let("valid", !0);
          t.block$data(b, () => m(p, b)), t.ok(b);
        } else
          s.if((0, e.checkMissingProp)(t, o, p)), (0, e.reportMissingProp)(t, p), s.else();
      }
      function y() {
        s.forOf("prop", l, (p) => {
          t.setParams({ missingProperty: p }), s.if((0, e.noPropertyInData)(s, u, p, f.ownProperties), () => t.error());
        });
      }
      function m(p, b) {
        t.setParams({ missingProperty: p }), s.forOf(p, l, () => {
          s.assign(b, (0, e.propertyInData)(s, u, p, f.ownProperties)), s.if((0, a.not)(b), () => {
            t.error(), s.break();
          });
        }, a.nil);
      }
    }
  };
  return ri.default = n, ri;
}
var ii = {}, pd;
function jg() {
  if (pd) return ii;
  pd = 1, Object.defineProperty(ii, "__esModule", { value: !0 });
  const e = Ie(), i = {
    keyword: ["maxItems", "minItems"],
    type: "array",
    schemaType: "number",
    $data: !0,
    error: {
      message({ keyword: r, schemaCode: n }) {
        const t = r === "maxItems" ? "more" : "fewer";
        return (0, e.str)`must NOT have ${t} than ${n} items`;
      },
      params: ({ schemaCode: r }) => (0, e._)`{limit: ${r}}`
    },
    code(r) {
      const { keyword: n, data: t, schemaCode: s } = r, o = n === "maxItems" ? e.operators.GT : e.operators.LT;
      r.fail$data((0, e._)`${t}.length ${o} ${s}`);
    }
  };
  return ii.default = i, ii;
}
var si = {}, li = {}, hd;
function Qo() {
  if (hd) return li;
  hd = 1, Object.defineProperty(li, "__esModule", { value: !0 });
  const e = tv();
  return e.code = 'require("ajv/dist/runtime/equal").default', li.default = e, li;
}
var yd;
function Dg() {
  if (yd) return si;
  yd = 1, Object.defineProperty(si, "__esModule", { value: !0 });
  const e = rs(), a = Ie(), i = Me(), r = Qo(), t = {
    keyword: "uniqueItems",
    type: "array",
    schemaType: "boolean",
    $data: !0,
    error: {
      message: ({ params: { i: s, j: o } }) => (0, a.str)`must NOT have duplicate items (items ## ${o} and ${s} are identical)`,
      params: ({ params: { i: s, j: o } }) => (0, a._)`{i: ${s}, j: ${o}}`
    },
    code(s) {
      const { gen: o, data: l, $data: u, schema: c, parentSchema: d, schemaCode: f, it: v } = s;
      if (!u && !c)
        return;
      const g = o.let("valid"), h = d.items ? (0, e.getSchemaTypes)(d.items) : [];
      s.block$data(g, y, (0, a._)`${f} === false`), s.ok(g);
      function y() {
        const w = o.let("i", (0, a._)`${l}.length`), k = o.let("j");
        s.setParams({ i: w, j: k }), o.assign(g, !0), o.if((0, a._)`${w} > 1`, () => (m() ? p : b)(w, k));
      }
      function m() {
        return h.length > 0 && !h.some((w) => w === "object" || w === "array");
      }
      function p(w, k) {
        const S = o.name("item"), _ = (0, e.checkDataTypes)(h, S, v.opts.strictNumbers, e.DataType.Wrong), P = o.const("indices", (0, a._)`{}`);
        o.for((0, a._)`;${w}--;`, () => {
          o.let(S, (0, a._)`${l}[${w}]`), o.if(_, (0, a._)`continue`), h.length > 1 && o.if((0, a._)`typeof ${S} == "string"`, (0, a._)`${S} += "_"`), o.if((0, a._)`typeof ${P}[${S}] == "number"`, () => {
            o.assign(k, (0, a._)`${P}[${S}]`), s.error(), o.assign(g, !1).break();
          }).code((0, a._)`${P}[${S}] = ${w}`);
        });
      }
      function b(w, k) {
        const S = (0, i.useFunc)(o, r.default), _ = o.name("outer");
        o.label(_).for((0, a._)`;${w}--;`, () => o.for((0, a._)`${k} = ${w}; ${k}--;`, () => o.if((0, a._)`${S}(${l}[${w}], ${l}[${k}])`, () => {
          s.error(), o.assign(g, !1).break(_);
        })));
      }
    }
  };
  return si.default = t, si;
}
var oi = {}, gd;
function Mg() {
  if (gd) return oi;
  gd = 1, Object.defineProperty(oi, "__esModule", { value: !0 });
  const e = Ie(), a = Me(), i = Qo(), n = {
    keyword: "const",
    $data: !0,
    error: {
      message: "must be equal to constant",
      params: ({ schemaCode: t }) => (0, e._)`{allowedValue: ${t}}`
    },
    code(t) {
      const { gen: s, data: o, $data: l, schemaCode: u, schema: c } = t;
      l || c && typeof c == "object" ? t.fail$data((0, e._)`!${(0, a.useFunc)(s, i.default)}(${o}, ${u})`) : t.fail((0, e._)`${c} !== ${o}`);
    }
  };
  return oi.default = n, oi;
}
var ui = {}, bd;
function Rg() {
  if (bd) return ui;
  bd = 1, Object.defineProperty(ui, "__esModule", { value: !0 });
  const e = Ie(), a = Me(), i = Qo(), n = {
    keyword: "enum",
    schemaType: "array",
    $data: !0,
    error: {
      message: "must be equal to one of the allowed values",
      params: ({ schemaCode: t }) => (0, e._)`{allowedValues: ${t}}`
    },
    code(t) {
      const { gen: s, data: o, $data: l, schema: u, schemaCode: c, it: d } = t;
      if (!l && u.length === 0)
        throw new Error("enum must have non-empty array");
      const f = u.length >= d.opts.loopEnum;
      let v;
      const g = () => v ?? (v = (0, a.useFunc)(s, i.default));
      let h;
      if (f || l)
        h = s.let("valid"), t.block$data(h, y);
      else {
        if (!Array.isArray(u))
          throw new Error("ajv implementation error");
        const p = s.const("vSchema", c);
        h = (0, e.or)(...u.map((b, w) => m(p, w)));
      }
      t.pass(h);
      function y() {
        s.assign(h, !1), s.forOf("v", c, (p) => s.if((0, e._)`${g()}(${o}, ${p})`, () => s.assign(h, !0).break()));
      }
      function m(p, b) {
        const w = u[b];
        return typeof w == "object" && w !== null ? (0, e._)`${g()}(${o}, ${p}[${b}])` : (0, e._)`${o} === ${w}`;
      }
    }
  };
  return ui.default = n, ui;
}
var kd;
function Ng() {
  if (kd) return Zr;
  kd = 1, Object.defineProperty(Zr, "__esModule", { value: !0 });
  const e = xg(), a = Vg(), i = Og(), r = Eg(), n = Ag(), t = Tg(), s = jg(), o = Dg(), l = Mg(), u = Rg(), c = [
    // number
    e.default,
    a.default,
    // string
    i.default,
    r.default,
    // object
    n.default,
    t.default,
    // array
    s.default,
    o.default,
    // any
    { keyword: "type", schemaType: ["string", "array"] },
    { keyword: "nullable", schemaType: "boolean" },
    l.default,
    u.default
  ];
  return Zr.default = c, Zr;
}
var ci = {}, wn = {}, wd;
function rv() {
  if (wd) return wn;
  wd = 1, Object.defineProperty(wn, "__esModule", { value: !0 }), wn.validateAdditionalItems = void 0;
  const e = Ie(), a = Me(), r = {
    keyword: "additionalItems",
    type: "array",
    schemaType: ["boolean", "object"],
    before: "uniqueItems",
    error: {
      message: ({ params: { len: t } }) => (0, e.str)`must NOT have more than ${t} items`,
      params: ({ params: { len: t } }) => (0, e._)`{limit: ${t}}`
    },
    code(t) {
      const { parentSchema: s, it: o } = t, { items: l } = s;
      if (!Array.isArray(l)) {
        (0, a.checkStrictMode)(o, '"additionalItems" is ignored when "items" is not an array of schemas');
        return;
      }
      n(t, l);
    }
  };
  function n(t, s) {
    const { gen: o, schema: l, data: u, keyword: c, it: d } = t;
    d.items = !0;
    const f = o.const("len", (0, e._)`${u}.length`);
    if (l === !1)
      t.setParams({ len: s.length }), t.pass((0, e._)`${f} <= ${s.length}`);
    else if (typeof l == "object" && !(0, a.alwaysValidSchema)(d, l)) {
      const g = o.var("valid", (0, e._)`${f} <= ${s.length}`);
      o.if((0, e.not)(g), () => v(g)), t.ok(g);
    }
    function v(g) {
      o.forRange("i", s.length, f, (h) => {
        t.subschema({ keyword: c, dataProp: h, dataPropType: a.Type.Num }, g), d.allErrors || o.if((0, e.not)(g), () => o.break());
      });
    }
  }
  return wn.validateAdditionalItems = n, wn.default = r, wn;
}
var di = {}, Sn = {}, Sd;
function iv() {
  if (Sd) return Sn;
  Sd = 1, Object.defineProperty(Sn, "__esModule", { value: !0 }), Sn.validateTuple = void 0;
  const e = Ie(), a = Me(), i = ca(), r = {
    keyword: "items",
    type: "array",
    schemaType: ["object", "array", "boolean"],
    before: "uniqueItems",
    code(t) {
      const { schema: s, it: o } = t;
      if (Array.isArray(s))
        return n(t, "additionalItems", s);
      o.items = !0, !(0, a.alwaysValidSchema)(o, s) && t.ok((0, i.validateArray)(t));
    }
  };
  function n(t, s, o = t.schema) {
    const { gen: l, parentSchema: u, data: c, keyword: d, it: f } = t;
    h(u), f.opts.unevaluated && o.length && f.items !== !0 && (f.items = a.mergeEvaluated.items(l, o.length, f.items));
    const v = l.name("valid"), g = l.const("len", (0, e._)`${c}.length`);
    o.forEach((y, m) => {
      (0, a.alwaysValidSchema)(f, y) || (l.if((0, e._)`${g} > ${m}`, () => t.subschema({
        keyword: d,
        schemaProp: m,
        dataProp: m
      }, v)), t.ok(v));
    });
    function h(y) {
      const { opts: m, errSchemaPath: p } = f, b = o.length, w = b === y.minItems && (b === y.maxItems || y[s] === !1);
      if (m.strictTuples && !w) {
        const k = `"${d}" is ${b}-tuple, but minItems or maxItems/${s} are not specified or different at path "${p}"`;
        (0, a.checkStrictMode)(f, k, m.strictTuples);
      }
    }
  }
  return Sn.validateTuple = n, Sn.default = r, Sn;
}
var $d;
function Lg() {
  if ($d) return di;
  $d = 1, Object.defineProperty(di, "__esModule", { value: !0 });
  const e = iv(), a = {
    keyword: "prefixItems",
    type: "array",
    schemaType: ["array"],
    before: "uniqueItems",
    code: (i) => (0, e.validateTuple)(i, "items")
  };
  return di.default = a, di;
}
var fi = {}, _d;
function qg() {
  if (_d) return fi;
  _d = 1, Object.defineProperty(fi, "__esModule", { value: !0 });
  const e = Ie(), a = Me(), i = ca(), r = rv(), t = {
    keyword: "items",
    type: "array",
    schemaType: ["object", "boolean"],
    before: "uniqueItems",
    error: {
      message: ({ params: { len: s } }) => (0, e.str)`must NOT have more than ${s} items`,
      params: ({ params: { len: s } }) => (0, e._)`{limit: ${s}}`
    },
    code(s) {
      const { schema: o, parentSchema: l, it: u } = s, { prefixItems: c } = l;
      u.items = !0, !(0, a.alwaysValidSchema)(u, o) && (c ? (0, r.validateAdditionalItems)(s, c) : s.ok((0, i.validateArray)(s)));
    }
  };
  return fi.default = t, fi;
}
var mi = {}, Pd;
function zg() {
  if (Pd) return mi;
  Pd = 1, Object.defineProperty(mi, "__esModule", { value: !0 });
  const e = Ie(), a = Me(), r = {
    keyword: "contains",
    type: "array",
    schemaType: ["object", "boolean"],
    before: "uniqueItems",
    trackErrors: !0,
    error: {
      message: ({ params: { min: n, max: t } }) => t === void 0 ? (0, e.str)`must contain at least ${n} valid item(s)` : (0, e.str)`must contain at least ${n} and no more than ${t} valid item(s)`,
      params: ({ params: { min: n, max: t } }) => t === void 0 ? (0, e._)`{minContains: ${n}}` : (0, e._)`{minContains: ${n}, maxContains: ${t}}`
    },
    code(n) {
      const { gen: t, schema: s, parentSchema: o, data: l, it: u } = n;
      let c, d;
      const { minContains: f, maxContains: v } = o;
      u.opts.next ? (c = f === void 0 ? 1 : f, d = v) : c = 1;
      const g = t.const("len", (0, e._)`${l}.length`);
      if (n.setParams({ min: c, max: d }), d === void 0 && c === 0) {
        (0, a.checkStrictMode)(u, '"minContains" == 0 without "maxContains": "contains" keyword ignored');
        return;
      }
      if (d !== void 0 && c > d) {
        (0, a.checkStrictMode)(u, '"minContains" > "maxContains" is always invalid'), n.fail();
        return;
      }
      if ((0, a.alwaysValidSchema)(u, s)) {
        let b = (0, e._)`${g} >= ${c}`;
        d !== void 0 && (b = (0, e._)`${b} && ${g} <= ${d}`), n.pass(b);
        return;
      }
      u.items = !0;
      const h = t.name("valid");
      d === void 0 && c === 1 ? m(h, () => t.if(h, () => t.break())) : c === 0 ? (t.let(h, !0), d !== void 0 && t.if((0, e._)`${l}.length > 0`, y)) : (t.let(h, !1), y()), n.result(h, () => n.reset());
      function y() {
        const b = t.name("_valid"), w = t.let("count", 0);
        m(b, () => t.if(b, () => p(w)));
      }
      function m(b, w) {
        t.forRange("i", 0, g, (k) => {
          n.subschema({
            keyword: "contains",
            dataProp: k,
            dataPropType: a.Type.Num,
            compositeRule: !0
          }, b), w();
        });
      }
      function p(b) {
        t.code((0, e._)`${b}++`), d === void 0 ? t.if((0, e._)`${b} >= ${c}`, () => t.assign(h, !0).break()) : (t.if((0, e._)`${b} > ${d}`, () => t.assign(h, !1).break()), c === 1 ? t.assign(h, !0) : t.if((0, e._)`${b} >= ${c}`, () => t.assign(h, !0)));
      }
    }
  };
  return mi.default = r, mi;
}
var jl = {}, Cd;
function eu() {
  return Cd || (Cd = 1, (function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.validateSchemaDeps = e.validatePropertyDeps = e.error = void 0;
    const a = Ie(), i = Me(), r = ca();
    e.error = {
      message: ({ params: { property: l, depsCount: u, deps: c } }) => {
        const d = u === 1 ? "property" : "properties";
        return (0, a.str)`must have ${d} ${c} when property ${l} is present`;
      },
      params: ({ params: { property: l, depsCount: u, deps: c, missingProperty: d } }) => (0, a._)`{property: ${l},
    missingProperty: ${d},
    depsCount: ${u},
    deps: ${c}}`
      // TODO change to reference
    };
    const n = {
      keyword: "dependencies",
      type: "object",
      schemaType: "object",
      error: e.error,
      code(l) {
        const [u, c] = t(l);
        s(l, u), o(l, c);
      }
    };
    function t({ schema: l }) {
      const u = {}, c = {};
      for (const d in l) {
        if (d === "__proto__")
          continue;
        const f = Array.isArray(l[d]) ? u : c;
        f[d] = l[d];
      }
      return [u, c];
    }
    function s(l, u = l.schema) {
      const { gen: c, data: d, it: f } = l;
      if (Object.keys(u).length === 0)
        return;
      const v = c.let("missing");
      for (const g in u) {
        const h = u[g];
        if (h.length === 0)
          continue;
        const y = (0, r.propertyInData)(c, d, g, f.opts.ownProperties);
        l.setParams({
          property: g,
          depsCount: h.length,
          deps: h.join(", ")
        }), f.allErrors ? c.if(y, () => {
          for (const m of h)
            (0, r.checkReportMissingProp)(l, m);
        }) : (c.if((0, a._)`${y} && (${(0, r.checkMissingProp)(l, h, v)})`), (0, r.reportMissingProp)(l, v), c.else());
      }
    }
    e.validatePropertyDeps = s;
    function o(l, u = l.schema) {
      const { gen: c, data: d, keyword: f, it: v } = l, g = c.name("valid");
      for (const h in u)
        (0, i.alwaysValidSchema)(v, u[h]) || (c.if(
          (0, r.propertyInData)(c, d, h, v.opts.ownProperties),
          () => {
            const y = l.subschema({ keyword: f, schemaProp: h }, g);
            l.mergeValidEvaluated(y, g);
          },
          () => c.var(g, !0)
          // TODO var
        ), l.ok(g));
    }
    e.validateSchemaDeps = o, e.default = n;
  })(jl)), jl;
}
var vi = {}, xd;
function Bg() {
  if (xd) return vi;
  xd = 1, Object.defineProperty(vi, "__esModule", { value: !0 });
  const e = Ie(), a = Me(), r = {
    keyword: "propertyNames",
    type: "object",
    schemaType: ["object", "boolean"],
    error: {
      message: "property name must be valid",
      params: ({ params: n }) => (0, e._)`{propertyName: ${n.propertyName}}`
    },
    code(n) {
      const { gen: t, schema: s, data: o, it: l } = n;
      if ((0, a.alwaysValidSchema)(l, s))
        return;
      const u = t.name("valid");
      t.forIn("key", o, (c) => {
        n.setParams({ propertyName: c }), n.subschema({
          keyword: "propertyNames",
          data: c,
          dataTypes: ["string"],
          propertyName: c,
          compositeRule: !0
        }, u), t.if((0, e.not)(u), () => {
          n.error(!0), l.allErrors || t.break();
        });
      }), n.ok(u);
    }
  };
  return vi.default = r, vi;
}
var pi = {}, Vd;
function sv() {
  if (Vd) return pi;
  Vd = 1, Object.defineProperty(pi, "__esModule", { value: !0 });
  const e = ca(), a = Ie(), i = Zt(), r = Me(), t = {
    keyword: "additionalProperties",
    type: ["object"],
    schemaType: ["boolean", "object"],
    allowUndefined: !0,
    trackErrors: !0,
    error: {
      message: "must NOT have additional properties",
      params: ({ params: s }) => (0, a._)`{additionalProperty: ${s.additionalProperty}}`
    },
    code(s) {
      const { gen: o, schema: l, parentSchema: u, data: c, errsCount: d, it: f } = s;
      if (!d)
        throw new Error("ajv implementation error");
      const { allErrors: v, opts: g } = f;
      if (f.props = !0, g.removeAdditional !== "all" && (0, r.alwaysValidSchema)(f, l))
        return;
      const h = (0, e.allSchemaProperties)(u.properties), y = (0, e.allSchemaProperties)(u.patternProperties);
      m(), s.ok((0, a._)`${d} === ${i.default.errors}`);
      function m() {
        o.forIn("key", c, (S) => {
          !h.length && !y.length ? w(S) : o.if(p(S), () => w(S));
        });
      }
      function p(S) {
        let _;
        if (h.length > 8) {
          const P = (0, r.schemaRefOrVal)(f, u.properties, "properties");
          _ = (0, e.isOwnProperty)(o, P, S);
        } else h.length ? _ = (0, a.or)(...h.map((P) => (0, a._)`${S} === ${P}`)) : _ = a.nil;
        return y.length && (_ = (0, a.or)(_, ...y.map((P) => (0, a._)`${(0, e.usePattern)(s, P)}.test(${S})`))), (0, a.not)(_);
      }
      function b(S) {
        o.code((0, a._)`delete ${c}[${S}]`);
      }
      function w(S) {
        if (g.removeAdditional === "all" || g.removeAdditional && l === !1) {
          b(S);
          return;
        }
        if (l === !1) {
          s.setParams({ additionalProperty: S }), s.error(), v || o.break();
          return;
        }
        if (typeof l == "object" && !(0, r.alwaysValidSchema)(f, l)) {
          const _ = o.name("valid");
          g.removeAdditional === "failing" ? (k(S, _, !1), o.if((0, a.not)(_), () => {
            s.reset(), b(S);
          })) : (k(S, _), v || o.if((0, a.not)(_), () => o.break()));
        }
      }
      function k(S, _, P) {
        const M = {
          keyword: "additionalProperties",
          dataProp: S,
          dataPropType: r.Type.Str
        };
        P === !1 && Object.assign(M, {
          compositeRule: !0,
          createErrors: !1,
          allErrors: !1
        }), s.subschema(M, _);
      }
    }
  };
  return pi.default = t, pi;
}
var hi = {}, Id;
function Fg() {
  if (Id) return hi;
  Id = 1, Object.defineProperty(hi, "__esModule", { value: !0 });
  const e = zn(), a = ca(), i = Me(), r = sv(), n = {
    keyword: "properties",
    type: "object",
    schemaType: "object",
    code(t) {
      const { gen: s, schema: o, parentSchema: l, data: u, it: c } = t;
      c.opts.removeAdditional === "all" && l.additionalProperties === void 0 && r.default.code(new e.KeywordCxt(c, r.default, "additionalProperties"));
      const d = (0, a.allSchemaProperties)(o);
      for (const y of d)
        c.definedProperties.add(y);
      c.opts.unevaluated && d.length && c.props !== !0 && (c.props = i.mergeEvaluated.props(s, (0, i.toHash)(d), c.props));
      const f = d.filter((y) => !(0, i.alwaysValidSchema)(c, o[y]));
      if (f.length === 0)
        return;
      const v = s.name("valid");
      for (const y of f)
        g(y) ? h(y) : (s.if((0, a.propertyInData)(s, u, y, c.opts.ownProperties)), h(y), c.allErrors || s.else().var(v, !0), s.endIf()), t.it.definedProperties.add(y), t.ok(v);
      function g(y) {
        return c.opts.useDefaults && !c.compositeRule && o[y].default !== void 0;
      }
      function h(y) {
        t.subschema({
          keyword: "properties",
          schemaProp: y,
          dataProp: y
        }, v);
      }
    }
  };
  return hi.default = n, hi;
}
var yi = {}, Od;
function Kg() {
  if (Od) return yi;
  Od = 1, Object.defineProperty(yi, "__esModule", { value: !0 });
  const e = ca(), a = Ie(), i = Me(), r = Me(), n = {
    keyword: "patternProperties",
    type: "object",
    schemaType: "object",
    code(t) {
      const { gen: s, schema: o, data: l, parentSchema: u, it: c } = t, { opts: d } = c, f = (0, e.allSchemaProperties)(o), v = f.filter((w) => (0, i.alwaysValidSchema)(c, o[w]));
      if (f.length === 0 || v.length === f.length && (!c.opts.unevaluated || c.props === !0))
        return;
      const g = d.strictSchema && !d.allowMatchingProperties && u.properties, h = s.name("valid");
      c.props !== !0 && !(c.props instanceof a.Name) && (c.props = (0, r.evaluatedPropsToName)(s, c.props));
      const { props: y } = c;
      m();
      function m() {
        for (const w of f)
          g && p(w), c.allErrors ? b(w) : (s.var(h, !0), b(w), s.if(h));
      }
      function p(w) {
        for (const k in g)
          new RegExp(w).test(k) && (0, i.checkStrictMode)(c, `property ${k} matches pattern ${w} (use allowMatchingProperties)`);
      }
      function b(w) {
        s.forIn("key", l, (k) => {
          s.if((0, a._)`${(0, e.usePattern)(t, w)}.test(${k})`, () => {
            const S = v.includes(w);
            S || t.subschema({
              keyword: "patternProperties",
              schemaProp: w,
              dataProp: k,
              dataPropType: r.Type.Str
            }, h), c.opts.unevaluated && y !== !0 ? s.assign((0, a._)`${y}[${k}]`, !0) : !S && !c.allErrors && s.if((0, a.not)(h), () => s.break());
          });
        });
      }
    }
  };
  return yi.default = n, yi;
}
var gi = {}, Ed;
function Hg() {
  if (Ed) return gi;
  Ed = 1, Object.defineProperty(gi, "__esModule", { value: !0 });
  const e = Me(), a = {
    keyword: "not",
    schemaType: ["object", "boolean"],
    trackErrors: !0,
    code(i) {
      const { gen: r, schema: n, it: t } = i;
      if ((0, e.alwaysValidSchema)(t, n)) {
        i.fail();
        return;
      }
      const s = r.name("valid");
      i.subschema({
        keyword: "not",
        compositeRule: !0,
        createErrors: !1,
        allErrors: !1
      }, s), i.failResult(s, () => i.reset(), () => i.error());
    },
    error: { message: "must NOT be valid" }
  };
  return gi.default = a, gi;
}
var bi = {}, Ad;
function Ug() {
  if (Ad) return bi;
  Ad = 1, Object.defineProperty(bi, "__esModule", { value: !0 });
  const a = {
    keyword: "anyOf",
    schemaType: "array",
    trackErrors: !0,
    code: ca().validateUnion,
    error: { message: "must match a schema in anyOf" }
  };
  return bi.default = a, bi;
}
var ki = {}, Td;
function Wg() {
  if (Td) return ki;
  Td = 1, Object.defineProperty(ki, "__esModule", { value: !0 });
  const e = Ie(), a = Me(), r = {
    keyword: "oneOf",
    schemaType: "array",
    trackErrors: !0,
    error: {
      message: "must match exactly one schema in oneOf",
      params: ({ params: n }) => (0, e._)`{passingSchemas: ${n.passing}}`
    },
    code(n) {
      const { gen: t, schema: s, parentSchema: o, it: l } = n;
      if (!Array.isArray(s))
        throw new Error("ajv implementation error");
      if (l.opts.discriminator && o.discriminator)
        return;
      const u = s, c = t.let("valid", !1), d = t.let("passing", null), f = t.name("_valid");
      n.setParams({ passing: d }), t.block(v), n.result(c, () => n.reset(), () => n.error(!0));
      function v() {
        u.forEach((g, h) => {
          let y;
          (0, a.alwaysValidSchema)(l, g) ? t.var(f, !0) : y = n.subschema({
            keyword: "oneOf",
            schemaProp: h,
            compositeRule: !0
          }, f), h > 0 && t.if((0, e._)`${f} && ${c}`).assign(c, !1).assign(d, (0, e._)`[${d}, ${h}]`).else(), t.if(f, () => {
            t.assign(c, !0), t.assign(d, h), y && n.mergeEvaluated(y, e.Name);
          });
        });
      }
    }
  };
  return ki.default = r, ki;
}
var wi = {}, jd;
function Gg() {
  if (jd) return wi;
  jd = 1, Object.defineProperty(wi, "__esModule", { value: !0 });
  const e = Me(), a = {
    keyword: "allOf",
    schemaType: "array",
    code(i) {
      const { gen: r, schema: n, it: t } = i;
      if (!Array.isArray(n))
        throw new Error("ajv implementation error");
      const s = r.name("valid");
      n.forEach((o, l) => {
        if ((0, e.alwaysValidSchema)(t, o))
          return;
        const u = i.subschema({ keyword: "allOf", schemaProp: l }, s);
        i.ok(s), i.mergeEvaluated(u);
      });
    }
  };
  return wi.default = a, wi;
}
var Si = {}, Dd;
function Yg() {
  if (Dd) return Si;
  Dd = 1, Object.defineProperty(Si, "__esModule", { value: !0 });
  const e = Ie(), a = Me(), r = {
    keyword: "if",
    schemaType: ["object", "boolean"],
    trackErrors: !0,
    error: {
      message: ({ params: t }) => (0, e.str)`must match "${t.ifClause}" schema`,
      params: ({ params: t }) => (0, e._)`{failingKeyword: ${t.ifClause}}`
    },
    code(t) {
      const { gen: s, parentSchema: o, it: l } = t;
      o.then === void 0 && o.else === void 0 && (0, a.checkStrictMode)(l, '"if" without "then" and "else" is ignored');
      const u = n(l, "then"), c = n(l, "else");
      if (!u && !c)
        return;
      const d = s.let("valid", !0), f = s.name("_valid");
      if (v(), t.reset(), u && c) {
        const h = s.let("ifClause");
        t.setParams({ ifClause: h }), s.if(f, g("then", h), g("else", h));
      } else u ? s.if(f, g("then")) : s.if((0, e.not)(f), g("else"));
      t.pass(d, () => t.error(!0));
      function v() {
        const h = t.subschema({
          keyword: "if",
          compositeRule: !0,
          createErrors: !1,
          allErrors: !1
        }, f);
        t.mergeEvaluated(h);
      }
      function g(h, y) {
        return () => {
          const m = t.subschema({ keyword: h }, f);
          s.assign(d, f), t.mergeValidEvaluated(m, d), y ? s.assign(y, (0, e._)`${h}`) : t.setParams({ ifClause: h });
        };
      }
    }
  };
  function n(t, s) {
    const o = t.schema[s];
    return o !== void 0 && !(0, a.alwaysValidSchema)(t, o);
  }
  return Si.default = r, Si;
}
var $i = {}, Md;
function Xg() {
  if (Md) return $i;
  Md = 1, Object.defineProperty($i, "__esModule", { value: !0 });
  const e = Me(), a = {
    keyword: ["then", "else"],
    schemaType: ["object", "boolean"],
    code({ keyword: i, parentSchema: r, it: n }) {
      r.if === void 0 && (0, e.checkStrictMode)(n, `"${i}" without "if" is ignored`);
    }
  };
  return $i.default = a, $i;
}
var Rd;
function Zg() {
  if (Rd) return ci;
  Rd = 1, Object.defineProperty(ci, "__esModule", { value: !0 });
  const e = rv(), a = Lg(), i = iv(), r = qg(), n = zg(), t = eu(), s = Bg(), o = sv(), l = Fg(), u = Kg(), c = Hg(), d = Ug(), f = Wg(), v = Gg(), g = Yg(), h = Xg();
  function y(m = !1) {
    const p = [
      // any
      c.default,
      d.default,
      f.default,
      v.default,
      g.default,
      h.default,
      // object
      s.default,
      o.default,
      t.default,
      l.default,
      u.default
    ];
    return m ? p.push(a.default, r.default) : p.push(e.default, i.default), p.push(n.default), p;
  }
  return ci.default = y, ci;
}
var _i = {}, Pi = {}, Nd;
function Jg() {
  if (Nd) return Pi;
  Nd = 1, Object.defineProperty(Pi, "__esModule", { value: !0 });
  const e = Ie(), i = {
    keyword: "format",
    type: ["number", "string"],
    schemaType: "string",
    $data: !0,
    error: {
      message: ({ schemaCode: r }) => (0, e.str)`must match format "${r}"`,
      params: ({ schemaCode: r }) => (0, e._)`{format: ${r}}`
    },
    code(r, n) {
      const { gen: t, data: s, $data: o, schema: l, schemaCode: u, it: c } = r, { opts: d, errSchemaPath: f, schemaEnv: v, self: g } = c;
      if (!d.validateFormats)
        return;
      o ? h() : y();
      function h() {
        const m = t.scopeValue("formats", {
          ref: g.formats,
          code: d.code.formats
        }), p = t.const("fDef", (0, e._)`${m}[${u}]`), b = t.let("fType"), w = t.let("format");
        t.if((0, e._)`typeof ${p} == "object" && !(${p} instanceof RegExp)`, () => t.assign(b, (0, e._)`${p}.type || "string"`).assign(w, (0, e._)`${p}.validate`), () => t.assign(b, (0, e._)`"string"`).assign(w, p)), r.fail$data((0, e.or)(k(), S()));
        function k() {
          return d.strictSchema === !1 ? e.nil : (0, e._)`${u} && !${w}`;
        }
        function S() {
          const _ = v.$async ? (0, e._)`(${p}.async ? await ${w}(${s}) : ${w}(${s}))` : (0, e._)`${w}(${s})`, P = (0, e._)`(typeof ${w} == "function" ? ${_} : ${w}.test(${s}))`;
          return (0, e._)`${w} && ${w} !== true && ${b} === ${n} && !${P}`;
        }
      }
      function y() {
        const m = g.formats[l];
        if (!m) {
          k();
          return;
        }
        if (m === !0)
          return;
        const [p, b, w] = S(m);
        p === n && r.pass(_());
        function k() {
          if (d.strictSchema === !1) {
            g.logger.warn(P());
            return;
          }
          throw new Error(P());
          function P() {
            return `unknown format "${l}" ignored in schema at path "${f}"`;
          }
        }
        function S(P) {
          const M = P instanceof RegExp ? (0, e.regexpCode)(P) : d.code.formats ? (0, e._)`${d.code.formats}${(0, e.getProperty)(l)}` : void 0, q = t.scopeValue("formats", { key: l, ref: P, code: M });
          return typeof P == "object" && !(P instanceof RegExp) ? [P.type || "string", P.validate, (0, e._)`${q}.validate`] : ["string", P, q];
        }
        function _() {
          if (typeof m == "object" && !(m instanceof RegExp) && m.async) {
            if (!v.$async)
              throw new Error("async format in sync schema");
            return (0, e._)`await ${w}(${s})`;
          }
          return typeof b == "function" ? (0, e._)`${w}(${s})` : (0, e._)`${w}.test(${s})`;
        }
      }
    }
  };
  return Pi.default = i, Pi;
}
var Ld;
function Qg() {
  if (Ld) return _i;
  Ld = 1, Object.defineProperty(_i, "__esModule", { value: !0 });
  const a = [Jg().default];
  return _i.default = a, _i;
}
var Wa = {}, qd;
function eb() {
  return qd || (qd = 1, Object.defineProperty(Wa, "__esModule", { value: !0 }), Wa.contentVocabulary = Wa.metadataVocabulary = void 0, Wa.metadataVocabulary = [
    "title",
    "description",
    "default",
    "deprecated",
    "readOnly",
    "writeOnly",
    "examples"
  ], Wa.contentVocabulary = [
    "contentMediaType",
    "contentEncoding",
    "contentSchema"
  ]), Wa;
}
var zd;
function lv() {
  if (zd) return Gr;
  zd = 1, Object.defineProperty(Gr, "__esModule", { value: !0 });
  const e = Cg(), a = Ng(), i = Zg(), r = Qg(), n = eb(), t = [
    e.default,
    a.default,
    (0, i.default)(),
    r.default,
    n.metadataVocabulary,
    n.contentVocabulary
  ];
  return Gr.default = t, Gr;
}
var Ci = {}, $n = {}, Bd;
function ov() {
  if (Bd) return $n;
  Bd = 1, Object.defineProperty($n, "__esModule", { value: !0 }), $n.dynamicAnchor = void 0;
  const e = Ie(), a = Zt(), i = Os(), r = Jo(), n = {
    keyword: "$dynamicAnchor",
    schemaType: "string",
    code: (o) => t(o, o.schema)
  };
  function t(o, l) {
    const { gen: u, it: c } = o;
    c.schemaEnv.root.dynamicAnchors[l] = !0;
    const d = (0, e._)`${a.default.dynamicAnchors}${(0, e.getProperty)(l)}`, f = c.errSchemaPath === "#" ? c.validateName : s(o);
    u.if((0, e._)`!${d}`, () => u.assign(d, f));
  }
  $n.dynamicAnchor = t;
  function s(o) {
    const { schemaEnv: l, schema: u, self: c } = o.it, { root: d, baseId: f, localRefs: v, meta: g } = l.root, { schemaId: h } = c.opts, y = new i.SchemaEnv({ schema: u, schemaId: h, root: d, baseId: f, localRefs: v, meta: g });
    return i.compileSchema.call(c, y), (0, r.getValidate)(o, y);
  }
  return $n.default = n, $n;
}
var _n = {}, Fd;
function uv() {
  if (Fd) return _n;
  Fd = 1, Object.defineProperty(_n, "__esModule", { value: !0 }), _n.dynamicRef = void 0;
  const e = Ie(), a = Zt(), i = Jo(), r = {
    keyword: "$dynamicRef",
    schemaType: "string",
    code: (t) => n(t, t.schema)
  };
  function n(t, s) {
    const { gen: o, keyword: l, it: u } = t;
    if (s[0] !== "#")
      throw new Error(`"${l}" only supports hash fragment reference`);
    const c = s.slice(1);
    if (u.allErrors)
      d();
    else {
      const v = o.let("valid", !1);
      d(v), t.ok(v);
    }
    function d(v) {
      if (u.schemaEnv.root.dynamicAnchors[c]) {
        const g = o.let("_v", (0, e._)`${a.default.dynamicAnchors}${(0, e.getProperty)(c)}`);
        o.if(g, f(g, v), f(u.validateName, v));
      } else
        f(u.validateName, v)();
    }
    function f(v, g) {
      return g ? () => o.block(() => {
        (0, i.callRef)(t, v), o.let(g, !0);
      }) : () => (0, i.callRef)(t, v);
    }
  }
  return _n.dynamicRef = n, _n.default = r, _n;
}
var xi = {}, Kd;
function tb() {
  if (Kd) return xi;
  Kd = 1, Object.defineProperty(xi, "__esModule", { value: !0 });
  const e = ov(), a = Me(), i = {
    keyword: "$recursiveAnchor",
    schemaType: "boolean",
    code(r) {
      r.schema ? (0, e.dynamicAnchor)(r, "") : (0, a.checkStrictMode)(r.it, "$recursiveAnchor: false is ignored");
    }
  };
  return xi.default = i, xi;
}
var Vi = {}, Hd;
function ab() {
  if (Hd) return Vi;
  Hd = 1, Object.defineProperty(Vi, "__esModule", { value: !0 });
  const e = uv(), a = {
    keyword: "$recursiveRef",
    schemaType: "string",
    code: (i) => (0, e.dynamicRef)(i, i.schema)
  };
  return Vi.default = a, Vi;
}
var Ud;
function nb() {
  if (Ud) return Ci;
  Ud = 1, Object.defineProperty(Ci, "__esModule", { value: !0 });
  const e = ov(), a = uv(), i = tb(), r = ab(), n = [e.default, a.default, i.default, r.default];
  return Ci.default = n, Ci;
}
var Ii = {}, Oi = {}, Wd;
function rb() {
  if (Wd) return Oi;
  Wd = 1, Object.defineProperty(Oi, "__esModule", { value: !0 });
  const e = eu(), a = {
    keyword: "dependentRequired",
    type: "object",
    schemaType: "object",
    error: e.error,
    code: (i) => (0, e.validatePropertyDeps)(i)
  };
  return Oi.default = a, Oi;
}
var Ei = {}, Gd;
function ib() {
  if (Gd) return Ei;
  Gd = 1, Object.defineProperty(Ei, "__esModule", { value: !0 });
  const e = eu(), a = {
    keyword: "dependentSchemas",
    type: "object",
    schemaType: "object",
    code: (i) => (0, e.validateSchemaDeps)(i)
  };
  return Ei.default = a, Ei;
}
var Ai = {}, Yd;
function sb() {
  if (Yd) return Ai;
  Yd = 1, Object.defineProperty(Ai, "__esModule", { value: !0 });
  const e = Me(), a = {
    keyword: ["maxContains", "minContains"],
    type: "array",
    schemaType: "number",
    code({ keyword: i, parentSchema: r, it: n }) {
      r.contains === void 0 && (0, e.checkStrictMode)(n, `"${i}" without "contains" is ignored`);
    }
  };
  return Ai.default = a, Ai;
}
var Xd;
function lb() {
  if (Xd) return Ii;
  Xd = 1, Object.defineProperty(Ii, "__esModule", { value: !0 });
  const e = rb(), a = ib(), i = sb(), r = [e.default, a.default, i.default];
  return Ii.default = r, Ii;
}
var Ti = {}, ji = {}, Zd;
function ob() {
  if (Zd) return ji;
  Zd = 1, Object.defineProperty(ji, "__esModule", { value: !0 });
  const e = Ie(), a = Me(), i = Zt(), n = {
    keyword: "unevaluatedProperties",
    type: "object",
    schemaType: ["boolean", "object"],
    trackErrors: !0,
    error: {
      message: "must NOT have unevaluated properties",
      params: ({ params: t }) => (0, e._)`{unevaluatedProperty: ${t.unevaluatedProperty}}`
    },
    code(t) {
      const { gen: s, schema: o, data: l, errsCount: u, it: c } = t;
      if (!u)
        throw new Error("ajv implementation error");
      const { allErrors: d, props: f } = c;
      f instanceof e.Name ? s.if((0, e._)`${f} !== true`, () => s.forIn("key", l, (y) => s.if(g(f, y), () => v(y)))) : f !== !0 && s.forIn("key", l, (y) => f === void 0 ? v(y) : s.if(h(f, y), () => v(y))), c.props = !0, t.ok((0, e._)`${u} === ${i.default.errors}`);
      function v(y) {
        if (o === !1) {
          t.setParams({ unevaluatedProperty: y }), t.error(), d || s.break();
          return;
        }
        if (!(0, a.alwaysValidSchema)(c, o)) {
          const m = s.name("valid");
          t.subschema({
            keyword: "unevaluatedProperties",
            dataProp: y,
            dataPropType: a.Type.Str
          }, m), d || s.if((0, e.not)(m), () => s.break());
        }
      }
      function g(y, m) {
        return (0, e._)`!${y} || !${y}[${m}]`;
      }
      function h(y, m) {
        const p = [];
        for (const b in y)
          y[b] === !0 && p.push((0, e._)`${m} !== ${b}`);
        return (0, e.and)(...p);
      }
    }
  };
  return ji.default = n, ji;
}
var Di = {}, Jd;
function ub() {
  if (Jd) return Di;
  Jd = 1, Object.defineProperty(Di, "__esModule", { value: !0 });
  const e = Ie(), a = Me(), r = {
    keyword: "unevaluatedItems",
    type: "array",
    schemaType: ["boolean", "object"],
    error: {
      message: ({ params: { len: n } }) => (0, e.str)`must NOT have more than ${n} items`,
      params: ({ params: { len: n } }) => (0, e._)`{limit: ${n}}`
    },
    code(n) {
      const { gen: t, schema: s, data: o, it: l } = n, u = l.items || 0;
      if (u === !0)
        return;
      const c = t.const("len", (0, e._)`${o}.length`);
      if (s === !1)
        n.setParams({ len: u }), n.fail((0, e._)`${c} > ${u}`);
      else if (typeof s == "object" && !(0, a.alwaysValidSchema)(l, s)) {
        const f = t.var("valid", (0, e._)`${c} <= ${u}`);
        t.if((0, e.not)(f), () => d(f, u)), n.ok(f);
      }
      l.items = !0;
      function d(f, v) {
        t.forRange("i", v, c, (g) => {
          n.subschema({ keyword: "unevaluatedItems", dataProp: g, dataPropType: a.Type.Num }, f), l.allErrors || t.if((0, e.not)(f), () => t.break());
        });
      }
    }
  };
  return Di.default = r, Di;
}
var Qd;
function cb() {
  if (Qd) return Ti;
  Qd = 1, Object.defineProperty(Ti, "__esModule", { value: !0 });
  const e = ob(), a = ub(), i = [e.default, a.default];
  return Ti.default = i, Ti;
}
var Mi = {}, er = {}, ef;
function db() {
  if (ef) return er;
  ef = 1, Object.defineProperty(er, "__esModule", { value: !0 }), er.DiscrError = void 0;
  var e;
  return (function(a) {
    a.Tag = "tag", a.Mapping = "mapping";
  })(e || (er.DiscrError = e = {})), er;
}
var tf;
function cv() {
  if (tf) return Mi;
  tf = 1, Object.defineProperty(Mi, "__esModule", { value: !0 });
  const e = Ie(), a = db(), i = Os(), r = Ir(), n = Me(), s = {
    keyword: "discriminator",
    type: "object",
    schemaType: "object",
    error: {
      message: ({ params: { discrError: o, tagName: l } }) => o === a.DiscrError.Tag ? `tag "${l}" must be string` : `value of tag "${l}" must be in oneOf`,
      params: ({ params: { discrError: o, tag: l, tagName: u } }) => (0, e._)`{error: ${o}, tag: ${u}, tagValue: ${l}}`
    },
    code(o) {
      const { gen: l, data: u, schema: c, parentSchema: d, it: f } = o, { oneOf: v } = d;
      if (!f.opts.discriminator)
        throw new Error("discriminator: requires discriminator option");
      const g = c.propertyName;
      if (typeof g != "string")
        throw new Error("discriminator: requires propertyName");
      if (c.mapping)
        throw new Error("discriminator: mapping is not supported");
      if (!v)
        throw new Error("discriminator: requires oneOf keyword");
      const h = l.let("valid", !1), y = l.const("tag", (0, e._)`${u}${(0, e.getProperty)(g)}`);
      l.if((0, e._)`typeof ${y} == "string"`, () => m(), () => o.error(!1, { discrError: a.DiscrError.Tag, tag: y, tagName: g })), o.ok(h);
      function m() {
        const w = b();
        l.if(!1);
        for (const k in w)
          l.elseIf((0, e._)`${y} === ${k}`), l.assign(h, p(w[k]));
        l.else(), o.error(!1, { discrError: a.DiscrError.Mapping, tag: y, tagName: g }), l.endIf();
      }
      function p(w) {
        const k = l.name("valid"), S = o.subschema({ keyword: "oneOf", schemaProp: w }, k);
        return o.mergeEvaluated(S, e.Name), k;
      }
      function b() {
        var w;
        const k = {}, S = P(d);
        let _ = !0;
        for (let K = 0; K < v.length; K++) {
          let j = v[K];
          if (j?.$ref && !(0, n.schemaHasRulesButRef)(j, f.self.RULES)) {
            const B = j.$ref;
            if (j = i.resolveRef.call(f.self, f.schemaEnv.root, f.baseId, B), j instanceof i.SchemaEnv && (j = j.schema), j === void 0)
              throw new r.default(f.opts.uriResolver, f.baseId, B);
          }
          const H = (w = j?.properties) === null || w === void 0 ? void 0 : w[g];
          if (typeof H != "object")
            throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${g}"`);
          _ = _ && (S || P(j)), M(H, K);
        }
        if (!_)
          throw new Error(`discriminator: "${g}" must be required`);
        return k;
        function P({ required: K }) {
          return Array.isArray(K) && K.includes(g);
        }
        function M(K, j) {
          if (K.const)
            q(K.const, j);
          else if (K.enum)
            for (const H of K.enum)
              q(H, j);
          else
            throw new Error(`discriminator: "properties/${g}" must have "const" or "enum"`);
        }
        function q(K, j) {
          if (typeof K != "string" || K in k)
            throw new Error(`discriminator: "${g}" values must be unique strings`);
          k[K] = j;
        }
      }
    }
  };
  return Mi.default = s, Mi;
}
var Ri = {};
const fb = "https://json-schema.org/draft/2019-09/schema", mb = "https://json-schema.org/draft/2019-09/schema", vb = { "https://json-schema.org/draft/2019-09/vocab/core": !0, "https://json-schema.org/draft/2019-09/vocab/applicator": !0, "https://json-schema.org/draft/2019-09/vocab/validation": !0, "https://json-schema.org/draft/2019-09/vocab/meta-data": !0, "https://json-schema.org/draft/2019-09/vocab/format": !1, "https://json-schema.org/draft/2019-09/vocab/content": !0 }, pb = !0, hb = "Core and Validation specifications meta-schema", yb = [{ $ref: "meta/core" }, { $ref: "meta/applicator" }, { $ref: "meta/validation" }, { $ref: "meta/meta-data" }, { $ref: "meta/format" }, { $ref: "meta/content" }], gb = ["object", "boolean"], bb = { definitions: { $comment: "While no longer an official keyword as it is replaced by $defs, this keyword is retained in the meta-schema to prevent incompatible extensions as it remains in common use.", type: "object", additionalProperties: { $recursiveRef: "#" }, default: {} }, dependencies: { $comment: '"dependencies" is no longer a keyword, but schema authors should avoid redefining it to facilitate a smooth transition to "dependentSchemas" and "dependentRequired"', type: "object", additionalProperties: { anyOf: [{ $recursiveRef: "#" }, { $ref: "meta/validation#/$defs/stringArray" }] } } }, kb = {
  $schema: fb,
  $id: mb,
  $vocabulary: vb,
  $recursiveAnchor: pb,
  title: hb,
  allOf: yb,
  type: gb,
  properties: bb
}, wb = "https://json-schema.org/draft/2019-09/schema", Sb = "https://json-schema.org/draft/2019-09/meta/applicator", $b = { "https://json-schema.org/draft/2019-09/vocab/applicator": !0 }, _b = !0, Pb = "Applicator vocabulary meta-schema", Cb = ["object", "boolean"], xb = { additionalItems: { $recursiveRef: "#" }, unevaluatedItems: { $recursiveRef: "#" }, items: { anyOf: [{ $recursiveRef: "#" }, { $ref: "#/$defs/schemaArray" }] }, contains: { $recursiveRef: "#" }, additionalProperties: { $recursiveRef: "#" }, unevaluatedProperties: { $recursiveRef: "#" }, properties: { type: "object", additionalProperties: { $recursiveRef: "#" }, default: {} }, patternProperties: { type: "object", additionalProperties: { $recursiveRef: "#" }, propertyNames: { format: "regex" }, default: {} }, dependentSchemas: { type: "object", additionalProperties: { $recursiveRef: "#" } }, propertyNames: { $recursiveRef: "#" }, if: { $recursiveRef: "#" }, then: { $recursiveRef: "#" }, else: { $recursiveRef: "#" }, allOf: { $ref: "#/$defs/schemaArray" }, anyOf: { $ref: "#/$defs/schemaArray" }, oneOf: { $ref: "#/$defs/schemaArray" }, not: { $recursiveRef: "#" } }, Vb = { schemaArray: { type: "array", minItems: 1, items: { $recursiveRef: "#" } } }, Ib = {
  $schema: wb,
  $id: Sb,
  $vocabulary: $b,
  $recursiveAnchor: _b,
  title: Pb,
  type: Cb,
  properties: xb,
  $defs: Vb
}, Ob = "https://json-schema.org/draft/2019-09/schema", Eb = "https://json-schema.org/draft/2019-09/meta/content", Ab = { "https://json-schema.org/draft/2019-09/vocab/content": !0 }, Tb = !0, jb = "Content vocabulary meta-schema", Db = ["object", "boolean"], Mb = { contentMediaType: { type: "string" }, contentEncoding: { type: "string" }, contentSchema: { $recursiveRef: "#" } }, Rb = {
  $schema: Ob,
  $id: Eb,
  $vocabulary: Ab,
  $recursiveAnchor: Tb,
  title: jb,
  type: Db,
  properties: Mb
}, Nb = "https://json-schema.org/draft/2019-09/schema", Lb = "https://json-schema.org/draft/2019-09/meta/core", qb = { "https://json-schema.org/draft/2019-09/vocab/core": !0 }, zb = !0, Bb = "Core vocabulary meta-schema", Fb = ["object", "boolean"], Kb = { $id: { type: "string", format: "uri-reference", $comment: "Non-empty fragments not allowed.", pattern: "^[^#]*#?$" }, $schema: { type: "string", format: "uri" }, $anchor: { type: "string", pattern: "^[A-Za-z][-A-Za-z0-9.:_]*$" }, $ref: { type: "string", format: "uri-reference" }, $recursiveRef: { type: "string", format: "uri-reference" }, $recursiveAnchor: { type: "boolean", default: !1 }, $vocabulary: { type: "object", propertyNames: { type: "string", format: "uri" }, additionalProperties: { type: "boolean" } }, $comment: { type: "string" }, $defs: { type: "object", additionalProperties: { $recursiveRef: "#" }, default: {} } }, Hb = {
  $schema: Nb,
  $id: Lb,
  $vocabulary: qb,
  $recursiveAnchor: zb,
  title: Bb,
  type: Fb,
  properties: Kb
}, Ub = "https://json-schema.org/draft/2019-09/schema", Wb = "https://json-schema.org/draft/2019-09/meta/format", Gb = { "https://json-schema.org/draft/2019-09/vocab/format": !0 }, Yb = !0, Xb = "Format vocabulary meta-schema", Zb = ["object", "boolean"], Jb = { format: { type: "string" } }, Qb = {
  $schema: Ub,
  $id: Wb,
  $vocabulary: Gb,
  $recursiveAnchor: Yb,
  title: Xb,
  type: Zb,
  properties: Jb
}, ek = "https://json-schema.org/draft/2019-09/schema", tk = "https://json-schema.org/draft/2019-09/meta/meta-data", ak = { "https://json-schema.org/draft/2019-09/vocab/meta-data": !0 }, nk = !0, rk = "Meta-data vocabulary meta-schema", ik = ["object", "boolean"], sk = { title: { type: "string" }, description: { type: "string" }, default: !0, deprecated: { type: "boolean", default: !1 }, readOnly: { type: "boolean", default: !1 }, writeOnly: { type: "boolean", default: !1 }, examples: { type: "array", items: !0 } }, lk = {
  $schema: ek,
  $id: tk,
  $vocabulary: ak,
  $recursiveAnchor: nk,
  title: rk,
  type: ik,
  properties: sk
}, ok = "https://json-schema.org/draft/2019-09/schema", uk = "https://json-schema.org/draft/2019-09/meta/validation", ck = { "https://json-schema.org/draft/2019-09/vocab/validation": !0 }, dk = !0, fk = "Validation vocabulary meta-schema", mk = ["object", "boolean"], vk = { multipleOf: { type: "number", exclusiveMinimum: 0 }, maximum: { type: "number" }, exclusiveMaximum: { type: "number" }, minimum: { type: "number" }, exclusiveMinimum: { type: "number" }, maxLength: { $ref: "#/$defs/nonNegativeInteger" }, minLength: { $ref: "#/$defs/nonNegativeIntegerDefault0" }, pattern: { type: "string", format: "regex" }, maxItems: { $ref: "#/$defs/nonNegativeInteger" }, minItems: { $ref: "#/$defs/nonNegativeIntegerDefault0" }, uniqueItems: { type: "boolean", default: !1 }, maxContains: { $ref: "#/$defs/nonNegativeInteger" }, minContains: { $ref: "#/$defs/nonNegativeInteger", default: 1 }, maxProperties: { $ref: "#/$defs/nonNegativeInteger" }, minProperties: { $ref: "#/$defs/nonNegativeIntegerDefault0" }, required: { $ref: "#/$defs/stringArray" }, dependentRequired: { type: "object", additionalProperties: { $ref: "#/$defs/stringArray" } }, const: !0, enum: { type: "array", items: !0 }, type: { anyOf: [{ $ref: "#/$defs/simpleTypes" }, { type: "array", items: { $ref: "#/$defs/simpleTypes" }, minItems: 1, uniqueItems: !0 }] } }, pk = { nonNegativeInteger: { type: "integer", minimum: 0 }, nonNegativeIntegerDefault0: { $ref: "#/$defs/nonNegativeInteger", default: 0 }, simpleTypes: { enum: ["array", "boolean", "integer", "null", "number", "object", "string"] }, stringArray: { type: "array", items: { type: "string" }, uniqueItems: !0, default: [] } }, hk = {
  $schema: ok,
  $id: uk,
  $vocabulary: ck,
  $recursiveAnchor: dk,
  title: fk,
  type: mk,
  properties: vk,
  $defs: pk
};
var af;
function yk() {
  if (af) return Ri;
  af = 1, Object.defineProperty(Ri, "__esModule", { value: !0 });
  const e = kb, a = Ib, i = Rb, r = Hb, n = Qb, t = lk, s = hk, o = ["/properties"];
  function l(u) {
    return [
      e,
      a,
      i,
      r,
      c(this, n),
      t,
      c(this, s)
    ].forEach((d) => this.addMetaSchema(d, void 0, !1)), this;
    function c(d, f) {
      return u ? d.$dataMetaSchema(f, o) : f;
    }
  }
  return Ri.default = l, Ri;
}
var nf;
function gk() {
  return nf || (nf = 1, (function(e, a) {
    Object.defineProperty(a, "__esModule", { value: !0 }), a.MissingRefError = a.ValidationError = a.CodeGen = a.Name = a.nil = a.stringify = a.str = a._ = a.KeywordCxt = a.Ajv2019 = void 0;
    const i = nv(), r = lv(), n = nb(), t = lb(), s = cb(), o = cv(), l = yk(), u = "https://json-schema.org/draft/2019-09/schema";
    class c extends i.default {
      constructor(y = {}) {
        super({
          ...y,
          dynamicRef: !0,
          next: !0,
          unevaluated: !0
        });
      }
      _addVocabularies() {
        super._addVocabularies(), this.addVocabulary(n.default), r.default.forEach((y) => this.addVocabulary(y)), this.addVocabulary(t.default), this.addVocabulary(s.default), this.opts.discriminator && this.addKeyword(o.default);
      }
      _addDefaultMetaSchema() {
        super._addDefaultMetaSchema();
        const { $data: y, meta: m } = this.opts;
        m && (l.default.call(this, y), this.refs["http://json-schema.org/schema"] = u);
      }
      defaultMeta() {
        return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(u) ? u : void 0);
      }
    }
    a.Ajv2019 = c, e.exports = a = c, e.exports.Ajv2019 = c, Object.defineProperty(a, "__esModule", { value: !0 }), a.default = c;
    var d = zn();
    Object.defineProperty(a, "KeywordCxt", { enumerable: !0, get: function() {
      return d.KeywordCxt;
    } });
    var f = Ie();
    Object.defineProperty(a, "_", { enumerable: !0, get: function() {
      return f._;
    } }), Object.defineProperty(a, "str", { enumerable: !0, get: function() {
      return f.str;
    } }), Object.defineProperty(a, "stringify", { enumerable: !0, get: function() {
      return f.stringify;
    } }), Object.defineProperty(a, "nil", { enumerable: !0, get: function() {
      return f.nil;
    } }), Object.defineProperty(a, "Name", { enumerable: !0, get: function() {
      return f.Name;
    } }), Object.defineProperty(a, "CodeGen", { enumerable: !0, get: function() {
      return f.CodeGen;
    } });
    var v = Is();
    Object.defineProperty(a, "ValidationError", { enumerable: !0, get: function() {
      return v.default;
    } });
    var g = Ir();
    Object.defineProperty(a, "MissingRefError", { enumerable: !0, get: function() {
      return g.default;
    } });
  })(Fr, Fr.exports)), Fr.exports;
}
var bk = gk();
const dv = /* @__PURE__ */ xr(bk);
var Ni = { exports: {} }, Dl = {}, rf;
function kk() {
  return rf || (rf = 1, (function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.formatNames = e.fastFormats = e.fullFormats = void 0;
    function a(K, j) {
      return { validate: K, compare: j };
    }
    e.fullFormats = {
      // date: http://tools.ietf.org/html/rfc3339#section-5.6
      date: a(t, s),
      // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
      time: a(l(!0), u),
      "date-time": a(f(!0), v),
      "iso-time": a(l(), c),
      "iso-date-time": a(f(), g),
      // duration: https://tools.ietf.org/html/rfc3339#appendix-A
      duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
      uri: m,
      "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
      // uri-template: https://tools.ietf.org/html/rfc6570
      "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
      // For the source: https://gist.github.com/dperini/729294
      // For test cases: https://mathiasbynens.be/demo/url-regex
      url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
      email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
      hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
      // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
      ipv4: /^(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)$/,
      ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
      regex: q,
      // uuid: http://tools.ietf.org/html/rfc4122
      uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
      // JSON-pointer: https://tools.ietf.org/html/rfc6901
      // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
      "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/,
      "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
      // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
      "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
      // the following formats are used by the openapi specification: https://spec.openapis.org/oas/v3.0.0#data-types
      // byte: https://github.com/miguelmota/is-base64
      byte: b,
      // signed 32 bit integer
      int32: { type: "number", validate: S },
      // signed 64 bit integer
      int64: { type: "number", validate: _ },
      // C-type float
      float: { type: "number", validate: P },
      // C-type double
      double: { type: "number", validate: P },
      // hint to the UI to hide input strings
      password: !0,
      // unchecked string payload
      binary: !0
    }, e.fastFormats = {
      ...e.fullFormats,
      date: a(/^\d\d\d\d-[0-1]\d-[0-3]\d$/, s),
      time: a(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, u),
      "date-time": a(/^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, v),
      "iso-time": a(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, c),
      "iso-date-time": a(/^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, g),
      // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
      uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
      "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
      // email (sources from jsen validator):
      // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
      // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'wilful violation')
      email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i
    }, e.formatNames = Object.keys(e.fullFormats);
    function i(K) {
      return K % 4 === 0 && (K % 100 !== 0 || K % 400 === 0);
    }
    const r = /^(\d\d\d\d)-(\d\d)-(\d\d)$/, n = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    function t(K) {
      const j = r.exec(K);
      if (!j)
        return !1;
      const H = +j[1], B = +j[2], L = +j[3];
      return B >= 1 && B <= 12 && L >= 1 && L <= (B === 2 && i(H) ? 29 : n[B]);
    }
    function s(K, j) {
      if (K && j)
        return K > j ? 1 : K < j ? -1 : 0;
    }
    const o = /^(\d\d):(\d\d):(\d\d(?:\.\d+)?)(z|([+-])(\d\d)(?::?(\d\d))?)?$/i;
    function l(K) {
      return function(H) {
        const B = o.exec(H);
        if (!B)
          return !1;
        const L = +B[1], O = +B[2], U = +B[3], Z = B[4], J = B[5] === "-" ? -1 : 1, A = +(B[6] || 0), T = +(B[7] || 0);
        if (A > 23 || T > 59 || K && !Z)
          return !1;
        if (L <= 23 && O <= 59 && U < 60)
          return !0;
        const E = O - T * J, x = L - A * J - (E < 0 ? 1 : 0);
        return (x === 23 || x === -1) && (E === 59 || E === -1) && U < 61;
      };
    }
    function u(K, j) {
      if (!(K && j))
        return;
      const H = (/* @__PURE__ */ new Date("2020-01-01T" + K)).valueOf(), B = (/* @__PURE__ */ new Date("2020-01-01T" + j)).valueOf();
      if (H && B)
        return H - B;
    }
    function c(K, j) {
      if (!(K && j))
        return;
      const H = o.exec(K), B = o.exec(j);
      if (H && B)
        return K = H[1] + H[2] + H[3], j = B[1] + B[2] + B[3], K > j ? 1 : K < j ? -1 : 0;
    }
    const d = /t|\s/i;
    function f(K) {
      const j = l(K);
      return function(B) {
        const L = B.split(d);
        return L.length === 2 && t(L[0]) && j(L[1]);
      };
    }
    function v(K, j) {
      if (!(K && j))
        return;
      const H = new Date(K).valueOf(), B = new Date(j).valueOf();
      if (H && B)
        return H - B;
    }
    function g(K, j) {
      if (!(K && j))
        return;
      const [H, B] = K.split(d), [L, O] = j.split(d), U = s(H, L);
      if (U !== void 0)
        return U || u(B, O);
    }
    const h = /\/|:/, y = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
    function m(K) {
      return h.test(K) && y.test(K);
    }
    const p = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
    function b(K) {
      return p.lastIndex = 0, p.test(K);
    }
    const w = -2147483648, k = 2 ** 31 - 1;
    function S(K) {
      return Number.isInteger(K) && K <= k && K >= w;
    }
    function _(K) {
      return Number.isInteger(K);
    }
    function P() {
      return !0;
    }
    const M = /[^\\]\\Z/;
    function q(K) {
      if (M.test(K))
        return !1;
      try {
        return new RegExp(K), !0;
      } catch {
        return !1;
      }
    }
  })(Dl)), Dl;
}
var Ml = {}, Li = { exports: {} };
const wk = "http://json-schema.org/draft-07/schema#", Sk = "http://json-schema.org/draft-07/schema#", $k = "Core schema meta-schema", _k = { schemaArray: { type: "array", minItems: 1, items: { $ref: "#" } }, nonNegativeInteger: { type: "integer", minimum: 0 }, nonNegativeIntegerDefault0: { allOf: [{ $ref: "#/definitions/nonNegativeInteger" }, { default: 0 }] }, simpleTypes: { enum: ["array", "boolean", "integer", "null", "number", "object", "string"] }, stringArray: { type: "array", items: { type: "string" }, uniqueItems: !0, default: [] } }, Pk = ["object", "boolean"], Ck = { $id: { type: "string", format: "uri-reference" }, $schema: { type: "string", format: "uri" }, $ref: { type: "string", format: "uri-reference" }, $comment: { type: "string" }, title: { type: "string" }, description: { type: "string" }, default: !0, readOnly: { type: "boolean", default: !1 }, examples: { type: "array", items: !0 }, multipleOf: { type: "number", exclusiveMinimum: 0 }, maximum: { type: "number" }, exclusiveMaximum: { type: "number" }, minimum: { type: "number" }, exclusiveMinimum: { type: "number" }, maxLength: { $ref: "#/definitions/nonNegativeInteger" }, minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" }, pattern: { type: "string", format: "regex" }, additionalItems: { $ref: "#" }, items: { anyOf: [{ $ref: "#" }, { $ref: "#/definitions/schemaArray" }], default: !0 }, maxItems: { $ref: "#/definitions/nonNegativeInteger" }, minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" }, uniqueItems: { type: "boolean", default: !1 }, contains: { $ref: "#" }, maxProperties: { $ref: "#/definitions/nonNegativeInteger" }, minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" }, required: { $ref: "#/definitions/stringArray" }, additionalProperties: { $ref: "#" }, definitions: { type: "object", additionalProperties: { $ref: "#" }, default: {} }, properties: { type: "object", additionalProperties: { $ref: "#" }, default: {} }, patternProperties: { type: "object", additionalProperties: { $ref: "#" }, propertyNames: { format: "regex" }, default: {} }, dependencies: { type: "object", additionalProperties: { anyOf: [{ $ref: "#" }, { $ref: "#/definitions/stringArray" }] } }, propertyNames: { $ref: "#" }, const: !0, enum: { type: "array", items: !0, minItems: 1, uniqueItems: !0 }, type: { anyOf: [{ $ref: "#/definitions/simpleTypes" }, { type: "array", items: { $ref: "#/definitions/simpleTypes" }, minItems: 1, uniqueItems: !0 }] }, format: { type: "string" }, contentMediaType: { type: "string" }, contentEncoding: { type: "string" }, if: { $ref: "#" }, then: { $ref: "#" }, else: { $ref: "#" }, allOf: { $ref: "#/definitions/schemaArray" }, anyOf: { $ref: "#/definitions/schemaArray" }, oneOf: { $ref: "#/definitions/schemaArray" }, not: { $ref: "#" } }, xk = {
  $schema: wk,
  $id: Sk,
  title: $k,
  definitions: _k,
  type: Pk,
  properties: Ck,
  default: !0
};
var sf;
function fv() {
  return sf || (sf = 1, (function(e, a) {
    Object.defineProperty(a, "__esModule", { value: !0 }), a.MissingRefError = a.ValidationError = a.CodeGen = a.Name = a.nil = a.stringify = a.str = a._ = a.KeywordCxt = a.Ajv = void 0;
    const i = nv(), r = lv(), n = cv(), t = xk, s = ["/properties"], o = "http://json-schema.org/draft-07/schema";
    class l extends i.default {
      _addVocabularies() {
        super._addVocabularies(), r.default.forEach((g) => this.addVocabulary(g)), this.opts.discriminator && this.addKeyword(n.default);
      }
      _addDefaultMetaSchema() {
        if (super._addDefaultMetaSchema(), !this.opts.meta)
          return;
        const g = this.opts.$data ? this.$dataMetaSchema(t, s) : t;
        this.addMetaSchema(g, o, !1), this.refs["http://json-schema.org/schema"] = o;
      }
      defaultMeta() {
        return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(o) ? o : void 0);
      }
    }
    a.Ajv = l, e.exports = a = l, e.exports.Ajv = l, Object.defineProperty(a, "__esModule", { value: !0 }), a.default = l;
    var u = zn();
    Object.defineProperty(a, "KeywordCxt", { enumerable: !0, get: function() {
      return u.KeywordCxt;
    } });
    var c = Ie();
    Object.defineProperty(a, "_", { enumerable: !0, get: function() {
      return c._;
    } }), Object.defineProperty(a, "str", { enumerable: !0, get: function() {
      return c.str;
    } }), Object.defineProperty(a, "stringify", { enumerable: !0, get: function() {
      return c.stringify;
    } }), Object.defineProperty(a, "nil", { enumerable: !0, get: function() {
      return c.nil;
    } }), Object.defineProperty(a, "Name", { enumerable: !0, get: function() {
      return c.Name;
    } }), Object.defineProperty(a, "CodeGen", { enumerable: !0, get: function() {
      return c.CodeGen;
    } });
    var d = Is();
    Object.defineProperty(a, "ValidationError", { enumerable: !0, get: function() {
      return d.default;
    } });
    var f = Ir();
    Object.defineProperty(a, "MissingRefError", { enumerable: !0, get: function() {
      return f.default;
    } });
  })(Li, Li.exports)), Li.exports;
}
var lf;
function Vk() {
  return lf || (lf = 1, (function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.formatLimitDefinition = void 0;
    const a = fv(), i = Ie(), r = i.operators, n = {
      formatMaximum: { okStr: "<=", ok: r.LTE, fail: r.GT },
      formatMinimum: { okStr: ">=", ok: r.GTE, fail: r.LT },
      formatExclusiveMaximum: { okStr: "<", ok: r.LT, fail: r.GTE },
      formatExclusiveMinimum: { okStr: ">", ok: r.GT, fail: r.LTE }
    }, t = {
      message: ({ keyword: o, schemaCode: l }) => (0, i.str)`should be ${n[o].okStr} ${l}`,
      params: ({ keyword: o, schemaCode: l }) => (0, i._)`{comparison: ${n[o].okStr}, limit: ${l}}`
    };
    e.formatLimitDefinition = {
      keyword: Object.keys(n),
      type: "string",
      schemaType: "string",
      $data: !0,
      error: t,
      code(o) {
        const { gen: l, data: u, schemaCode: c, keyword: d, it: f } = o, { opts: v, self: g } = f;
        if (!v.validateFormats)
          return;
        const h = new a.KeywordCxt(f, g.RULES.all.format.definition, "format");
        h.$data ? y() : m();
        function y() {
          const b = l.scopeValue("formats", {
            ref: g.formats,
            code: v.code.formats
          }), w = l.const("fmt", (0, i._)`${b}[${h.schemaCode}]`);
          o.fail$data((0, i.or)((0, i._)`typeof ${w} != "object"`, (0, i._)`${w} instanceof RegExp`, (0, i._)`typeof ${w}.compare != "function"`, p(w)));
        }
        function m() {
          const b = h.schema, w = g.formats[b];
          if (!w || w === !0)
            return;
          if (typeof w != "object" || w instanceof RegExp || typeof w.compare != "function")
            throw new Error(`"${d}": format "${b}" does not define "compare" function`);
          const k = l.scopeValue("formats", {
            key: b,
            ref: w,
            code: v.code.formats ? (0, i._)`${v.code.formats}${(0, i.getProperty)(b)}` : void 0
          });
          o.fail$data(p(k));
        }
        function p(b) {
          return (0, i._)`${b}.compare(${u}, ${c}) ${n[d].fail} 0`;
        }
      },
      dependencies: ["format"]
    };
    const s = (o) => (o.addKeyword(e.formatLimitDefinition), o);
    e.default = s;
  })(Ml)), Ml;
}
var of;
function Ik() {
  return of || (of = 1, (function(e, a) {
    Object.defineProperty(a, "__esModule", { value: !0 });
    const i = kk(), r = Vk(), n = Ie(), t = new n.Name("fullFormats"), s = new n.Name("fastFormats"), o = (u, c = { keywords: !0 }) => {
      if (Array.isArray(c))
        return l(u, c, i.fullFormats, t), u;
      const [d, f] = c.mode === "fast" ? [i.fastFormats, s] : [i.fullFormats, t], v = c.formats || i.formatNames;
      return l(u, v, d, f), c.keywords && (0, r.default)(u), u;
    };
    o.get = (u, c = "full") => {
      const f = (c === "fast" ? i.fastFormats : i.fullFormats)[u];
      if (!f)
        throw new Error(`Unknown format "${u}"`);
      return f;
    };
    function l(u, c, d, f) {
      var v, g;
      (v = (g = u.opts.code).formats) !== null && v !== void 0 || (g.formats = (0, n._)`require("ajv-formats/dist/formats").${f}`);
      for (const h of c)
        u.addFormat(h, d[h]);
    }
    e.exports = a = o, Object.defineProperty(a, "__esModule", { value: !0 }), a.default = o;
  })(Ni, Ni.exports)), Ni.exports;
}
var Ok = Ik();
const mv = /* @__PURE__ */ xr(Ok);
var qi = { exports: {} }, uf;
function Ek() {
  return uf || (uf = 1, (function(e, a) {
    Object.defineProperty(a, "__esModule", { value: !0 });
    const i = fv(), r = Ie(), n = fr(), t = zn(), s = Vr(), o = Zt(), l = "errorMessage", u = new i.Name("emUsed"), c = {
      required: "missingProperty",
      dependencies: "property",
      dependentRequired: "property"
    }, d = /\$\{[^}]+\}/, f = /\$\{([^}]+)\}/g, v = /^""\s*\+\s*|\s*\+\s*""$/g;
    function g(y) {
      return {
        keyword: l,
        schemaType: ["string", "object"],
        post: !0,
        code(m) {
          const { gen: p, data: b, schema: w, schemaValue: k, it: S } = m;
          if (S.createErrors === !1)
            return;
          const _ = w, P = r.strConcat(o.default.instancePath, S.errorPath);
          p.if(i._`${o.default.errors} > 0`, () => {
            if (typeof _ == "object") {
              const [x, $] = q(_);
              $ && K($), x && j(x), H(M(_));
            }
            const E = typeof _ == "string" ? _ : _._;
            E && B(E), y.keepErrors || L();
          });
          function M({ properties: E, items: x }) {
            const $ = {};
            if (E) {
              $.props = {};
              for (const V in E)
                $.props[V] = [];
            }
            if (x) {
              $.items = {};
              for (let V = 0; V < x.length; V++)
                $.items[V] = [];
            }
            return $;
          }
          function q(E) {
            let x, $;
            for (const V in E) {
              if (V === "properties" || V === "items")
                continue;
              const F = E[V];
              if (typeof F == "object") {
                x || (x = {});
                const z = x[V] = {};
                for (const X in F)
                  z[X] = [];
              } else
                $ || ($ = {}), $[V] = [];
            }
            return [x, $];
          }
          function K(E) {
            const x = p.const("emErrors", i.stringify(E)), $ = p.const("templates", J(E, w));
            p.forOf("err", o.default.vErrors, (X) => p.if(O(X, x), () => p.code(i._`${x}[${X}.keyword].push(${X})`).assign(i._`${X}.${u}`, !0)));
            const { singleError: V } = y;
            if (V) {
              const X = p.let("message", i._`""`), Q = p.let("paramsErrors", i._`[]`);
              F((te) => {
                p.if(X, () => p.code(i._`${X} += ${typeof V == "string" ? V : ";"}`)), p.code(i._`${X} += ${z(te)}`), p.assign(Q, i._`${Q}.concat(${x}[${te}])`);
              }), s.reportError(m, { message: X, params: i._`{errors: ${Q}}` });
            } else
              F((X) => s.reportError(m, {
                message: z(X),
                params: i._`{errors: ${x}[${X}]}`
              }));
            function F(X) {
              p.forIn("key", x, (Q) => p.if(i._`${x}[${Q}].length`, () => X(Q)));
            }
            function z(X) {
              return i._`${X} in ${$} ? ${$}[${X}]() : ${k}[${X}]`;
            }
          }
          function j(E) {
            const x = p.const("emErrors", i.stringify(E)), $ = [];
            for (const Q in E)
              $.push([
                Q,
                J(E[Q], w[Q])
              ]);
            const V = p.const("templates", p.object(...$)), F = p.scopeValue("obj", {
              ref: c,
              code: i.stringify(c)
            }), z = p.let("emPropParams"), X = p.let("emParamsErrors");
            p.forOf("err", o.default.vErrors, (Q) => p.if(O(Q, x), () => {
              p.assign(z, i._`${F}[${Q}.keyword]`), p.assign(X, i._`${x}[${Q}.keyword][${Q}.params[${z}]]`), p.if(X, () => p.code(i._`${X}.push(${Q})`).assign(i._`${Q}.${u}`, !0));
            })), p.forIn("key", x, (Q) => p.forIn("keyProp", i._`${x}[${Q}]`, (te) => {
              p.assign(X, i._`${x}[${Q}][${te}]`), p.if(i._`${X}.length`, () => {
                const N = p.const("tmpl", i._`${V}[${Q}] && ${V}[${Q}][${te}]`);
                s.reportError(m, {
                  message: i._`${N} ? ${N}() : ${k}[${Q}][${te}]`,
                  params: i._`{errors: ${X}}`
                });
              });
            }));
          }
          function H(E) {
            const { props: x, items: $ } = E;
            if (!x && !$)
              return;
            const V = i._`typeof ${b} == "object"`, F = i._`Array.isArray(${b})`, z = p.let("emErrors");
            let X, Q;
            const te = p.let("templates");
            x && $ ? (X = p.let("emChildKwd"), p.if(V), p.if(F, () => {
              N($, w.items), p.assign(X, i.str`items`);
            }, () => {
              N(x, w.properties), p.assign(X, i.str`properties`);
            }), Q = i._`[${X}]`) : $ ? (p.if(F), N($, w.items), Q = i._`.items`) : x && (p.if(r.and(V, r.not(F))), N(x, w.properties), Q = i._`.properties`), p.forOf("err", o.default.vErrors, (R) => U(R, z, (G) => p.code(i._`${z}[${G}].push(${R})`).assign(i._`${R}.${u}`, !0))), p.forIn("key", z, (R) => p.if(i._`${z}[${R}].length`, () => {
              s.reportError(m, {
                message: i._`${R} in ${te} ? ${te}[${R}]() : ${k}${Q}[${R}]`,
                params: i._`{errors: ${z}[${R}]}`
              }), p.assign(i._`${o.default.vErrors}[${o.default.errors}-1].instancePath`, i._`${P} + "/" + ${R}.replace(/~/g, "~0").replace(/\\//g, "~1")`);
            })), p.endIf();
            function N(R, G) {
              p.assign(z, i.stringify(R)), p.assign(te, J(R, G));
            }
          }
          function B(E) {
            const x = p.const("emErrs", i._`[]`);
            p.forOf("err", o.default.vErrors, ($) => p.if(Z($), () => p.code(i._`${x}.push(${$})`).assign(i._`${$}.${u}`, !0))), p.if(i._`${x}.length`, () => s.reportError(m, {
              message: A(E),
              params: i._`{errors: ${x}}`
            }));
          }
          function L() {
            const E = p.const("emErrs", i._`[]`);
            p.forOf("err", o.default.vErrors, (x) => p.if(i._`!${x}.${u}`, () => p.code(i._`${E}.push(${x})`))), p.assign(o.default.vErrors, E).assign(o.default.errors, i._`${E}.length`);
          }
          function O(E, x) {
            return r.and(
              i._`${E}.keyword !== ${l}`,
              i._`!${E}.${u}`,
              i._`${E}.instancePath === ${P}`,
              i._`${E}.keyword in ${x}`,
              // TODO match the end of the string?
              i._`${E}.schemaPath.indexOf(${S.errSchemaPath}) === 0`,
              i._`/^\\/[^\\/]*$/.test(${E}.schemaPath.slice(${S.errSchemaPath.length}))`
            );
          }
          function U(E, x, $) {
            p.if(r.and(i._`${E}.keyword !== ${l}`, i._`!${E}.${u}`, i._`${E}.instancePath.indexOf(${P}) === 0`), () => {
              const V = p.scopeValue("pattern", {
                ref: /^\/([^/]*)(?:\/|$)/,
                code: i._`new RegExp("^\\\/([^/]*)(?:\\\/|$)")`
              }), F = p.const("emMatches", i._`${V}.exec(${E}.instancePath.slice(${P}.length))`), z = p.const("emChild", i._`${F} && ${F}[1].replace(/~1/g, "/").replace(/~0/g, "~")`);
              p.if(i._`${z} !== undefined && ${z} in ${x}`, () => $(z));
            });
          }
          function Z(E) {
            return r.and(i._`${E}.keyword !== ${l}`, i._`!${E}.${u}`, r.or(i._`${E}.instancePath === ${P}`, r.and(i._`${E}.instancePath.indexOf(${P}) === 0`, i._`${E}.instancePath[${P}.length] === "/"`)), i._`${E}.schemaPath.indexOf(${S.errSchemaPath}) === 0`, i._`${E}.schemaPath[${S.errSchemaPath}.length] === "/"`);
          }
          function J(E, x) {
            const $ = [];
            for (const V in E) {
              const F = x[V];
              d.test(F) && $.push([V, T(F)]);
            }
            return p.object(...$);
          }
          function A(E) {
            return d.test(E) ? new n._Code(n.safeStringify(E).replace(f, (x, $) => `" + JSON.stringify(${t.getData($, S)}) + "`).replace(v, "")) : i.stringify(E);
          }
          function T(E) {
            return i._`function(){return ${A(E)}}`;
          }
        },
        metaSchema: {
          anyOf: [
            { type: "string" },
            {
              type: "object",
              properties: {
                properties: { $ref: "#/$defs/stringMap" },
                items: { $ref: "#/$defs/stringList" },
                required: { $ref: "#/$defs/stringOrMap" },
                dependencies: { $ref: "#/$defs/stringOrMap" }
              },
              additionalProperties: { type: "string" }
            }
          ],
          $defs: {
            stringMap: {
              type: "object",
              additionalProperties: { type: "string" }
            },
            stringOrMap: {
              anyOf: [{ type: "string" }, { $ref: "#/$defs/stringMap" }]
            },
            stringList: { type: "array", items: { type: "string" } }
          }
        }
      };
    }
    const h = (y, m = {}) => {
      if (!y.opts.allErrors)
        throw new Error("ajv-errors: Ajv option allErrors must be true");
      if (y.opts.jsPropertySyntax)
        throw new Error("ajv-errors: ajv option jsPropertySyntax is not supported");
      return y.addKeyword(g(m));
    };
    a.default = h, e.exports = h, e.exports.default = h;
  })(qi, qi.exports)), qi.exports;
}
var Ak = Ek();
const vv = /* @__PURE__ */ xr(Ak), pv = {
  $id: "https://json-layout.github.io/normalized-layout-keyword",
  $defs: {
    "normalized-layout": {
      title: "normalized layout",
      type: "object",
      unevaluatedProperties: !1,
      oneOf: [
        {
          $ref: "#/$defs/switch-struct"
        },
        {
          $ref: "#/$defs/base-comp-object"
        }
      ]
    },
    "switch-struct": {
      type: "object",
      required: [
        "switch"
      ],
      additionalProperties: !1,
      properties: {
        switch: {
          type: "array",
          items: {
            $ref: "#/$defs/base-comp-object"
          }
        }
      }
    },
    "base-comp-object": {
      type: "object",
      required: [
        "comp"
      ],
      properties: {
        comp: {
          type: "string"
        },
        if: {
          $ref: "#/$defs/expression"
        },
        options: {
          $ref: "#/$defs/state-node-options-base"
        },
        getOptions: {
          $ref: "#/$defs/expression"
        },
        defaultData: {},
        getDefaultData: {
          $ref: "#/$defs/expression"
        },
        constData: {},
        getConstData: {
          $ref: "#/$defs/expression"
        },
        transformData: {
          $ref: "#/$defs/expression"
        },
        nullable: {
          type: "boolean"
        },
        help: {
          type: "string"
        },
        warning: {
          type: "string"
        },
        cols: {
          $ref: "#/$defs/cols-obj"
        },
        props: {
          $ref: "#/$defs/state-node-props-lib"
        },
        getProps: {
          $ref: "#/$defs/expression"
        },
        slots: {
          $ref: "#/$defs/slots"
        }
      }
    },
    "composite-comp-object": {
      allOf: [
        {
          $ref: "#/$defs/base-comp-object"
        },
        {
          type: "object",
          required: [
            "children",
            "comp"
          ],
          properties: {
            comp: {
              type: "string"
            },
            title: {
              type: [
                "string",
                "null"
              ]
            },
            subtitle: {
              type: [
                "string",
                "null"
              ]
            },
            children: {
              $ref: "#/$defs/children"
            }
          }
        }
      ]
    },
    "slot-comp-object": {
      allOf: [
        {
          $ref: "#/$defs/base-comp-object"
        },
        {
          type: "object",
          required: [
            "comp",
            "slots"
          ],
          properties: {
            comp: {
              type: "string",
              const: "slot"
            }
          }
        }
      ]
    },
    "simple-comp-object": {
      allOf: [
        {
          $ref: "#/$defs/base-comp-object"
        },
        {
          type: "object",
          required: [
            "comp"
          ],
          properties: {
            comp: {
              type: "string"
            },
            label: {
              type: "string"
            },
            hint: {
              type: [
                "string",
                "null"
              ]
            }
          }
        }
      ]
    },
    "focusable-comp-object": {
      allOf: [
        {
          $ref: "#/$defs/base-comp-object"
        },
        {
          type: "object",
          required: [
            "comp"
          ],
          properties: {
            comp: {
              type: "string"
            },
            autofocus: {
              type: "boolean"
            }
          }
        }
      ]
    },
    "items-based-comp-object": {
      allOf: [
        {
          $ref: "#/$defs/base-comp-object"
        },
        {
          type: "object",
          required: [
            "comp"
          ],
          properties: {
            comp: {
              type: "string"
            },
            items: {
              $ref: "#/$defs/select-items"
            },
            getItems: {
              $ref: "#/$defs/get-items"
            }
          }
        }
      ]
    },
    "multiple-compat-comp-object": {
      allOf: [
        {
          $ref: "#/$defs/base-comp-object"
        },
        {
          type: "object",
          required: [
            "comp"
          ],
          properties: {
            comp: {
              type: "string"
            },
            multiple: {
              type: "boolean"
            },
            separator: {
              type: "string"
            }
          }
        }
      ]
    },
    "child-ref": {
      type: "object",
      required: [
        "key"
      ],
      additionalProperties: !1,
      properties: {
        key: {
          type: [
            "string",
            "integer"
          ]
        },
        cols: {
          $ref: "#/$defs/cols-obj"
        },
        if: {
          $ref: "#/$defs/expression"
        },
        slots: {
          $ref: "#/$defs/slots"
        }
      }
    },
    "child-composite": {
      type: "object",
      required: [
        "key",
        "children"
      ],
      additionalProperties: !1,
      properties: {
        key: {
          type: [
            "string",
            "integer"
          ]
        },
        cols: {
          $ref: "#/$defs/cols-obj"
        },
        comp: {
          type: "string"
        },
        title: {
          type: "string"
        },
        subtitle: {
          type: "string"
        },
        children: {
          $ref: "#/$defs/children"
        },
        if: {
          $ref: "#/$defs/expression"
        },
        props: {
          $ref: "#/$defs/state-node-props-lib"
        },
        getProps: {
          $ref: "#/$defs/expression"
        },
        slots: {
          $ref: "#/$defs/slots"
        }
      }
    },
    "child-slot": {
      type: "object",
      required: [
        "key",
        "comp",
        "slots"
      ],
      additionalProperties: !1,
      properties: {
        key: {
          type: [
            "string",
            "integer"
          ]
        },
        cols: {
          $ref: "#/$defs/cols-obj"
        },
        comp: {
          const: "slot"
        },
        if: {
          $ref: "#/$defs/expression"
        },
        slots: {
          $ref: "#/$defs/slots"
        }
      }
    },
    child: {
      title: "Child",
      type: "object",
      oneOf: [
        {
          $ref: "#/$defs/child-ref"
        },
        {
          $ref: "#/$defs/child-composite"
        },
        {
          $ref: "#/$defs/child-slot"
        }
      ]
    },
    children: {
      type: "array",
      items: {
        $ref: "#/$defs/child"
      }
    },
    "select-items": {
      type: "array",
      items: {
        oneOf: [
          {
            $ref: "#/$defs/select-item"
          },
          {
            $ref: "#/$defs/select-item-header"
          }
        ]
      }
    },
    "select-item": {
      type: "object",
      required: [
        "title",
        "key",
        "value"
      ],
      properties: {
        title: {
          type: "string"
        },
        key: {
          type: "string"
        },
        value: {},
        icon: {
          type: "string"
        }
      }
    },
    "select-item-header": {
      type: "object",
      required: [
        "header",
        "title"
      ],
      properties: {
        header: {
          type: "boolean",
          const: !0
        },
        title: {
          type: "string"
        },
        icon: {
          type: "string"
        }
      }
    },
    "get-items": {
      type: "object",
      allOf: [
        {
          properties: {
            returnObjects: {
              type: "boolean",
              readOnly: !0
            },
            itemsResults: {
              $ref: "#/$defs/expression"
            },
            itemHeader: {
              $ref: "#/$defs/expression"
            },
            itemTitle: {
              $ref: "#/$defs/expression"
            },
            itemKey: {
              $ref: "#/$defs/expression"
            },
            itemValue: {
              $ref: "#/$defs/expression"
            },
            itemIcon: {
              $ref: "#/$defs/expression"
            },
            immutable: {
              type: "boolean"
            }
          }
        },
        {
          oneOf: [
            {
              $ref: "#/$defs/expression"
            },
            {
              $ref: "#/$defs/get-items-fetch"
            }
          ]
        }
      ]
    },
    "get-items-fetch": {
      type: "object",
      required: [
        "url"
      ],
      properties: {
        url: {
          $ref: "#/$defs/expression"
        },
        qSearchParam: {
          type: "string"
        },
        searchParams: {
          type: "object",
          patternProperties: {
            ".*": {
              $ref: "#/$defs/expression"
            }
          }
        },
        headers: {
          type: "object",
          patternProperties: {
            ".*": {
              $ref: "#/$defs/expression"
            }
          }
        }
      }
    },
    "one-of-item": {
      type: "object",
      oneOf: [
        {
          $ref: "#/$defs/one-of-item-child"
        },
        {
          $ref: "#/$defs/one-of-item-header"
        }
      ]
    },
    "one-of-item-child": {
      type: "object",
      required: [
        "title",
        "key"
      ],
      properties: {
        title: {
          type: "string"
        },
        key: {
          type: "number"
        },
        icon: {
          type: "string"
        }
      }
    },
    "one-of-item-header": {
      type: "object",
      required: [
        "header",
        "title"
      ],
      properties: {
        header: {
          type: "boolean",
          const: !0
        },
        title: {
          type: "string"
        },
        icon: {
          type: "string"
        }
      }
    },
    expression: {
      type: "object",
      required: [
        "type",
        "expr",
        "pure",
        "dataAlias"
      ],
      properties: {
        type: {
          type: "string",
          enum: [
            "js-fn",
            "js-eval",
            "js-tpl"
          ]
        },
        expr: {
          type: "string"
        },
        pure: {
          type: "boolean"
        },
        dataAlias: {
          type: "string"
        },
        ref: {
          type: "integer",
          readOnly: !0
        }
      }
    },
    "cols-obj": {
      type: "object",
      additionalProperties: !1,
      required: [
        "xs"
      ],
      properties: {
        xs: {
          $ref: "#/$defs/cols",
          default: 12
        },
        sm: {
          $ref: "#/$defs/cols"
        },
        md: {
          $ref: "#/$defs/cols"
        },
        lg: {
          $ref: "#/$defs/cols"
        },
        xl: {
          $ref: "#/$defs/cols"
        },
        xxl: {
          $ref: "#/$defs/cols"
        }
      }
    },
    cols: {
      type: "integer",
      minimum: 0,
      maximum: 12
    },
    slot: {
      oneOf: [
        {
          type: "object",
          additionalProperties: !1,
          required: [
            "text"
          ],
          properties: {
            text: {
              type: "string"
            }
          }
        },
        {
          type: "object",
          additionalProperties: !1,
          required: [
            "markdown"
          ],
          properties: {
            markdown: {
              type: "string"
            }
          }
        },
        {
          type: "object",
          additionalProperties: !1,
          required: [
            "name"
          ],
          properties: {
            name: {
              type: "string"
            },
            props: {
              type: "object"
            }
          }
        }
      ]
    },
    slots: {
      type: "object",
      allOf: [
        {
          $ref: "#/$defs/state-node-slots-lib"
        },
        {
          properties: {
            before: {
              $ref: "#/$defs/slot"
            },
            after: {
              $ref: "#/$defs/slot"
            },
            component: {
              $ref: "#/$defs/slot"
            },
            compositeComponent: {
              $ref: "#/$defs/slot"
            }
          }
        }
      ]
    },
    "state-node-options-base": {
      type: "object",
      allOf: [
        {
          $ref: "#/$defs/state-node-options-base-lib"
        },
        {
          properties: {
            readOnly: {
              type: "boolean",
              default: !1
            },
            summary: {
              type: "boolean",
              default: !1
            },
            titleDepth: {
              type: "integer",
              minimum: 1,
              maximum: 6,
              default: 2
            },
            density: {
              type: "string",
              enum: [
                "default",
                "comfortable",
                "compact"
              ],
              default: "default"
            },
            indent: {
              type: [
                "boolean",
                "integer"
              ]
            },
            removeAdditional: {
              description: "true is the same as 'unknown', false is the same as 'none'",
              default: "error",
              oneOf: [
                {
                  type: "boolean"
                },
                {
                  type: "string",
                  enum: [
                    "unknown",
                    "error",
                    "none"
                  ]
                }
              ]
            },
            validateOn: {
              type: "string",
              enum: [
                "input",
                "blur",
                "submit"
              ],
              default: "input"
            },
            updateOn: {
              type: "string",
              enum: [
                "input",
                "blur"
              ],
              default: "input"
            },
            debounceInputMs: {
              type: "integer",
              minimum: 0,
              default: 300
            },
            initialValidation: {
              type: "string",
              enum: [
                "never",
                "always",
                "withData"
              ],
              default: "withData"
            },
            defaultOn: {
              type: "string",
              enum: [
                "missing",
                "empty",
                "never"
              ],
              default: "empty"
            },
            autofocus: {
              type: "boolean",
              default: !1
            },
            readOnlyPropertiesMode: {
              type: "string",
              enum: [
                "remove",
                "hide",
                "show"
              ],
              default: "show"
            },
            listMenuWidth: {
              type: "integer",
              default: 500
            },
            listDialogWidth: {
              type: "integer",
              default: 500
            }
          }
        }
      ]
    },
    "state-node-options-base-lib": {
      type: "object",
      patternProperties: {
        ".*": {}
      }
    },
    "state-node-props-lib": {
      type: "object",
      patternProperties: {
        ".*": {}
      }
    },
    "state-node-slots-lib": {
      type: "object",
      patternProperties: {
        ".*": {
          $ref: "#/$defs/slot"
        }
      }
    }
  }
}, Tk = (
  /** @type {typeof ajvModule.default} */
  dv
), pn = new Tk({
  code: {
    source: !0,
    esm: !0
    // optimize: true
  },
  discriminator: !0,
  allowMatchingProperties: !0,
  allowUnionTypes: !0,
  allErrors: !0
});
mv.default(pn);
vv.default(pn);
pn.addSchema(Jm);
pn.addSchema(pv);
const zi = {};
function jk(e) {
  if (zi[e.name]) return zi[e.name];
  const a = og(e);
  return zi[e.name] = pn.compile(a), zi[e.name];
}
const cf = (
  /** @type {any} */
  pn.getSchema(Jm.$id)
), df = (
  /** @type {any} */
  pn.getSchema(pv.$id)
);
function ff(e, a) {
  const i = [];
  if (a === "object")
    for (const r of Object.keys(e)) {
      if (r === "properties")
        for (const n of Object.keys(e.properties ?? {}))
          i.push({ key: n }), e.dependencies?.[n] && !Array.isArray(e.dependencies[n]) && i.push({ key: `$deps-${n}` }), e.dependentSchemas && e.dependentSchemas[n] && i.push({ key: `$deps-${n}` });
      if (r === "patternProperties" && i.push({ key: "$patternProperties" }), r === "allOf" && e.allOf?.length)
        for (let n = 0; n < e.allOf.length; n++)
          i.push({ key: `$allOf-${n}` });
      r === "oneOf" && i.push({ key: "$oneOf" }), r === "then" && e.if && i.push({ key: "$then" }), r === "else" && e.if && i.push({ key: "$else" });
    }
  if (a === "array" && Array.isArray(e.items))
    for (let r = 0; r < e.items.length; r++)
      i.push({ key: r });
  return i;
}
function is(e, a, i) {
  if (!a) return e;
  let r = 0, n = 0;
  return a.map((t) => {
    if (typeof t == "string") {
      const s = e.find((o) => o.key === t);
      if (!s) throw new Error(`unknown child "${t}"`);
      return s;
    } else {
      if (Array.isArray(t))
        return r++, {
          comp: "section",
          key: `$comp-${r}`,
          children: is(e, t, i)
        };
      if ("slots" in t && !Ic(t) && (t.slots = ro(t.slots, i)), "cols" in t && (t.cols = io(t.cols)), t.if && (t.if = lt(t.if)), typeof t.cols == "number" && (t.cols = { sm: t.cols }), typeof t.cols == "object" && t.cols.xs === void 0 && (t.cols.xs = 12), t.key) {
        if (!e.find((o) => o.key === t.key)) throw new Error(`unknown child "${t.key}"`);
        return (
          /** @type {Child} */
          t
        );
      } else {
        if (Ic(t))
          return n++, {
            key: `$slot-${n}`,
            comp: "slot",
            cols: io(t.cols),
            slots: ro({ component: t }, i)
          };
        {
          const s = t;
          return Gy(s) && (s.comp || (s.comp = "section"), s.children = is(e, s.children, i), "key" in t || (r++, s.key = `$comp-${r}`)), /** @type {Child} */
          s;
        }
      }
    }
  });
}
function Dk(e, a, i, r, n) {
  if (e.slots?.component) return "slot";
  if (e.slots?.compositeComponent) return "composite-slot";
  const t = i && ["string", "integer", "number"].includes(i);
  if (n === "oneOf") return "one-of-select";
  if (n === "patternProperties") return "list";
  if (t && a.enum) return a.enum.length > 20 ? "autocomplete" : "select";
  if (t && a.oneOf) return a.oneOf.length > 20 ? "autocomplete" : "select";
  if (t && a.examples && r.useExamples === "items" && !(a.format && ["date", "date-time", "time"].includes(a.format)) || t && a.anyOf && a.anyOf.length && Object.keys(a.anyOf[a.anyOf.length - 1]).length === 0)
    return i === "string" ? "combobox" : "number-combobox";
  if (i === "string" && e.separator) return "combobox";
  if (e.items) return e.items.length > 20 ? "autocomplete" : "select";
  if (e.getItems)
    return Ym(e.getItems) && (e.getItems.qSearchParam || typeof e.getItems.url == "string" && e.getItems.url.includes("{q}") || typeof e.getItems.url == "object" && typeof e.getItems.url.expr == "string" && e.getItems.url.expr.includes("{q}")) ? "autocomplete" : "select";
  if (i === "array" && a.items) {
    const s = ["string", "integer", "number"].includes(a.items.type);
    if (s && (a.items.enum || a.items.oneOf))
      return (a.items.enum || a.items.oneOf).length > 20 ? "autocomplete" : "select";
    if (s && a.items.examples && r.useExamples === "items" || s && a.items.anyOf && a.items.anyOf.length && Object.keys(a.items.anyOf[a.items.anyOf.length - 1]).length === 0 || s && !a.items.layout && !["date", "date-time", "time"].includes(a.items.format))
      return a.items.type === "string" ? "combobox" : "number-combobox";
  }
  if (i === "object") return "section";
  if (i === "array")
    return Array.isArray(a.items) ? "section" : "list";
  if (i === "string")
    return a.format === "date" ? "date-picker" : a.format === "date-time" ? "date-time-picker" : a.format === "time" ? "time-picker" : "text-field";
  if (i === "integer" || i === "number") return "number-field";
  if (i === "boolean") return "checkbox";
  throw new Error("failed to calculate default component for schema fragment");
}
function hv(e) {
  return Yy(e) ? { ...e } : Hy(e) ? { comp: e } : Wy(e) ? { children: e } : {};
}
function Mk(e) {
  const a = typeof e == "string" ? e : e.expr;
  return !a.includes("rootData.") && !a.includes("rootData[") && !a.includes("parent.data") && !a.includes("parent.parent");
}
function lt(e, a = "js-eval", i = "value") {
  const r = Mk(e);
  return typeof e == "string" ? { type: a, expr: e, pure: r, dataAlias: i } : { pure: r, type: a, dataAlias: i, ...e };
}
function ro(e, a) {
  if (!e) return;
  const i = {};
  for (const [r, n] of Object.entries(e))
    typeof n == "string" ? ["before", "after"].includes(r) ? i[r] = { markdown: a(n).trim() } : i[r] = { name: n } : Jy(n) ? i[r] = { text: n.text } : Qy(n) ? i[r] = { name: n.name, props: n.props } : Zy(n) && (i[r] = { markdown: a(n.markdown).trim() });
  return i;
}
function io(e) {
  if (typeof e == "number")
    return { xs: 12, sm: e };
  if (typeof e == "object")
    return { xs: 12, ...e };
}
function mf(e) {
  if (!e) return null;
  const { type: a } = en(e), i = a && ["string", "integer", "number"].includes(a);
  if (e.enum && i)
    return e.enum.map((r) => ({ key: r + "", title: r + "", value: r }));
  if (e.examples && i)
    return e.examples.map((r) => ({ key: r + "", title: r + "", value: r }));
  if (e.anyOf && i && e.anyOf.length && Object.keys(e.anyOf[e.anyOf.length - 1]).length === 0) {
    const r = e.anyOf.slice(0, -1);
    if (!r.find((n) => !("const" in n)))
      return r.map((n) => ({
        ...n,
        key: n.const + "",
        title: (n.title ?? n.const) + "",
        value: n.const
      }));
  }
  return e.oneOf && i && !e.oneOf.find((r) => !("const" in r)) ? e.oneOf.map((r) => ({
    ...r,
    key: r.const + "",
    title: (r.title ?? r.const) + "",
    value: r.const
  })) : null;
}
const Rk = (e) => {
  let a = null;
  if (e.oneOf ? a = "oneOf" : e.anyOf && (a = "anyOf"), a) {
    const i = e[a];
    if (i && i.length === 2 && i.some((r) => r.type === "null")) {
      const r = i.findIndex((n) => n.type !== "null");
      if (r !== -1) {
        const n = i[r], t = na(e);
        for (const s in n)
          s in t || (t[s] = n[s]);
        return delete t[a], t.__pointer = t.__pointer + `/${a}/${r}`, t;
      }
    }
  }
}, en = (e) => {
  if (Array.isArray(e.type) && e.type.length === 2 && e.type.includes("null"))
    return { type: e.type.find((i) => i !== "null"), nullable: !0 };
  if (!e.type && (e.properties || e.patternProperties))
    return { type: "object", nullable: !1 };
  if (!e.type) {
    const a = [];
    for (const i of ["allOf", "anyOf", "oneOf"])
      if (e[i])
        for (const r of e[i]) {
          const { type: n } = en(r);
          n && !a.includes(n) && a.push(n);
        }
    if (a.length === 1) return { type: a[0], nullable: !1 };
  }
  if (Array.isArray(e.type))
    throw new Error("multiple types are not supported");
  return { type: e.type, nullable: !1 };
}, vf = ["readOnly", "summary", "titleDepth", "density", "removeAdditional", "validateOn", "updateOne", "debounceInputMs", "initialValidation", "defaultOn", "readOnlyPropertiesMode"];
function pf(e, a, i, r, n, t, s, o) {
  if ("const" in i) return { comp: "none" };
  if (!r) return { comp: "none" };
  const l = hv(a);
  if (r === "array" && !i.items && l.comp !== "file-input")
    return { comp: "none" };
  l.comp || (l.comp = Dk(l, i, r, s, o));
  const u = s.components[l.comp];
  if (!u)
    throw new Error(`unknown component "${l.comp}"`);
  if (l.comp === "none") return { comp: "none" };
  if (n && (l.nullable = n), u.itemsBased && !l.items) {
    let h;
    r === "array" ? h = mf(i.items) : h = mf(i), h && (l.getItems && _l(l.getItems) ? (l.getItems.expr = JSON.stringify(h), l.getItems.immutable = !0) : l.getItems = { expr: JSON.stringify(h), immutable: !0 });
  }
  if (l.comp === "one-of-select") {
    const h = (i.oneOf ?? []).map((y, m) => ({ key: m, title: y.title ?? `option ${m + 1}` }));
    if (l.oneOfItems) {
      let y = 0;
      const m = [];
      for (let p = 0; p < l.oneOfItems.length; p++) {
        const b = l.oneOfItems[p];
        if (typeof b == "string") {
          m.push({ title: b, key: y }), y++;
          continue;
        }
        if (b.header) {
          if (!b.title) throw new Error("missing title in oneOfItem header");
          m.push(b);
        } else {
          const w = { ...b };
          w.key === void 0 && (w.key = y);
          const k = h.find((S) => S.key === w.key);
          if (!k) throw new Error(`unknown oneOf item ${w.key}`);
          !w.title && k && (w.title = k.title), m.push(w), y++;
        }
      }
      l.oneOfItems = m;
    } else
      l.oneOfItems = h;
  }
  if (u.composite) {
    const h = is(ff(i, r), l.children, s.markdown);
    l.children = h, "title" in l || h.length === 1 && h[0].key === "$patternProperties" || (l.title = i.title ?? null);
  } else if (l.comp === "list") {
    if (o === "patternProperties") {
      if (!("title" in l)) {
        const y = is(ff(i, r), l.children, s.markdown);
        y.length === 1 && y[0].key === "$patternProperties" && (l.title = i.title ?? null);
      }
      let h = !1;
      for (const y of Object.values(i.patternProperties ?? {})) {
        const { type: m } = en(y);
        m === "object" && (h = !0);
      }
      l.listEditMode = l.listEditMode ?? (h ? "inline-single" : "inline"), l.listActions = l.listActions ?? ["add", "edit", "delete"], l.indexed = Object.keys(i.patternProperties ?? {});
    } else {
      "title" in l || (l.title = i.title ?? "" + e);
      const { type: h } = en(i.items);
      l.listEditMode = l.listEditMode ?? (h === "object" ? "inline-single" : "inline"), l.listActions || (l.getItems ? (l.listActions = ["edit"], _l(l.getItems) && l.getItems.itemTitle && !l.itemTitle && (l.itemTitle = l.getItems.itemTitle)) : l.clipboardKey ? l.listActions = ["add", "edit", "delete", "sort", "duplicate", "copy", "paste"] : l.listActions = ["add", "edit", "delete", "sort", "duplicate"]);
    }
    l.itemTitle && (l.itemTitle = lt(l.itemTitle, "js-eval", "item")), l.itemSubtitle && (l.itemSubtitle = lt(l.itemSubtitle, "js-eval", "item")), l.itemCopy && (l.itemCopy = lt(l.itemCopy ?? "item", "js-eval", "item"));
  }
  u.multipleCompat && (r === "array" || l.separator) && (l.multiple = !0), l.comp === "date-picker" && (i.format === "date" && (l.format = "date"), i.format === "date-time" && (l.format = "date-time")), ["date-picker", "date-time-picker", "time-picker"].includes(l.comp) && ("formatMinimum" in i && (l.min = l.min ?? i.formatMinimum), "formatMaximum" in i && (l.max = l.max ?? i.formatMaximum)), ["number-field", "slider"].includes(l.comp) && (r === "integer" && (l.step = l.step ?? 1), "minimum" in i && (l.min = l.min ?? i.minimum), "maximum" in i && (l.max = l.max ?? i.maximum)), l.comp === "number-field" && r === "integer" && (l.precision = 0), l.if && (l.if = lt(l.if)), !l.defaultData && i.type === "string" && t.split("#").pop() === "" && (l.defaultData = "");
  const c = s.optionsKeys ? s.optionsKeys.concat(vf) : vf;
  for (const h of c)
    h in l && (l.options = l.options ?? {}, l.options[h] = l[h], delete l[h]);
  if (i.readOnly && (l.options = l.options ?? {}, "readOnly" in l.options || (l.options.readOnly = !0)), l.getOptions !== void 0 && (l.getOptions = lt(l.getOptions)), l.getDefaultData !== void 0 && (l.getDefaultData = lt(l.getDefaultData)), l.getConstData !== void 0 && (l.getConstData = lt(l.getConstData)), l.transformData !== void 0 && (l.transformData = lt(l.transformData)), l.getProps !== void 0 && (l.getProps = lt(l.getProps)), l.getItems && Xy(l.getItems) && (l.getItems = lt(l.getItems)), l.getItems && _l(l.getItems)) {
    if (r === "object" && (l.getItems.returnObjects = !0), r === "array") {
      const { type: h } = en(i.items);
      h === "object" && (l.getItems.returnObjects = !0);
    }
    l.getItems.itemHeader && (l.getItems.itemHeader = lt(l.getItems.itemHeader, "js-eval", "item")), l.getItems.itemTitle && (l.getItems.itemTitle = lt(l.getItems.itemTitle, "js-eval", "item")), l.getItems.itemKey && (l.getItems.itemKey = lt(l.getItems.itemKey, "js-eval", "item")), l.getItems.itemValue && (l.getItems.itemValue = lt(l.getItems.itemValue, "js-eval", "item")), l.getItems.itemIcon && (l.getItems.itemIcon = lt(l.getItems.itemIcon, "js-eval", "item")), l.getItems.itemsResults && (l.getItems.itemsResults = lt(l.getItems.itemsResults, "js-eval", "body"));
  }
  if (l.getItems && Ym(l.getItems)) {
    if (l.getItems.url = lt(l.getItems.url, "js-tpl"), l.getItems.searchParams)
      for (const [h, y] of Object.entries(l.getItems.searchParams))
        l.getItems.searchParams[h] = lt(y, "js-eval");
    if (l.getItems.headers)
      for (const [h, y] of Object.entries(l.getItems.headers))
        l.getItems.headers[h] = lt(y, "js-eval");
  }
  l.items && (l.items = l.items.map((h) => {
    if (["string", "integer", "number"].includes(typeof h))
      return { title: h + "", key: h + "", value: h };
    if (typeof h == "object")
      return h.header ? h : {
        key: (h.key ?? h.value) + "",
        title: (h.title ?? h.key ?? h.value) + "",
        value: h.value ?? h.key
      };
    throw new Error(`bad item for select: ${JSON.stringify(h)}`);
  })), !l.comp && (l.items ?? l.getItems) && (l.comp = "select"), l.comp === "date-picker" && i.format === "date-time" && (l.format = "date-time"), l.slots && (l.slots = ro(l.slots, s.markdown));
  const d = [], f = [], v = [];
  !u.composite && l.comp !== "list" && l.comp !== "slot" && !("label" in l) && !o && ((s.useTitle === "label" || s.useTitle === void 0) && i.title ? l.label = i.title : l.label = e + ""), i.title && (s.useTitle === "hint" && f.push(i.title), s.useTitle === "placeholder" && v.push(i.title), s.useTitle === "help" && d.push(i.title)), i.deprecated && s.useDeprecated && (l.warning = s.messages.deprecated), i.description && (u.composite && l.title && s.useDescription.includes("subtitle") ? l.subtitle === void 0 && (l.subtitle = i.description) : s.useDescription.includes("hint") ? f.push(i.description) : !o && s.useDescription.includes("help") && d.push(i.description)), s.useName === "placeholder" && v.push(s.messages.name + e), s.useName === "hint" && f.push(s.messages.name + e), s.useName === "help" && d.push(s.messages.name + e), "default" in i && typeof i.default != "object" && (s.useDefault === "hint" && f.push(s.messages.default + i.default), s.useDefault === "placeholder" && v.push(s.messages.default + i.default)), i.examples && !i.examples.some((h) => typeof h == "object") && s.useExamples === "help" && d.push(s.messages.examples + i.examples.map((h) => `
 - ` + h).join("")), d.length && (l.help && d.unshift(l.help), l.help = d.join(`

`)), f.length && !u.composite && (l.hint && f.unshift(l.hint), l.hint = f.join(" - ")), v.length && u.schema?.properties?.placeholder && (typeof l.placeholder == "string" && v.unshift(l.placeholder), l.placeholder = v.join(" - ")), l.help && (l.help = s.markdown(l.help).trim()), l.subtitle && (l.subtitle = s.markdown(l.subtitle).trim()), "cols" in l && (l.cols = io(l.cols));
  const g = jk(u);
  if (!g(l)) {
    const h = new Error(`component "${u.name}" validation errors`);
    throw h.cause = so(g.errors), h;
  }
  return (
    /** @type {BaseCompObject} */
    l
  );
}
function Nk(e, a, i, r, n, t, s, o) {
  if (Uy(a)) {
    const l = [], u = [...a.switch];
    u.find((d) => !d.if) || u.push({});
    const c = { ...a };
    delete c.switch;
    for (let d = 0; d < u.length; d++) {
      const f = u[d], v = pf(e, { ...c, ...hv(f) }, i, r, n, t, s, o);
      l.push(v);
    }
    return { switch: l };
  } else
    return pf(e, a, i, r, n, t, s, o);
}
function Rl(e, a) {
  return e.keyword === "errorMessage" && (e = e.params.errors[0]), a(e);
}
function so(e) {
  if (!e) return [];
  const a = e.filter((r) => Rl(r, (n) => n.keyword === "anyOf" || n.keyword === "oneOf"));
  for (const r of a)
    e.find((t) => Rl(t, (s) => s.instancePath === r.instancePath && s.keyword !== "type")) && (e = e.filter((t) => Rl(t, (s) => s.instancePath !== r.instancePath || s.keyword !== "type")));
  const i = [];
  for (const r of e) {
    let n = r.instancePath + " " + (r.message ?? r.keyword);
    r.params && (n += " " + JSON.stringify(r.params)), i.push(n);
  }
  return i;
}
function hf(e, a, i, r, n, t, s) {
  let o;
  if (s === "oneOf" ? o = a.oneOfLayout ?? {} : s === "patternProperties" ? o = a.patternPropertiesLayout ?? {} : o = a.layout ?? {}, !cf(o)) {
    const u = new Error("layout keyword validation errors at path");
    throw u.cause = so(cf.errors), u;
  }
  const l = Nk(e, o, a, i, r, n, t, s);
  if (!df(l)) {
    const u = new Error("normalized layout validation errors at path");
    throw u.cause = so(df.errors), u;
  }
  return l;
}
function Nl(e, a, i, r, n, t, s) {
  const { type: o, nullable: l } = t ? { type: t, nullable: s ?? !1 } : en(a), u = [];
  try {
    return { layout: hf(e, a, o, l, i, r, n), errors: u };
  } catch (c) {
    try {
      return u.push(c.message), c.cause && Array.isArray(c.cause) && u.push(...c.cause), u.push("failed to normalize layout, use default component"), { layout: hf(e, { ...a, layout: {} }, o, l, i, r, n), errors: u };
    } catch (d) {
      return u.push(d.message), d.cause && Array.isArray(d.cause) && u.push(...d.cause), u.push("failed to produce default layout, hide this fragment"), { layout: { comp: "none" }, errors: u };
    }
  }
}
const Lk = (e, a) => (i, r) => {
  const n = a.opts.uriResolver.resolve(i, r), [t, s] = n.split("#");
  if (e[t] = e[t] ?? a.getSchema(t)?.schema, !e[t]) throw new Error(`reference not found ${t}`);
  if (!s) return [e[t], t, n];
  const o = s.split("/").filter((u) => !!u), { value: l } = o.reduce((u, c) => {
    if (u.path.push(c), !(c in u.value)) throw new Error(`reference not found ${t}#${u.path.join("/")}`);
    return u.value = u.value[c], u;
  }, { path: (
    /** @type {string[]} */
    []
  ), value: e[t] });
  return [l, t, n];
};
function qk(e, a, i = "en", r = "en") {
  if (!e.$id) throw new Error("missing schema id");
  const n = Lk({ [e.$id]: e }, a), t = [];
  return lo(e, e.$id, n, i, r, t), n;
}
const lo = (e, a, i, r, n, t) => {
  if (!t.includes(e)) {
    t.push(e);
    for (const s of Object.keys(e))
      if (e[s] && typeof e[s] == "object")
        if ("$ref" in e[s]) {
          const o = e[s].$ref.replace("~$locale~", r), l = e[s].$ref.replace("~$locale~", n);
          let u, c;
          try {
            [u, c] = i(a, o), e[s].$ref = o;
          } catch {
            [u, c] = i(a, l), e[s].$ref = l;
          }
          typeof u == "string" ? e[s] = u : lo(u, c, i, r, n, t);
        } else
          lo(e[s], a, i, r, n, t);
  }
};
function zk(e, a, i) {
  let r = null;
  if (e.items && e.items.$ref) {
    const [n] = i(a, e.items.$ref);
    r = r ?? na(e), r.items = { ...n, ...e.items };
  }
  if (e.properties) {
    for (const n in e.properties)
      if (e.properties[n].$ref) {
        const [t] = i(a, e.properties[n].$ref);
        r = r ?? na(e), r.properties[n] = { ...t, ...e.properties[n] };
      }
  }
  if (e.oneOf) {
    for (let n = 0; n < e.oneOf.length; n++)
      if (e.oneOf[n].$ref) {
        const [t] = i(a, e.oneOf[n].$ref);
        r = r ?? na(e), r.oneOf[n] = { ...t, ...e.oneOf[n] };
      }
  }
  if (e.anyOf) {
    for (let n = 0; n < e.anyOf.length; n++)
      if (e.anyOf[n].$ref) {
        const [t] = i(a, e.anyOf[n].$ref);
        r = r ?? na(e), r.anyOf[n] = { ...t, ...e.anyOf[n] };
      }
  }
  if (e.allOf) {
    for (let n = 0; n < e.allOf.length; n++)
      if (e.allOf[n].$ref) {
        const [t] = i(a, e.allOf[n].$ref);
        r = r ?? na(e), r.allOf[n] = { ...t, ...e.allOf[n] };
      }
  }
  return r ?? e;
}
function Xa(e, a, i, r, n, t, s, o, l, u, c, d, f, v, g, h) {
  let y = a, m = e, p = d, b, w = e.errorMessage;
  e.__pointer = d, m.$ref && ([b, y, p] = r(a, m.$ref), b.__pointer = p, m = { ...b, ...e }, w && b.errorMessage, w = b.errorMessage = b.errorMessage ?? w ?? {}, delete m.$ref), w = e.errorMessage = w ?? {};
  const k = Rk(m);
  k && (m = k, d === p && (d = m.__pointer), p = m.__pointer);
  const S = p === m.$id ? p += "#" : p, _ = zk(m, y, r);
  let { type: P, nullable: M } = en(_);
  if (h && (P = h), k && (M = !0), !l[d]) {
    const O = Nl(
      c,
      /** @type {import('@json-layout/vocabulary').SchemaFragment} */
      _,
      d,
      i,
      void 0,
      P,
      M
    );
    l[d] = O.layout, O.errors.length && (o[d.replace("_jl#", "/")] = O.errors);
  }
  const q = l[d];
  let K = !g;
  const j = (O, U) => {
    U.pure || (K = !1);
    const Z = O.findIndex((J) => J.type === U.type && J.expr === U.expr);
    Z !== -1 ? U.ref = Z : (U.ref = O.length, O.push(U));
  }, H = (O) => {
    if (O.if && j(u, O.if), Xm(O)) {
      O.props !== void 0 && !O.getProps && (O.getProps = { type: "js-eval", expr: "layout.props", pure: !0, dataAlias: "value" }), O.getProps && j(u, O.getProps);
      for (const U of O.children) H(U);
    }
  }, B = Ja(q) ? q.switch : [q];
  for (const O of B) {
    if (!i.components[O.comp]) throw new Error(`Component "${O.comp}" not found`);
    if (O.if && j(u, O.if), lr(O, i.components))
      for (const J of O.children) H(J);
    m.const !== void 0 && O.constData === void 0 && (O.constData = m.const), O.constData !== void 0 && !O.getConstData && (O.getConstData = { type: "js-eval", expr: "layout.constData", pure: !0, dataAlias: "value" }), O.getConstData && j(u, O.getConstData);
    let Z;
    if ("default" in m && (i.useDefault === "data" || i.useDefault === !0 || f) ? Z = m.default : f && (M ? Z = null : P === "object" && lr(O, i.components) ? Z = {} : P === "array" ? Z = [] : P === "boolean" && (Z = !1)), Z !== void 0 && O.defaultData === void 0 && (O.defaultData = Z), O.defaultData !== void 0 && !O.getDefaultData && (O.getDefaultData = { type: "js-eval", expr: "layout.defaultData", pure: !0, dataAlias: "value" }), O.getDefaultData && j(u, O.getDefaultData), O.options !== void 0 && !O.getOptions && (O.getOptions = { type: "js-eval", expr: "layout.options", pure: !0, dataAlias: "value" }), O.getOptions && j(u, O.getOptions), O.props !== void 0 && !O.getProps && (O.getProps = { type: "js-eval", expr: "layout.props", pure: !0, dataAlias: "value" }), O.getProps && j(u, O.getProps), O.transformData && j(u, O.transformData), Zm(O) && (O.itemTitle && j(u, O.itemTitle), O.itemSubtitle && j(u, O.itemSubtitle), O.itemCopy && j(u, O.itemCopy)), or(O, i.components) && O.getItems) {
      if (Xo(O.getItems) && j(u, O.getItems), Zo(O.getItems)) {
        if (j(u, O.getItems.url), O.getItems.searchParams)
          for (const J of Object.values(O.getItems.searchParams))
            j(u, J);
        if (O.getItems.headers)
          for (const J of Object.values(O.getItems.headers))
            j(u, J);
      }
      O.getItems.itemHeader && j(u, O.getItems.itemHeader), O.getItems.itemTitle && j(u, O.getItems.itemTitle), O.getItems.itemKey && j(u, O.getItems.itemKey), O.getItems.itemValue && j(u, O.getItems.itemValue), O.getItems.itemIcon && j(u, O.getItems.itemIcon), O.getItems.itemsResults && j(u, O.getItems.itemsResults);
    }
  }
  const L = {
    title: m.title,
    key: c ?? "",
    pointer: d,
    refPointer: p,
    pure: K,
    propertyKeys: [],
    roPropertyKeys: [],
    nullable: M,
    required: f && !M
  };
  if (v) {
    if (Ja(q)) throw new Error("Switch struct not allowed in conditional schema");
    L.condition = { type: "js-eval", expr: v, pure: !0, dataAlias: "value" }, j(u, L.condition);
  }
  if (m.oneOf && (w.oneOf = w.oneOf ?? i.messages.errorOneOf), P === "object") {
    if (m.properties) {
      L.children = L.children ?? [];
      for (const O of Object.keys(m.properties)) {
        L.propertyKeys.push(O), m.properties[O].readOnly && L.roPropertyKeys.push(O);
        const U = m.dependentRequired && Object.values(m.dependentRequired).some((J) => J.includes(O)), Z = `${S}/properties/${O}`;
        if (t[Z] || (t[Z] = "recursing", t[Z] = Xa(
          m.properties[O],
          y,
          i,
          r,
          n,
          t,
          s,
          o,
          l,
          u,
          O,
          Z,
          m.required?.includes(O),
          void 0,
          U
        )), L.children.push(Z), m.dependentSchemas?.[O] || m.dependencies?.[O] && !Array.isArray(m.dependencies[O])) {
          const J = m.dependentSchemas?.[O] ?? m.dependencies[O], A = m.dependentSchemas?.[O] ? `${S}/dependentSchemas/${O}` : `${S}/dependencies/${O}`;
          t[A] || (t[A] = "recursing", t[A] = Xa(
            J,
            y,
            i,
            r,
            n,
            t,
            s,
            o,
            l,
            u,
            `$deps-${O}`,
            A,
            !1,
            `data["${O}"] !== undefined`,
            void 0,
            "object"
          )), L.propertyKeys.push("$" + A), L.roPropertyKeys.push("$" + A), L.children.push(A);
        }
      }
    }
    if (m.allOf)
      for (let O = 0; O < m.allOf.length; O++) {
        const U = `${S}/allOf/${O}`;
        t[U] || (t[U] = "recursing", t[U] = Xa(
          m.allOf[O],
          y,
          i,
          r,
          n,
          t,
          s,
          o,
          l,
          u,
          `$allOf-${O}`,
          U,
          !1,
          void 0,
          void 0,
          "object"
        )), L.propertyKeys.push("$" + U), L.roPropertyKeys.push("$" + U), L.children = L.children ?? [], L.children.push(U);
      }
    if (m.oneOf) {
      let O;
      m.discriminator?.propertyName && (O = m.discriminator?.propertyName);
      const U = `${S}/oneOf`;
      if (!l[U]) {
        const T = Nl(
          "",
          /** @type {import('@json-layout/vocabulary').SchemaFragment} */
          _,
          U,
          i,
          "oneOf",
          P,
          M
        ), E = Ja(T.layout) ? T.layout.switch : [T.layout];
        for (const x of E) {
          let $;
          "default" in m && (i.useDefault === "data" || i.useDefault === !0 || f) ? $ = m.default : $ = M ? null : {}, x.defaultData === void 0 && (x.defaultData = $), x.defaultData !== void 0 && !x.getDefaultData && (x.getDefaultData = { type: "js-eval", expr: "layout.defaultData", pure: !0, dataAlias: "value" }), x.getDefaultData && j(u, x.getDefaultData);
        }
        l[U] = T.layout, T.errors.length && (o[U.replace("_jl#", "/")] = T.errors);
      }
      const Z = [], J = [], A = [];
      for (let T = 0; T < m.oneOf.length; T++) {
        m.oneOf[T].type || (m.oneOf[T].type = P);
        const E = `${U}/${T}`;
        n[E] || (n[E] = "recursing", n[E] = Ji(
          m.oneOf[T],
          y,
          i,
          r,
          n,
          t,
          s,
          o,
          l,
          u,
          E,
          `option ${T + 1}`,
          !0,
          O
        )), Z.push(E), J.push("$" + E), A.push("$" + E);
      }
      t[U] || (t[U] = {
        key: "$oneOf",
        pointer: U,
        refPointer: U,
        childrenTrees: Z,
        discriminator: O,
        pure: !Z.some((T) => !t[n[T]?.root]?.pure),
        propertyKeys: J,
        roPropertyKeys: A
      }), L.propertyKeys = L.propertyKeys.concat(t[U].propertyKeys), L.roPropertyKeys = L.roPropertyKeys.concat(t[U].roPropertyKeys), L.children = L.children ?? [], L.children.push(U);
    }
    if (m.patternProperties) {
      const O = `${d}/patternProperties`;
      if (!l[O]) {
        const Z = Nl(
          "",
          /** @type {import('@json-layout/vocabulary').SchemaFragment} */
          _,
          O,
          i,
          "patternProperties",
          P,
          M
        );
        l[O] = Z.layout, Z.errors.length && (o[O.replace("_jl#", "/")] = Z.errors);
      }
      const U = [];
      for (const Z of Object.keys(m.patternProperties)) {
        const J = `${O}/${Z}`;
        if (!n[J]) {
          n[J] = "recursing", n[J] = Ji(
            m.patternProperties[Z],
            y,
            i,
            r,
            n,
            t,
            s,
            o,
            l,
            u,
            J,
            "pattern " + Z
          );
          const A = l[t[n[J].root].pointer];
          if (Ja(A))
            for (const T of A.switch)
              T.nullable = !0;
          else
            A.nullable = !0;
        }
        U.push(J);
      }
      t[O] || (t[O] = {
        key: "$patternProperties",
        pointer: O,
        refPointer: O,
        childrenTrees: U,
        pure: !U.some((Z) => !t[n[Z]?.root]?.pure),
        propertyKeys: [],
        roPropertyKeys: []
      }), L.children = L.children ?? [], L.children.push(O);
    }
    if (m.if) {
      if (s.push(`${d}/if`), m.then) {
        const O = `${S}/then`;
        t[O] || (t[O] = "recursing", t[O] = Xa(
          m.then,
          y,
          i,
          r,
          n,
          t,
          s,
          o,
          l,
          u,
          "$then",
          O,
          !1,
          `validates["${d}/if"](data)`,
          void 0,
          "object"
        )), L.children = L.children ?? [], L.propertyKeys.push("$" + O), L.roPropertyKeys.push("$" + O), L.children.push(O);
      }
      if (m.else) {
        const O = `${S}/else`;
        t[O] || (t[O] = "recursing", t[O] = Xa(
          m.else,
          y,
          i,
          r,
          n,
          t,
          s,
          o,
          l,
          u,
          "$else",
          O,
          !1,
          `!validates["${d}/if"](data)`,
          void 0,
          "object"
        )), L.children = L.children ?? [], L.propertyKeys.push("$" + O), L.roPropertyKeys.push("$" + O), L.children.push(O);
      }
    }
    for (const O of L.propertyKeys)
      m?.required?.includes(O) && (w.required = e.errorMessage.required ?? {}, w.required[O] = w.required[O] ?? i.messages.errorRequired), m.dependentRequired && Object.keys(m.dependentRequired).includes(O) && (w.dependentRequired = w.dependentRequired ?? i.messages.errorRequired);
  }
  if (P === "array" && m.items)
    if (Array.isArray(m.items)) {
      L.children = L.children ?? [];
      for (let O = 0; O < m.items.length; O++) {
        const U = m.items[O], Z = `${S}/items/${O}`;
        t[Z] || (t[Z] = "recursing", t[Z] = Xa(
          U,
          y,
          i,
          r,
          n,
          t,
          s,
          o,
          l,
          u,
          O,
          Z,
          !0
        )), L.children.push(Z);
      }
    } else {
      const O = `${S}/items`;
      n[O] || (n[O] = "recursing", n[O] = Ji(
        m.items,
        y,
        i,
        r,
        n,
        t,
        s,
        o,
        l,
        u,
        O
      )), L.childrenTrees = [O];
      const U = l[t[n[O].root].pointer];
      if (Ja(U))
        for (const Z of U.switch)
          Z.nullable = !0;
      else
        U.nullable = !0;
    }
  for (const O of L.children || [])
    t[O].pure || (L.pure = !1);
  for (const O of L.childrenTrees || [])
    t[n[O]?.root]?.pure || (L.pure = !1);
  return L;
}
function Ji(e, a, i, r, n, t, s, o, l, u, c, d, f, v) {
  let g;
  t[c] || (t[c] = "recursing", t[c] = Xa(
    e,
    a,
    i,
    r,
    n,
    t,
    s,
    o,
    l,
    u,
    "",
    c,
    !0
  ), g = t[c].title, f && delete t[c].title, s.push(t[c].refPointer));
  let h;
  if (v) {
    if (e.$ref) {
      const [y] = r(a, e.$ref);
      h = y.properties?.[v]?.const;
    } else
      h = e.properties?.[v]?.const;
    if (h === void 0) throw new Error(`const discriminator ${v} missing in oneOf item ${c}`);
  }
  return { title: g ?? d ?? "", root: c, refPointer: t[c].refPointer, discriminatorValue: h };
}
const oo = (e, a, i = "en") => {
  if (!(!e || typeof e != "object"))
    for (const [r, n] of Object.entries(e))
      if (r.startsWith("x-i18n-")) {
        typeof n != "object" && console.error(`i18n property ${r} should be an object`);
        const t = r.replace("x-i18n-", "");
        e[t] = n[a] ?? n[i] ?? e[t], delete e[r];
      } else if (Array.isArray(n))
        for (const t of n)
          oo(t, a, i);
      else
        oo(n, a, i);
};
function tu() {
  return {
    async: !1,
    breaks: !1,
    extensions: null,
    gfm: !0,
    hooks: null,
    pedantic: !1,
    renderer: null,
    silent: !1,
    tokenizer: null,
    walkTokens: null
  };
}
var hn = tu();
function yv(e) {
  hn = e;
}
var ur = { exec: () => null };
function Ke(e, a = "") {
  let i = typeof e == "string" ? e : e.source;
  const r = {
    replace: (n, t) => {
      let s = typeof t == "string" ? t : t.source;
      return s = s.replace(Ot.caret, "$1"), i = i.replace(n, s), r;
    },
    getRegex: () => new RegExp(i, a)
  };
  return r;
}
var Ot = {
  codeRemoveIndent: /^(?: {1,4}| {0,3}\t)/gm,
  outputLinkReplace: /\\([\[\]])/g,
  indentCodeCompensation: /^(\s+)(?:```)/,
  beginningSpace: /^\s+/,
  endingHash: /#$/,
  startingSpaceChar: /^ /,
  endingSpaceChar: / $/,
  nonSpaceChar: /[^ ]/,
  newLineCharGlobal: /\n/g,
  tabCharGlobal: /\t/g,
  multipleSpaceGlobal: /\s+/g,
  blankLine: /^[ \t]*$/,
  doubleBlankLine: /\n[ \t]*\n[ \t]*$/,
  blockquoteStart: /^ {0,3}>/,
  blockquoteSetextReplace: /\n {0,3}((?:=+|-+) *)(?=\n|$)/g,
  blockquoteSetextReplace2: /^ {0,3}>[ \t]?/gm,
  listReplaceTabs: /^\t+/,
  listReplaceNesting: /^ {1,4}(?=( {4})*[^ ])/g,
  listIsTask: /^\[[ xX]\] /,
  listReplaceTask: /^\[[ xX]\] +/,
  anyLine: /\n.*\n/,
  hrefBrackets: /^<(.*)>$/,
  tableDelimiter: /[:|]/,
  tableAlignChars: /^\||\| *$/g,
  tableRowBlankLine: /\n[ \t]*$/,
  tableAlignRight: /^ *-+: *$/,
  tableAlignCenter: /^ *:-+: *$/,
  tableAlignLeft: /^ *:-+ *$/,
  startATag: /^<a /i,
  endATag: /^<\/a>/i,
  startPreScriptTag: /^<(pre|code|kbd|script)(\s|>)/i,
  endPreScriptTag: /^<\/(pre|code|kbd|script)(\s|>)/i,
  startAngleBracket: /^</,
  endAngleBracket: />$/,
  pedanticHrefTitle: /^([^'"]*[^\s])\s+(['"])(.*)\2/,
  unicodeAlphaNumeric: /[\p{L}\p{N}]/u,
  escapeTest: /[&<>"']/,
  escapeReplace: /[&<>"']/g,
  escapeTestNoEncode: /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/,
  escapeReplaceNoEncode: /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/g,
  unescapeTest: /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig,
  caret: /(^|[^\[])\^/g,
  percentDecode: /%25/g,
  findPipe: /\|/g,
  splitPipe: / \|/,
  slashPipe: /\\\|/g,
  carriageReturn: /\r\n|\r/g,
  spaceLine: /^ +$/gm,
  notSpaceStart: /^\S*/,
  endingNewline: /\n$/,
  listItemRegex: (e) => new RegExp(`^( {0,3}${e})((?:[	 ][^\\n]*)?(?:\\n|$))`),
  nextBulletRegex: (e) => new RegExp(`^ {0,${Math.min(3, e - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`),
  hrRegex: (e) => new RegExp(`^ {0,${Math.min(3, e - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`),
  fencesBeginRegex: (e) => new RegExp(`^ {0,${Math.min(3, e - 1)}}(?:\`\`\`|~~~)`),
  headingBeginRegex: (e) => new RegExp(`^ {0,${Math.min(3, e - 1)}}#`),
  htmlBeginRegex: (e) => new RegExp(`^ {0,${Math.min(3, e - 1)}}<(?:[a-z].*>|!--)`, "i")
}, Bk = /^(?:[ \t]*(?:\n|$))+/, Fk = /^((?: {4}| {0,3}\t)[^\n]+(?:\n(?:[ \t]*(?:\n|$))*)?)+/, Kk = /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/, Or = /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/, Hk = /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/, au = /(?:[*+-]|\d{1,9}[.)])/, gv = /^(?!bull |blockCode|fences|blockquote|heading|html|table)((?:.|\n(?!\s*?\n|bull |blockCode|fences|blockquote|heading|html|table))+?)\n {0,3}(=+|-+) *(?:\n+|$)/, bv = Ke(gv).replace(/bull/g, au).replace(/blockCode/g, /(?: {4}| {0,3}\t)/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, / {0,3}<[^\n>]+>\n/).replace(/\|table/g, "").getRegex(), Uk = Ke(gv).replace(/bull/g, au).replace(/blockCode/g, /(?: {4}| {0,3}\t)/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, / {0,3}<[^\n>]+>\n/).replace(/table/g, / {0,3}\|?(?:[:\- ]*\|)+[\:\- ]*\n/).getRegex(), nu = /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/, Wk = /^[^\n]+/, ru = /(?!\s*\])(?:\\.|[^\[\]\\])+/, Gk = Ke(/^ {0,3}\[(label)\]: *(?:\n[ \t]*)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n[ \t]*)?| *\n[ \t]*)(title))? *(?:\n+|$)/).replace("label", ru).replace("title", /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/).getRegex(), Yk = Ke(/^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/).replace(/bull/g, au).getRegex(), Es = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul", iu = /<!--(?:-?>|[\s\S]*?(?:-->|$))/, Xk = Ke(
  "^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$))",
  "i"
).replace("comment", iu).replace("tag", Es).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex(), kv = Ke(nu).replace("hr", Or).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", Es).getRegex(), Zk = Ke(/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/).replace("paragraph", kv).getRegex(), su = {
  blockquote: Zk,
  code: Fk,
  def: Gk,
  fences: Kk,
  heading: Hk,
  hr: Or,
  html: Xk,
  lheading: bv,
  list: Yk,
  newline: Bk,
  paragraph: kv,
  table: ur,
  text: Wk
}, yf = Ke(
  "^ *([^\\n ].*)\\n {0,3}((?:\\| *)?:?-+:? *(?:\\| *:?-+:? *)*(?:\\| *)?)(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)"
).replace("hr", Or).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("blockquote", " {0,3}>").replace("code", "(?: {4}| {0,3}	)[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", Es).getRegex(), Jk = {
  ...su,
  lheading: Uk,
  table: yf,
  paragraph: Ke(nu).replace("hr", Or).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("table", yf).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", Es).getRegex()
}, Qk = {
  ...su,
  html: Ke(
    `^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`
  ).replace("comment", iu).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),
  def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
  heading: /^(#{1,6})(.*)(?:\n+|$)/,
  fences: ur,
  // fences not supported
  lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
  paragraph: Ke(nu).replace("hr", Or).replace("heading", ` *#{1,6} *[^
]`).replace("lheading", bv).replace("|table", "").replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").replace("|tag", "").getRegex()
}, e0 = /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/, t0 = /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/, wv = /^( {2,}|\\)\n(?!\s*$)/, a0 = /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/, As = /[\p{P}\p{S}]/u, lu = /[\s\p{P}\p{S}]/u, Sv = /[^\s\p{P}\p{S}]/u, n0 = Ke(/^((?![*_])punctSpace)/, "u").replace(/punctSpace/g, lu).getRegex(), $v = /(?!~)[\p{P}\p{S}]/u, r0 = /(?!~)[\s\p{P}\p{S}]/u, i0 = /(?:[^\s\p{P}\p{S}]|~)/u, s0 = /\[[^[\]]*?\]\((?:\\.|[^\\\(\)]|\((?:\\.|[^\\\(\)])*\))*\)|`[^`]*?`|<[^<>]*?>/g, _v = /^(?:\*+(?:((?!\*)punct)|[^\s*]))|^_+(?:((?!_)punct)|([^\s_]))/, l0 = Ke(_v, "u").replace(/punct/g, As).getRegex(), o0 = Ke(_v, "u").replace(/punct/g, $v).getRegex(), Pv = "^[^_*]*?__[^_*]*?\\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\\*)punct(\\*+)(?=[\\s]|$)|notPunctSpace(\\*+)(?!\\*)(?=punctSpace|$)|(?!\\*)punctSpace(\\*+)(?=notPunctSpace)|[\\s](\\*+)(?!\\*)(?=punct)|(?!\\*)punct(\\*+)(?!\\*)(?=punct)|notPunctSpace(\\*+)(?=notPunctSpace)", u0 = Ke(Pv, "gu").replace(/notPunctSpace/g, Sv).replace(/punctSpace/g, lu).replace(/punct/g, As).getRegex(), c0 = Ke(Pv, "gu").replace(/notPunctSpace/g, i0).replace(/punctSpace/g, r0).replace(/punct/g, $v).getRegex(), d0 = Ke(
  "^[^_*]*?\\*\\*[^_*]*?_[^_*]*?(?=\\*\\*)|[^_]+(?=[^_])|(?!_)punct(_+)(?=[\\s]|$)|notPunctSpace(_+)(?!_)(?=punctSpace|$)|(?!_)punctSpace(_+)(?=notPunctSpace)|[\\s](_+)(?!_)(?=punct)|(?!_)punct(_+)(?!_)(?=punct)",
  "gu"
).replace(/notPunctSpace/g, Sv).replace(/punctSpace/g, lu).replace(/punct/g, As).getRegex(), f0 = Ke(/\\(punct)/, "gu").replace(/punct/g, As).getRegex(), m0 = Ke(/^<(scheme:[^\s\x00-\x1f<>]*|email)>/).replace("scheme", /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/).replace("email", /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/).getRegex(), v0 = Ke(iu).replace("(?:-->|$)", "-->").getRegex(), p0 = Ke(
  "^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>"
).replace("comment", v0).replace("attribute", /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/).getRegex(), ss = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/, h0 = Ke(/^!?\[(label)\]\(\s*(href)(?:(?:[ \t]*(?:\n[ \t]*)?)(title))?\s*\)/).replace("label", ss).replace("href", /<(?:\\.|[^\n<>\\])+>|[^ \t\n\x00-\x1f]*/).replace("title", /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/).getRegex(), Cv = Ke(/^!?\[(label)\]\[(ref)\]/).replace("label", ss).replace("ref", ru).getRegex(), xv = Ke(/^!?\[(ref)\](?:\[\])?/).replace("ref", ru).getRegex(), y0 = Ke("reflink|nolink(?!\\()", "g").replace("reflink", Cv).replace("nolink", xv).getRegex(), ou = {
  _backpedal: ur,
  // only used for GFM url
  anyPunctuation: f0,
  autolink: m0,
  blockSkip: s0,
  br: wv,
  code: t0,
  del: ur,
  emStrongLDelim: l0,
  emStrongRDelimAst: u0,
  emStrongRDelimUnd: d0,
  escape: e0,
  link: h0,
  nolink: xv,
  punctuation: n0,
  reflink: Cv,
  reflinkSearch: y0,
  tag: p0,
  text: a0,
  url: ur
}, g0 = {
  ...ou,
  link: Ke(/^!?\[(label)\]\((.*?)\)/).replace("label", ss).getRegex(),
  reflink: Ke(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", ss).getRegex()
}, uo = {
  ...ou,
  emStrongRDelimAst: c0,
  emStrongLDelim: o0,
  url: Ke(/^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/, "i").replace("email", /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/).getRegex(),
  _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,
  del: /^(~~?)(?=[^\s~])((?:\\.|[^\\])*?(?:\\.|[^\s~\\]))\1(?=[^~]|$)/,
  text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
}, b0 = {
  ...uo,
  br: Ke(wv).replace("{2,}", "*").getRegex(),
  text: Ke(uo.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex()
}, Bi = {
  normal: su,
  gfm: Jk,
  pedantic: Qk
}, tr = {
  normal: ou,
  gfm: uo,
  breaks: b0,
  pedantic: g0
}, k0 = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
}, gf = (e) => k0[e];
function ma(e, a) {
  if (a) {
    if (Ot.escapeTest.test(e))
      return e.replace(Ot.escapeReplace, gf);
  } else if (Ot.escapeTestNoEncode.test(e))
    return e.replace(Ot.escapeReplaceNoEncode, gf);
  return e;
}
function bf(e) {
  try {
    e = encodeURI(e).replace(Ot.percentDecode, "%");
  } catch {
    return null;
  }
  return e;
}
function kf(e, a) {
  const i = e.replace(Ot.findPipe, (t, s, o) => {
    let l = !1, u = s;
    for (; --u >= 0 && o[u] === "\\"; ) l = !l;
    return l ? "|" : " |";
  }), r = i.split(Ot.splitPipe);
  let n = 0;
  if (r[0].trim() || r.shift(), r.length > 0 && !r.at(-1)?.trim() && r.pop(), a)
    if (r.length > a)
      r.splice(a);
    else
      for (; r.length < a; ) r.push("");
  for (; n < r.length; n++)
    r[n] = r[n].trim().replace(Ot.slashPipe, "|");
  return r;
}
function ar(e, a, i) {
  const r = e.length;
  if (r === 0)
    return "";
  let n = 0;
  for (; n < r && e.charAt(r - n - 1) === a; )
    n++;
  return e.slice(0, r - n);
}
function w0(e, a) {
  if (e.indexOf(a[1]) === -1)
    return -1;
  let i = 0;
  for (let r = 0; r < e.length; r++)
    if (e[r] === "\\")
      r++;
    else if (e[r] === a[0])
      i++;
    else if (e[r] === a[1] && (i--, i < 0))
      return r;
  return i > 0 ? -2 : -1;
}
function wf(e, a, i, r, n) {
  const t = a.href, s = a.title || null, o = e[1].replace(n.other.outputLinkReplace, "$1");
  r.state.inLink = !0;
  const l = {
    type: e[0].charAt(0) === "!" ? "image" : "link",
    raw: i,
    href: t,
    title: s,
    text: o,
    tokens: r.inlineTokens(o)
  };
  return r.state.inLink = !1, l;
}
function S0(e, a, i) {
  const r = e.match(i.other.indentCodeCompensation);
  if (r === null)
    return a;
  const n = r[1];
  return a.split(`
`).map((t) => {
    const s = t.match(i.other.beginningSpace);
    if (s === null)
      return t;
    const [o] = s;
    return o.length >= n.length ? t.slice(n.length) : t;
  }).join(`
`);
}
var ls = class {
  options;
  rules;
  // set by the lexer
  lexer;
  // set by the lexer
  constructor(e) {
    this.options = e || hn;
  }
  space(e) {
    const a = this.rules.block.newline.exec(e);
    if (a && a[0].length > 0)
      return {
        type: "space",
        raw: a[0]
      };
  }
  code(e) {
    const a = this.rules.block.code.exec(e);
    if (a) {
      const i = a[0].replace(this.rules.other.codeRemoveIndent, "");
      return {
        type: "code",
        raw: a[0],
        codeBlockStyle: "indented",
        text: this.options.pedantic ? i : ar(i, `
`)
      };
    }
  }
  fences(e) {
    const a = this.rules.block.fences.exec(e);
    if (a) {
      const i = a[0], r = S0(i, a[3] || "", this.rules);
      return {
        type: "code",
        raw: i,
        lang: a[2] ? a[2].trim().replace(this.rules.inline.anyPunctuation, "$1") : a[2],
        text: r
      };
    }
  }
  heading(e) {
    const a = this.rules.block.heading.exec(e);
    if (a) {
      let i = a[2].trim();
      if (this.rules.other.endingHash.test(i)) {
        const r = ar(i, "#");
        (this.options.pedantic || !r || this.rules.other.endingSpaceChar.test(r)) && (i = r.trim());
      }
      return {
        type: "heading",
        raw: a[0],
        depth: a[1].length,
        text: i,
        tokens: this.lexer.inline(i)
      };
    }
  }
  hr(e) {
    const a = this.rules.block.hr.exec(e);
    if (a)
      return {
        type: "hr",
        raw: ar(a[0], `
`)
      };
  }
  blockquote(e) {
    const a = this.rules.block.blockquote.exec(e);
    if (a) {
      let i = ar(a[0], `
`).split(`
`), r = "", n = "";
      const t = [];
      for (; i.length > 0; ) {
        let s = !1;
        const o = [];
        let l;
        for (l = 0; l < i.length; l++)
          if (this.rules.other.blockquoteStart.test(i[l]))
            o.push(i[l]), s = !0;
          else if (!s)
            o.push(i[l]);
          else
            break;
        i = i.slice(l);
        const u = o.join(`
`), c = u.replace(this.rules.other.blockquoteSetextReplace, `
    $1`).replace(this.rules.other.blockquoteSetextReplace2, "");
        r = r ? `${r}
${u}` : u, n = n ? `${n}
${c}` : c;
        const d = this.lexer.state.top;
        if (this.lexer.state.top = !0, this.lexer.blockTokens(c, t, !0), this.lexer.state.top = d, i.length === 0)
          break;
        const f = t.at(-1);
        if (f?.type === "code")
          break;
        if (f?.type === "blockquote") {
          const v = f, g = v.raw + `
` + i.join(`
`), h = this.blockquote(g);
          t[t.length - 1] = h, r = r.substring(0, r.length - v.raw.length) + h.raw, n = n.substring(0, n.length - v.text.length) + h.text;
          break;
        } else if (f?.type === "list") {
          const v = f, g = v.raw + `
` + i.join(`
`), h = this.list(g);
          t[t.length - 1] = h, r = r.substring(0, r.length - f.raw.length) + h.raw, n = n.substring(0, n.length - v.raw.length) + h.raw, i = g.substring(t.at(-1).raw.length).split(`
`);
          continue;
        }
      }
      return {
        type: "blockquote",
        raw: r,
        tokens: t,
        text: n
      };
    }
  }
  list(e) {
    let a = this.rules.block.list.exec(e);
    if (a) {
      let i = a[1].trim();
      const r = i.length > 1, n = {
        type: "list",
        raw: "",
        ordered: r,
        start: r ? +i.slice(0, -1) : "",
        loose: !1,
        items: []
      };
      i = r ? `\\d{1,9}\\${i.slice(-1)}` : `\\${i}`, this.options.pedantic && (i = r ? i : "[*+-]");
      const t = this.rules.other.listItemRegex(i);
      let s = !1;
      for (; e; ) {
        let l = !1, u = "", c = "";
        if (!(a = t.exec(e)) || this.rules.block.hr.test(e))
          break;
        u = a[0], e = e.substring(u.length);
        let d = a[2].split(`
`, 1)[0].replace(this.rules.other.listReplaceTabs, (m) => " ".repeat(3 * m.length)), f = e.split(`
`, 1)[0], v = !d.trim(), g = 0;
        if (this.options.pedantic ? (g = 2, c = d.trimStart()) : v ? g = a[1].length + 1 : (g = a[2].search(this.rules.other.nonSpaceChar), g = g > 4 ? 1 : g, c = d.slice(g), g += a[1].length), v && this.rules.other.blankLine.test(f) && (u += f + `
`, e = e.substring(f.length + 1), l = !0), !l) {
          const m = this.rules.other.nextBulletRegex(g), p = this.rules.other.hrRegex(g), b = this.rules.other.fencesBeginRegex(g), w = this.rules.other.headingBeginRegex(g), k = this.rules.other.htmlBeginRegex(g);
          for (; e; ) {
            const S = e.split(`
`, 1)[0];
            let _;
            if (f = S, this.options.pedantic ? (f = f.replace(this.rules.other.listReplaceNesting, "  "), _ = f) : _ = f.replace(this.rules.other.tabCharGlobal, "    "), b.test(f) || w.test(f) || k.test(f) || m.test(f) || p.test(f))
              break;
            if (_.search(this.rules.other.nonSpaceChar) >= g || !f.trim())
              c += `
` + _.slice(g);
            else {
              if (v || d.replace(this.rules.other.tabCharGlobal, "    ").search(this.rules.other.nonSpaceChar) >= 4 || b.test(d) || w.test(d) || p.test(d))
                break;
              c += `
` + f;
            }
            !v && !f.trim() && (v = !0), u += S + `
`, e = e.substring(S.length + 1), d = _.slice(g);
          }
        }
        n.loose || (s ? n.loose = !0 : this.rules.other.doubleBlankLine.test(u) && (s = !0));
        let h = null, y;
        this.options.gfm && (h = this.rules.other.listIsTask.exec(c), h && (y = h[0] !== "[ ] ", c = c.replace(this.rules.other.listReplaceTask, ""))), n.items.push({
          type: "list_item",
          raw: u,
          task: !!h,
          checked: y,
          loose: !1,
          text: c,
          tokens: []
        }), n.raw += u;
      }
      const o = n.items.at(-1);
      if (o)
        o.raw = o.raw.trimEnd(), o.text = o.text.trimEnd();
      else
        return;
      n.raw = n.raw.trimEnd();
      for (let l = 0; l < n.items.length; l++)
        if (this.lexer.state.top = !1, n.items[l].tokens = this.lexer.blockTokens(n.items[l].text, []), !n.loose) {
          const u = n.items[l].tokens.filter((d) => d.type === "space"), c = u.length > 0 && u.some((d) => this.rules.other.anyLine.test(d.raw));
          n.loose = c;
        }
      if (n.loose)
        for (let l = 0; l < n.items.length; l++)
          n.items[l].loose = !0;
      return n;
    }
  }
  html(e) {
    const a = this.rules.block.html.exec(e);
    if (a)
      return {
        type: "html",
        block: !0,
        raw: a[0],
        pre: a[1] === "pre" || a[1] === "script" || a[1] === "style",
        text: a[0]
      };
  }
  def(e) {
    const a = this.rules.block.def.exec(e);
    if (a) {
      const i = a[1].toLowerCase().replace(this.rules.other.multipleSpaceGlobal, " "), r = a[2] ? a[2].replace(this.rules.other.hrefBrackets, "$1").replace(this.rules.inline.anyPunctuation, "$1") : "", n = a[3] ? a[3].substring(1, a[3].length - 1).replace(this.rules.inline.anyPunctuation, "$1") : a[3];
      return {
        type: "def",
        tag: i,
        raw: a[0],
        href: r,
        title: n
      };
    }
  }
  table(e) {
    const a = this.rules.block.table.exec(e);
    if (!a || !this.rules.other.tableDelimiter.test(a[2]))
      return;
    const i = kf(a[1]), r = a[2].replace(this.rules.other.tableAlignChars, "").split("|"), n = a[3]?.trim() ? a[3].replace(this.rules.other.tableRowBlankLine, "").split(`
`) : [], t = {
      type: "table",
      raw: a[0],
      header: [],
      align: [],
      rows: []
    };
    if (i.length === r.length) {
      for (const s of r)
        this.rules.other.tableAlignRight.test(s) ? t.align.push("right") : this.rules.other.tableAlignCenter.test(s) ? t.align.push("center") : this.rules.other.tableAlignLeft.test(s) ? t.align.push("left") : t.align.push(null);
      for (let s = 0; s < i.length; s++)
        t.header.push({
          text: i[s],
          tokens: this.lexer.inline(i[s]),
          header: !0,
          align: t.align[s]
        });
      for (const s of n)
        t.rows.push(kf(s, t.header.length).map((o, l) => ({
          text: o,
          tokens: this.lexer.inline(o),
          header: !1,
          align: t.align[l]
        })));
      return t;
    }
  }
  lheading(e) {
    const a = this.rules.block.lheading.exec(e);
    if (a)
      return {
        type: "heading",
        raw: a[0],
        depth: a[2].charAt(0) === "=" ? 1 : 2,
        text: a[1],
        tokens: this.lexer.inline(a[1])
      };
  }
  paragraph(e) {
    const a = this.rules.block.paragraph.exec(e);
    if (a) {
      const i = a[1].charAt(a[1].length - 1) === `
` ? a[1].slice(0, -1) : a[1];
      return {
        type: "paragraph",
        raw: a[0],
        text: i,
        tokens: this.lexer.inline(i)
      };
    }
  }
  text(e) {
    const a = this.rules.block.text.exec(e);
    if (a)
      return {
        type: "text",
        raw: a[0],
        text: a[0],
        tokens: this.lexer.inline(a[0])
      };
  }
  escape(e) {
    const a = this.rules.inline.escape.exec(e);
    if (a)
      return {
        type: "escape",
        raw: a[0],
        text: a[1]
      };
  }
  tag(e) {
    const a = this.rules.inline.tag.exec(e);
    if (a)
      return !this.lexer.state.inLink && this.rules.other.startATag.test(a[0]) ? this.lexer.state.inLink = !0 : this.lexer.state.inLink && this.rules.other.endATag.test(a[0]) && (this.lexer.state.inLink = !1), !this.lexer.state.inRawBlock && this.rules.other.startPreScriptTag.test(a[0]) ? this.lexer.state.inRawBlock = !0 : this.lexer.state.inRawBlock && this.rules.other.endPreScriptTag.test(a[0]) && (this.lexer.state.inRawBlock = !1), {
        type: "html",
        raw: a[0],
        inLink: this.lexer.state.inLink,
        inRawBlock: this.lexer.state.inRawBlock,
        block: !1,
        text: a[0]
      };
  }
  link(e) {
    const a = this.rules.inline.link.exec(e);
    if (a) {
      const i = a[2].trim();
      if (!this.options.pedantic && this.rules.other.startAngleBracket.test(i)) {
        if (!this.rules.other.endAngleBracket.test(i))
          return;
        const t = ar(i.slice(0, -1), "\\");
        if ((i.length - t.length) % 2 === 0)
          return;
      } else {
        const t = w0(a[2], "()");
        if (t === -2)
          return;
        if (t > -1) {
          const o = (a[0].indexOf("!") === 0 ? 5 : 4) + a[1].length + t;
          a[2] = a[2].substring(0, t), a[0] = a[0].substring(0, o).trim(), a[3] = "";
        }
      }
      let r = a[2], n = "";
      if (this.options.pedantic) {
        const t = this.rules.other.pedanticHrefTitle.exec(r);
        t && (r = t[1], n = t[3]);
      } else
        n = a[3] ? a[3].slice(1, -1) : "";
      return r = r.trim(), this.rules.other.startAngleBracket.test(r) && (this.options.pedantic && !this.rules.other.endAngleBracket.test(i) ? r = r.slice(1) : r = r.slice(1, -1)), wf(a, {
        href: r && r.replace(this.rules.inline.anyPunctuation, "$1"),
        title: n && n.replace(this.rules.inline.anyPunctuation, "$1")
      }, a[0], this.lexer, this.rules);
    }
  }
  reflink(e, a) {
    let i;
    if ((i = this.rules.inline.reflink.exec(e)) || (i = this.rules.inline.nolink.exec(e))) {
      const r = (i[2] || i[1]).replace(this.rules.other.multipleSpaceGlobal, " "), n = a[r.toLowerCase()];
      if (!n) {
        const t = i[0].charAt(0);
        return {
          type: "text",
          raw: t,
          text: t
        };
      }
      return wf(i, n, i[0], this.lexer, this.rules);
    }
  }
  emStrong(e, a, i = "") {
    let r = this.rules.inline.emStrongLDelim.exec(e);
    if (!r || r[3] && i.match(this.rules.other.unicodeAlphaNumeric)) return;
    if (!(r[1] || r[2] || "") || !i || this.rules.inline.punctuation.exec(i)) {
      const t = [...r[0]].length - 1;
      let s, o, l = t, u = 0;
      const c = r[0][0] === "*" ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;
      for (c.lastIndex = 0, a = a.slice(-1 * e.length + t); (r = c.exec(a)) != null; ) {
        if (s = r[1] || r[2] || r[3] || r[4] || r[5] || r[6], !s) continue;
        if (o = [...s].length, r[3] || r[4]) {
          l += o;
          continue;
        } else if ((r[5] || r[6]) && t % 3 && !((t + o) % 3)) {
          u += o;
          continue;
        }
        if (l -= o, l > 0) continue;
        o = Math.min(o, o + l + u);
        const d = [...r[0]][0].length, f = e.slice(0, t + r.index + d + o);
        if (Math.min(t, o) % 2) {
          const g = f.slice(1, -1);
          return {
            type: "em",
            raw: f,
            text: g,
            tokens: this.lexer.inlineTokens(g)
          };
        }
        const v = f.slice(2, -2);
        return {
          type: "strong",
          raw: f,
          text: v,
          tokens: this.lexer.inlineTokens(v)
        };
      }
    }
  }
  codespan(e) {
    const a = this.rules.inline.code.exec(e);
    if (a) {
      let i = a[2].replace(this.rules.other.newLineCharGlobal, " ");
      const r = this.rules.other.nonSpaceChar.test(i), n = this.rules.other.startingSpaceChar.test(i) && this.rules.other.endingSpaceChar.test(i);
      return r && n && (i = i.substring(1, i.length - 1)), {
        type: "codespan",
        raw: a[0],
        text: i
      };
    }
  }
  br(e) {
    const a = this.rules.inline.br.exec(e);
    if (a)
      return {
        type: "br",
        raw: a[0]
      };
  }
  del(e) {
    const a = this.rules.inline.del.exec(e);
    if (a)
      return {
        type: "del",
        raw: a[0],
        text: a[2],
        tokens: this.lexer.inlineTokens(a[2])
      };
  }
  autolink(e) {
    const a = this.rules.inline.autolink.exec(e);
    if (a) {
      let i, r;
      return a[2] === "@" ? (i = a[1], r = "mailto:" + i) : (i = a[1], r = i), {
        type: "link",
        raw: a[0],
        text: i,
        href: r,
        tokens: [
          {
            type: "text",
            raw: i,
            text: i
          }
        ]
      };
    }
  }
  url(e) {
    let a;
    if (a = this.rules.inline.url.exec(e)) {
      let i, r;
      if (a[2] === "@")
        i = a[0], r = "mailto:" + i;
      else {
        let n;
        do
          n = a[0], a[0] = this.rules.inline._backpedal.exec(a[0])?.[0] ?? "";
        while (n !== a[0]);
        i = a[0], a[1] === "www." ? r = "http://" + a[0] : r = a[0];
      }
      return {
        type: "link",
        raw: a[0],
        text: i,
        href: r,
        tokens: [
          {
            type: "text",
            raw: i,
            text: i
          }
        ]
      };
    }
  }
  inlineText(e) {
    const a = this.rules.inline.text.exec(e);
    if (a) {
      const i = this.lexer.state.inRawBlock;
      return {
        type: "text",
        raw: a[0],
        text: a[0],
        escaped: i
      };
    }
  }
}, Ca = class co {
  tokens;
  options;
  state;
  tokenizer;
  inlineQueue;
  constructor(a) {
    this.tokens = [], this.tokens.links = /* @__PURE__ */ Object.create(null), this.options = a || hn, this.options.tokenizer = this.options.tokenizer || new ls(), this.tokenizer = this.options.tokenizer, this.tokenizer.options = this.options, this.tokenizer.lexer = this, this.inlineQueue = [], this.state = {
      inLink: !1,
      inRawBlock: !1,
      top: !0
    };
    const i = {
      other: Ot,
      block: Bi.normal,
      inline: tr.normal
    };
    this.options.pedantic ? (i.block = Bi.pedantic, i.inline = tr.pedantic) : this.options.gfm && (i.block = Bi.gfm, this.options.breaks ? i.inline = tr.breaks : i.inline = tr.gfm), this.tokenizer.rules = i;
  }
  /**
   * Expose Rules
   */
  static get rules() {
    return {
      block: Bi,
      inline: tr
    };
  }
  /**
   * Static Lex Method
   */
  static lex(a, i) {
    return new co(i).lex(a);
  }
  /**
   * Static Lex Inline Method
   */
  static lexInline(a, i) {
    return new co(i).inlineTokens(a);
  }
  /**
   * Preprocessing
   */
  lex(a) {
    a = a.replace(Ot.carriageReturn, `
`), this.blockTokens(a, this.tokens);
    for (let i = 0; i < this.inlineQueue.length; i++) {
      const r = this.inlineQueue[i];
      this.inlineTokens(r.src, r.tokens);
    }
    return this.inlineQueue = [], this.tokens;
  }
  blockTokens(a, i = [], r = !1) {
    for (this.options.pedantic && (a = a.replace(Ot.tabCharGlobal, "    ").replace(Ot.spaceLine, "")); a; ) {
      let n;
      if (this.options.extensions?.block?.some((s) => (n = s.call({ lexer: this }, a, i)) ? (a = a.substring(n.raw.length), i.push(n), !0) : !1))
        continue;
      if (n = this.tokenizer.space(a)) {
        a = a.substring(n.raw.length);
        const s = i.at(-1);
        n.raw.length === 1 && s !== void 0 ? s.raw += `
` : i.push(n);
        continue;
      }
      if (n = this.tokenizer.code(a)) {
        a = a.substring(n.raw.length);
        const s = i.at(-1);
        s?.type === "paragraph" || s?.type === "text" ? (s.raw += `
` + n.raw, s.text += `
` + n.text, this.inlineQueue.at(-1).src = s.text) : i.push(n);
        continue;
      }
      if (n = this.tokenizer.fences(a)) {
        a = a.substring(n.raw.length), i.push(n);
        continue;
      }
      if (n = this.tokenizer.heading(a)) {
        a = a.substring(n.raw.length), i.push(n);
        continue;
      }
      if (n = this.tokenizer.hr(a)) {
        a = a.substring(n.raw.length), i.push(n);
        continue;
      }
      if (n = this.tokenizer.blockquote(a)) {
        a = a.substring(n.raw.length), i.push(n);
        continue;
      }
      if (n = this.tokenizer.list(a)) {
        a = a.substring(n.raw.length), i.push(n);
        continue;
      }
      if (n = this.tokenizer.html(a)) {
        a = a.substring(n.raw.length), i.push(n);
        continue;
      }
      if (n = this.tokenizer.def(a)) {
        a = a.substring(n.raw.length);
        const s = i.at(-1);
        s?.type === "paragraph" || s?.type === "text" ? (s.raw += `
` + n.raw, s.text += `
` + n.raw, this.inlineQueue.at(-1).src = s.text) : this.tokens.links[n.tag] || (this.tokens.links[n.tag] = {
          href: n.href,
          title: n.title
        });
        continue;
      }
      if (n = this.tokenizer.table(a)) {
        a = a.substring(n.raw.length), i.push(n);
        continue;
      }
      if (n = this.tokenizer.lheading(a)) {
        a = a.substring(n.raw.length), i.push(n);
        continue;
      }
      let t = a;
      if (this.options.extensions?.startBlock) {
        let s = 1 / 0;
        const o = a.slice(1);
        let l;
        this.options.extensions.startBlock.forEach((u) => {
          l = u.call({ lexer: this }, o), typeof l == "number" && l >= 0 && (s = Math.min(s, l));
        }), s < 1 / 0 && s >= 0 && (t = a.substring(0, s + 1));
      }
      if (this.state.top && (n = this.tokenizer.paragraph(t))) {
        const s = i.at(-1);
        r && s?.type === "paragraph" ? (s.raw += `
` + n.raw, s.text += `
` + n.text, this.inlineQueue.pop(), this.inlineQueue.at(-1).src = s.text) : i.push(n), r = t.length !== a.length, a = a.substring(n.raw.length);
        continue;
      }
      if (n = this.tokenizer.text(a)) {
        a = a.substring(n.raw.length);
        const s = i.at(-1);
        s?.type === "text" ? (s.raw += `
` + n.raw, s.text += `
` + n.text, this.inlineQueue.pop(), this.inlineQueue.at(-1).src = s.text) : i.push(n);
        continue;
      }
      if (a) {
        const s = "Infinite loop on byte: " + a.charCodeAt(0);
        if (this.options.silent) {
          console.error(s);
          break;
        } else
          throw new Error(s);
      }
    }
    return this.state.top = !0, i;
  }
  inline(a, i = []) {
    return this.inlineQueue.push({ src: a, tokens: i }), i;
  }
  /**
   * Lexing/Compiling
   */
  inlineTokens(a, i = []) {
    let r = a, n = null;
    if (this.tokens.links) {
      const o = Object.keys(this.tokens.links);
      if (o.length > 0)
        for (; (n = this.tokenizer.rules.inline.reflinkSearch.exec(r)) != null; )
          o.includes(n[0].slice(n[0].lastIndexOf("[") + 1, -1)) && (r = r.slice(0, n.index) + "[" + "a".repeat(n[0].length - 2) + "]" + r.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex));
    }
    for (; (n = this.tokenizer.rules.inline.anyPunctuation.exec(r)) != null; )
      r = r.slice(0, n.index) + "++" + r.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);
    for (; (n = this.tokenizer.rules.inline.blockSkip.exec(r)) != null; )
      r = r.slice(0, n.index) + "[" + "a".repeat(n[0].length - 2) + "]" + r.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
    let t = !1, s = "";
    for (; a; ) {
      t || (s = ""), t = !1;
      let o;
      if (this.options.extensions?.inline?.some((u) => (o = u.call({ lexer: this }, a, i)) ? (a = a.substring(o.raw.length), i.push(o), !0) : !1))
        continue;
      if (o = this.tokenizer.escape(a)) {
        a = a.substring(o.raw.length), i.push(o);
        continue;
      }
      if (o = this.tokenizer.tag(a)) {
        a = a.substring(o.raw.length), i.push(o);
        continue;
      }
      if (o = this.tokenizer.link(a)) {
        a = a.substring(o.raw.length), i.push(o);
        continue;
      }
      if (o = this.tokenizer.reflink(a, this.tokens.links)) {
        a = a.substring(o.raw.length);
        const u = i.at(-1);
        o.type === "text" && u?.type === "text" ? (u.raw += o.raw, u.text += o.text) : i.push(o);
        continue;
      }
      if (o = this.tokenizer.emStrong(a, r, s)) {
        a = a.substring(o.raw.length), i.push(o);
        continue;
      }
      if (o = this.tokenizer.codespan(a)) {
        a = a.substring(o.raw.length), i.push(o);
        continue;
      }
      if (o = this.tokenizer.br(a)) {
        a = a.substring(o.raw.length), i.push(o);
        continue;
      }
      if (o = this.tokenizer.del(a)) {
        a = a.substring(o.raw.length), i.push(o);
        continue;
      }
      if (o = this.tokenizer.autolink(a)) {
        a = a.substring(o.raw.length), i.push(o);
        continue;
      }
      if (!this.state.inLink && (o = this.tokenizer.url(a))) {
        a = a.substring(o.raw.length), i.push(o);
        continue;
      }
      let l = a;
      if (this.options.extensions?.startInline) {
        let u = 1 / 0;
        const c = a.slice(1);
        let d;
        this.options.extensions.startInline.forEach((f) => {
          d = f.call({ lexer: this }, c), typeof d == "number" && d >= 0 && (u = Math.min(u, d));
        }), u < 1 / 0 && u >= 0 && (l = a.substring(0, u + 1));
      }
      if (o = this.tokenizer.inlineText(l)) {
        a = a.substring(o.raw.length), o.raw.slice(-1) !== "_" && (s = o.raw.slice(-1)), t = !0;
        const u = i.at(-1);
        u?.type === "text" ? (u.raw += o.raw, u.text += o.text) : i.push(o);
        continue;
      }
      if (a) {
        const u = "Infinite loop on byte: " + a.charCodeAt(0);
        if (this.options.silent) {
          console.error(u);
          break;
        } else
          throw new Error(u);
      }
    }
    return i;
  }
}, os = class {
  options;
  parser;
  // set by the parser
  constructor(e) {
    this.options = e || hn;
  }
  space(e) {
    return "";
  }
  code({ text: e, lang: a, escaped: i }) {
    const r = (a || "").match(Ot.notSpaceStart)?.[0], n = e.replace(Ot.endingNewline, "") + `
`;
    return r ? '<pre><code class="language-' + ma(r) + '">' + (i ? n : ma(n, !0)) + `</code></pre>
` : "<pre><code>" + (i ? n : ma(n, !0)) + `</code></pre>
`;
  }
  blockquote({ tokens: e }) {
    return `<blockquote>
${this.parser.parse(e)}</blockquote>
`;
  }
  html({ text: e }) {
    return e;
  }
  heading({ tokens: e, depth: a }) {
    return `<h${a}>${this.parser.parseInline(e)}</h${a}>
`;
  }
  hr(e) {
    return `<hr>
`;
  }
  list(e) {
    const a = e.ordered, i = e.start;
    let r = "";
    for (let s = 0; s < e.items.length; s++) {
      const o = e.items[s];
      r += this.listitem(o);
    }
    const n = a ? "ol" : "ul", t = a && i !== 1 ? ' start="' + i + '"' : "";
    return "<" + n + t + `>
` + r + "</" + n + `>
`;
  }
  listitem(e) {
    let a = "";
    if (e.task) {
      const i = this.checkbox({ checked: !!e.checked });
      e.loose ? e.tokens[0]?.type === "paragraph" ? (e.tokens[0].text = i + " " + e.tokens[0].text, e.tokens[0].tokens && e.tokens[0].tokens.length > 0 && e.tokens[0].tokens[0].type === "text" && (e.tokens[0].tokens[0].text = i + " " + ma(e.tokens[0].tokens[0].text), e.tokens[0].tokens[0].escaped = !0)) : e.tokens.unshift({
        type: "text",
        raw: i + " ",
        text: i + " ",
        escaped: !0
      }) : a += i + " ";
    }
    return a += this.parser.parse(e.tokens, !!e.loose), `<li>${a}</li>
`;
  }
  checkbox({ checked: e }) {
    return "<input " + (e ? 'checked="" ' : "") + 'disabled="" type="checkbox">';
  }
  paragraph({ tokens: e }) {
    return `<p>${this.parser.parseInline(e)}</p>
`;
  }
  table(e) {
    let a = "", i = "";
    for (let n = 0; n < e.header.length; n++)
      i += this.tablecell(e.header[n]);
    a += this.tablerow({ text: i });
    let r = "";
    for (let n = 0; n < e.rows.length; n++) {
      const t = e.rows[n];
      i = "";
      for (let s = 0; s < t.length; s++)
        i += this.tablecell(t[s]);
      r += this.tablerow({ text: i });
    }
    return r && (r = `<tbody>${r}</tbody>`), `<table>
<thead>
` + a + `</thead>
` + r + `</table>
`;
  }
  tablerow({ text: e }) {
    return `<tr>
${e}</tr>
`;
  }
  tablecell(e) {
    const a = this.parser.parseInline(e.tokens), i = e.header ? "th" : "td";
    return (e.align ? `<${i} align="${e.align}">` : `<${i}>`) + a + `</${i}>
`;
  }
  /**
   * span level renderer
   */
  strong({ tokens: e }) {
    return `<strong>${this.parser.parseInline(e)}</strong>`;
  }
  em({ tokens: e }) {
    return `<em>${this.parser.parseInline(e)}</em>`;
  }
  codespan({ text: e }) {
    return `<code>${ma(e, !0)}</code>`;
  }
  br(e) {
    return "<br>";
  }
  del({ tokens: e }) {
    return `<del>${this.parser.parseInline(e)}</del>`;
  }
  link({ href: e, title: a, tokens: i }) {
    const r = this.parser.parseInline(i), n = bf(e);
    if (n === null)
      return r;
    e = n;
    let t = '<a href="' + e + '"';
    return a && (t += ' title="' + ma(a) + '"'), t += ">" + r + "</a>", t;
  }
  image({ href: e, title: a, text: i, tokens: r }) {
    r && (i = this.parser.parseInline(r, this.parser.textRenderer));
    const n = bf(e);
    if (n === null)
      return ma(i);
    e = n;
    let t = `<img src="${e}" alt="${i}"`;
    return a && (t += ` title="${ma(a)}"`), t += ">", t;
  }
  text(e) {
    return "tokens" in e && e.tokens ? this.parser.parseInline(e.tokens) : "escaped" in e && e.escaped ? e.text : ma(e.text);
  }
}, uu = class {
  // no need for block level renderers
  strong({ text: e }) {
    return e;
  }
  em({ text: e }) {
    return e;
  }
  codespan({ text: e }) {
    return e;
  }
  del({ text: e }) {
    return e;
  }
  html({ text: e }) {
    return e;
  }
  text({ text: e }) {
    return e;
  }
  link({ text: e }) {
    return "" + e;
  }
  image({ text: e }) {
    return "" + e;
  }
  br() {
    return "";
  }
}, xa = class fo {
  options;
  renderer;
  textRenderer;
  constructor(a) {
    this.options = a || hn, this.options.renderer = this.options.renderer || new os(), this.renderer = this.options.renderer, this.renderer.options = this.options, this.renderer.parser = this, this.textRenderer = new uu();
  }
  /**
   * Static Parse Method
   */
  static parse(a, i) {
    return new fo(i).parse(a);
  }
  /**
   * Static Parse Inline Method
   */
  static parseInline(a, i) {
    return new fo(i).parseInline(a);
  }
  /**
   * Parse Loop
   */
  parse(a, i = !0) {
    let r = "";
    for (let n = 0; n < a.length; n++) {
      const t = a[n];
      if (this.options.extensions?.renderers?.[t.type]) {
        const o = t, l = this.options.extensions.renderers[o.type].call({ parser: this }, o);
        if (l !== !1 || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "paragraph", "text"].includes(o.type)) {
          r += l || "";
          continue;
        }
      }
      const s = t;
      switch (s.type) {
        case "space": {
          r += this.renderer.space(s);
          continue;
        }
        case "hr": {
          r += this.renderer.hr(s);
          continue;
        }
        case "heading": {
          r += this.renderer.heading(s);
          continue;
        }
        case "code": {
          r += this.renderer.code(s);
          continue;
        }
        case "table": {
          r += this.renderer.table(s);
          continue;
        }
        case "blockquote": {
          r += this.renderer.blockquote(s);
          continue;
        }
        case "list": {
          r += this.renderer.list(s);
          continue;
        }
        case "html": {
          r += this.renderer.html(s);
          continue;
        }
        case "paragraph": {
          r += this.renderer.paragraph(s);
          continue;
        }
        case "text": {
          let o = s, l = this.renderer.text(o);
          for (; n + 1 < a.length && a[n + 1].type === "text"; )
            o = a[++n], l += `
` + this.renderer.text(o);
          i ? r += this.renderer.paragraph({
            type: "paragraph",
            raw: l,
            text: l,
            tokens: [{ type: "text", raw: l, text: l, escaped: !0 }]
          }) : r += l;
          continue;
        }
        default: {
          const o = 'Token with "' + s.type + '" type was not found.';
          if (this.options.silent)
            return console.error(o), "";
          throw new Error(o);
        }
      }
    }
    return r;
  }
  /**
   * Parse Inline Tokens
   */
  parseInline(a, i = this.renderer) {
    let r = "";
    for (let n = 0; n < a.length; n++) {
      const t = a[n];
      if (this.options.extensions?.renderers?.[t.type]) {
        const o = this.options.extensions.renderers[t.type].call({ parser: this }, t);
        if (o !== !1 || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(t.type)) {
          r += o || "";
          continue;
        }
      }
      const s = t;
      switch (s.type) {
        case "escape": {
          r += i.text(s);
          break;
        }
        case "html": {
          r += i.html(s);
          break;
        }
        case "link": {
          r += i.link(s);
          break;
        }
        case "image": {
          r += i.image(s);
          break;
        }
        case "strong": {
          r += i.strong(s);
          break;
        }
        case "em": {
          r += i.em(s);
          break;
        }
        case "codespan": {
          r += i.codespan(s);
          break;
        }
        case "br": {
          r += i.br(s);
          break;
        }
        case "del": {
          r += i.del(s);
          break;
        }
        case "text": {
          r += i.text(s);
          break;
        }
        default: {
          const o = 'Token with "' + s.type + '" type was not found.';
          if (this.options.silent)
            return console.error(o), "";
          throw new Error(o);
        }
      }
    }
    return r;
  }
}, Qi = class {
  options;
  block;
  constructor(e) {
    this.options = e || hn;
  }
  static passThroughHooks = /* @__PURE__ */ new Set([
    "preprocess",
    "postprocess",
    "processAllTokens"
  ]);
  /**
   * Process markdown before marked
   */
  preprocess(e) {
    return e;
  }
  /**
   * Process HTML after marked is finished
   */
  postprocess(e) {
    return e;
  }
  /**
   * Process all tokens before walk tokens
   */
  processAllTokens(e) {
    return e;
  }
  /**
   * Provide function to tokenize markdown
   */
  provideLexer() {
    return this.block ? Ca.lex : Ca.lexInline;
  }
  /**
   * Provide function to parse tokens
   */
  provideParser() {
    return this.block ? xa.parse : xa.parseInline;
  }
}, $0 = class {
  defaults = tu();
  options = this.setOptions;
  parse = this.parseMarkdown(!0);
  parseInline = this.parseMarkdown(!1);
  Parser = xa;
  Renderer = os;
  TextRenderer = uu;
  Lexer = Ca;
  Tokenizer = ls;
  Hooks = Qi;
  constructor(...e) {
    this.use(...e);
  }
  /**
   * Run callback for every token
   */
  walkTokens(e, a) {
    let i = [];
    for (const r of e)
      switch (i = i.concat(a.call(this, r)), r.type) {
        case "table": {
          const n = r;
          for (const t of n.header)
            i = i.concat(this.walkTokens(t.tokens, a));
          for (const t of n.rows)
            for (const s of t)
              i = i.concat(this.walkTokens(s.tokens, a));
          break;
        }
        case "list": {
          const n = r;
          i = i.concat(this.walkTokens(n.items, a));
          break;
        }
        default: {
          const n = r;
          this.defaults.extensions?.childTokens?.[n.type] ? this.defaults.extensions.childTokens[n.type].forEach((t) => {
            const s = n[t].flat(1 / 0);
            i = i.concat(this.walkTokens(s, a));
          }) : n.tokens && (i = i.concat(this.walkTokens(n.tokens, a)));
        }
      }
    return i;
  }
  use(...e) {
    const a = this.defaults.extensions || { renderers: {}, childTokens: {} };
    return e.forEach((i) => {
      const r = { ...i };
      if (r.async = this.defaults.async || r.async || !1, i.extensions && (i.extensions.forEach((n) => {
        if (!n.name)
          throw new Error("extension name required");
        if ("renderer" in n) {
          const t = a.renderers[n.name];
          t ? a.renderers[n.name] = function(...s) {
            let o = n.renderer.apply(this, s);
            return o === !1 && (o = t.apply(this, s)), o;
          } : a.renderers[n.name] = n.renderer;
        }
        if ("tokenizer" in n) {
          if (!n.level || n.level !== "block" && n.level !== "inline")
            throw new Error("extension level must be 'block' or 'inline'");
          const t = a[n.level];
          t ? t.unshift(n.tokenizer) : a[n.level] = [n.tokenizer], n.start && (n.level === "block" ? a.startBlock ? a.startBlock.push(n.start) : a.startBlock = [n.start] : n.level === "inline" && (a.startInline ? a.startInline.push(n.start) : a.startInline = [n.start]));
        }
        "childTokens" in n && n.childTokens && (a.childTokens[n.name] = n.childTokens);
      }), r.extensions = a), i.renderer) {
        const n = this.defaults.renderer || new os(this.defaults);
        for (const t in i.renderer) {
          if (!(t in n))
            throw new Error(`renderer '${t}' does not exist`);
          if (["options", "parser"].includes(t))
            continue;
          const s = t, o = i.renderer[s], l = n[s];
          n[s] = (...u) => {
            let c = o.apply(n, u);
            return c === !1 && (c = l.apply(n, u)), c || "";
          };
        }
        r.renderer = n;
      }
      if (i.tokenizer) {
        const n = this.defaults.tokenizer || new ls(this.defaults);
        for (const t in i.tokenizer) {
          if (!(t in n))
            throw new Error(`tokenizer '${t}' does not exist`);
          if (["options", "rules", "lexer"].includes(t))
            continue;
          const s = t, o = i.tokenizer[s], l = n[s];
          n[s] = (...u) => {
            let c = o.apply(n, u);
            return c === !1 && (c = l.apply(n, u)), c;
          };
        }
        r.tokenizer = n;
      }
      if (i.hooks) {
        const n = this.defaults.hooks || new Qi();
        for (const t in i.hooks) {
          if (!(t in n))
            throw new Error(`hook '${t}' does not exist`);
          if (["options", "block"].includes(t))
            continue;
          const s = t, o = i.hooks[s], l = n[s];
          Qi.passThroughHooks.has(t) ? n[s] = (u) => {
            if (this.defaults.async)
              return Promise.resolve(o.call(n, u)).then((d) => l.call(n, d));
            const c = o.call(n, u);
            return l.call(n, c);
          } : n[s] = (...u) => {
            let c = o.apply(n, u);
            return c === !1 && (c = l.apply(n, u)), c;
          };
        }
        r.hooks = n;
      }
      if (i.walkTokens) {
        const n = this.defaults.walkTokens, t = i.walkTokens;
        r.walkTokens = function(s) {
          let o = [];
          return o.push(t.call(this, s)), n && (o = o.concat(n.call(this, s))), o;
        };
      }
      this.defaults = { ...this.defaults, ...r };
    }), this;
  }
  setOptions(e) {
    return this.defaults = { ...this.defaults, ...e }, this;
  }
  lexer(e, a) {
    return Ca.lex(e, a ?? this.defaults);
  }
  parser(e, a) {
    return xa.parse(e, a ?? this.defaults);
  }
  parseMarkdown(e) {
    return (i, r) => {
      const n = { ...r }, t = { ...this.defaults, ...n }, s = this.onError(!!t.silent, !!t.async);
      if (this.defaults.async === !0 && n.async === !1)
        return s(new Error("marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise."));
      if (typeof i > "u" || i === null)
        return s(new Error("marked(): input parameter is undefined or null"));
      if (typeof i != "string")
        return s(new Error("marked(): input parameter is of type " + Object.prototype.toString.call(i) + ", string expected"));
      t.hooks && (t.hooks.options = t, t.hooks.block = e);
      const o = t.hooks ? t.hooks.provideLexer() : e ? Ca.lex : Ca.lexInline, l = t.hooks ? t.hooks.provideParser() : e ? xa.parse : xa.parseInline;
      if (t.async)
        return Promise.resolve(t.hooks ? t.hooks.preprocess(i) : i).then((u) => o(u, t)).then((u) => t.hooks ? t.hooks.processAllTokens(u) : u).then((u) => t.walkTokens ? Promise.all(this.walkTokens(u, t.walkTokens)).then(() => u) : u).then((u) => l(u, t)).then((u) => t.hooks ? t.hooks.postprocess(u) : u).catch(s);
      try {
        t.hooks && (i = t.hooks.preprocess(i));
        let u = o(i, t);
        t.hooks && (u = t.hooks.processAllTokens(u)), t.walkTokens && this.walkTokens(u, t.walkTokens);
        let c = l(u, t);
        return t.hooks && (c = t.hooks.postprocess(c)), c;
      } catch (u) {
        return s(u);
      }
    };
  }
  onError(e, a) {
    return (i) => {
      if (i.message += `
Please report this to https://github.com/markedjs/marked.`, e) {
        const r = "<p>An error occurred:</p><pre>" + ma(i.message + "", !0) + "</pre>";
        return a ? Promise.resolve(r) : r;
      }
      if (a)
        return Promise.reject(i);
      throw i;
    };
  }
}, ln = new $0();
function We(e, a) {
  return ln.parse(e, a);
}
We.options = We.setOptions = function(e) {
  return ln.setOptions(e), We.defaults = ln.defaults, yv(We.defaults), We;
};
We.getDefaults = tu;
We.defaults = hn;
We.use = function(...e) {
  return ln.use(...e), We.defaults = ln.defaults, yv(We.defaults), We;
};
We.walkTokens = function(e, a) {
  return ln.walkTokens(e, a);
};
We.parseInline = ln.parseInline;
We.Parser = xa;
We.parser = xa.parse;
We.Renderer = os;
We.TextRenderer = uu;
We.Lexer = Ca;
We.lexer = Ca.lex;
We.Tokenizer = ls;
We.Hooks = Qi;
We.parse = We;
We.options;
We.setOptions;
We.use;
We.walkTokens;
We.parseInline;
xa.parse;
Ca.lex;
var Er = {}, Vv = /* @__PURE__ */ Symbol.for("immer-nothing"), Sf = /* @__PURE__ */ Symbol.for("immer-draftable"), Ft = /* @__PURE__ */ Symbol.for("immer-state"), _0 = Er.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(e) {
    return `The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`;
  },
  function(e) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`;
  },
  "This object has been frozen and should not be mutated",
  function(e) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(e) {
    return `'current' expects a draft, got: ${e}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(e) {
    return `'original' expects a draft, got: ${e}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function jt(e, ...a) {
  if (Er.NODE_ENV !== "production") {
    const i = _0[e], r = typeof i == "function" ? i.apply(null, a) : i;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var mr = Object.getPrototypeOf;
function En(e) {
  return !!e && !!e[Ft];
}
function on(e) {
  return e ? Iv(e) || Array.isArray(e) || !!e[Sf] || !!e.constructor?.[Sf] || Ar(e) || js(e) : !1;
}
var P0 = Object.prototype.constructor.toString(), $f = /* @__PURE__ */ new WeakMap();
function Iv(e) {
  if (!e || typeof e != "object")
    return !1;
  const a = Object.getPrototypeOf(e);
  if (a === null || a === Object.prototype)
    return !0;
  const i = Object.hasOwnProperty.call(a, "constructor") && a.constructor;
  if (i === Object)
    return !0;
  if (typeof i != "function")
    return !1;
  let r = $f.get(i);
  return r === void 0 && (r = Function.toString.call(i), $f.set(i, r)), r === P0;
}
function us(e, a, i = !0) {
  Ts(e) === 0 ? (i ? Reflect.ownKeys(e) : Object.keys(e)).forEach((n) => {
    a(n, e[n], e);
  }) : e.forEach((r, n) => a(n, r, e));
}
function Ts(e) {
  const a = e[Ft];
  return a ? a.type_ : Array.isArray(e) ? 1 : Ar(e) ? 2 : js(e) ? 3 : 0;
}
function mo(e, a) {
  return Ts(e) === 2 ? e.has(a) : Object.prototype.hasOwnProperty.call(e, a);
}
function Ov(e, a, i) {
  const r = Ts(e);
  r === 2 ? e.set(a, i) : r === 3 ? e.add(i) : e[a] = i;
}
function C0(e, a) {
  return e === a ? e !== 0 || 1 / e === 1 / a : e !== e && a !== a;
}
function Ar(e) {
  return e instanceof Map;
}
function js(e) {
  return e instanceof Set;
}
function Za(e) {
  return e.copy_ || e.base_;
}
function vo(e, a) {
  if (Ar(e))
    return new Map(e);
  if (js(e))
    return new Set(e);
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  const i = Iv(e);
  if (a === !0 || a === "class_only" && !i) {
    const r = Object.getOwnPropertyDescriptors(e);
    delete r[Ft];
    let n = Reflect.ownKeys(r);
    for (let t = 0; t < n.length; t++) {
      const s = n[t], o = r[s];
      o.writable === !1 && (o.writable = !0, o.configurable = !0), (o.get || o.set) && (r[s] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: o.enumerable,
        value: e[s]
      });
    }
    return Object.create(mr(e), r);
  } else {
    const r = mr(e);
    if (r !== null && i)
      return { ...e };
    const n = Object.create(r);
    return Object.assign(n, e);
  }
}
function cu(e, a = !1) {
  return Ds(e) || En(e) || !on(e) || (Ts(e) > 1 && Object.defineProperties(e, {
    set: Fi,
    add: Fi,
    clear: Fi,
    delete: Fi
  }), Object.freeze(e), a && Object.values(e).forEach((i) => cu(i, !0))), e;
}
function x0() {
  jt(2);
}
var Fi = {
  value: x0
};
function Ds(e) {
  return e === null || typeof e != "object" ? !0 : Object.isFrozen(e);
}
var V0 = {};
function un(e) {
  const a = V0[e];
  return a || jt(0, e), a;
}
var vr;
function Ev() {
  return vr;
}
function I0(e, a) {
  return {
    drafts_: [],
    parent_: e,
    immer_: a,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function _f(e, a) {
  a && (un("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = a);
}
function po(e) {
  ho(e), e.drafts_.forEach(O0), e.drafts_ = null;
}
function ho(e) {
  e === vr && (vr = e.parent_);
}
function Pf(e) {
  return vr = I0(vr, e);
}
function O0(e) {
  const a = e[Ft];
  a.type_ === 0 || a.type_ === 1 ? a.revoke_() : a.revoked_ = !0;
}
function Cf(e, a) {
  a.unfinalizedDrafts_ = a.drafts_.length;
  const i = a.drafts_[0];
  return e !== void 0 && e !== i ? (i[Ft].modified_ && (po(a), jt(4)), on(e) && (e = cs(a, e), a.parent_ || ds(a, e)), a.patches_ && un("Patches").generateReplacementPatches_(
    i[Ft].base_,
    e,
    a.patches_,
    a.inversePatches_
  )) : e = cs(a, i, []), po(a), a.patches_ && a.patchListener_(a.patches_, a.inversePatches_), e !== Vv ? e : void 0;
}
function cs(e, a, i) {
  if (Ds(a))
    return a;
  const r = e.immer_.shouldUseStrictIteration(), n = a[Ft];
  if (!n)
    return us(
      a,
      (t, s) => xf(e, n, a, t, s, i),
      r
    ), a;
  if (n.scope_ !== e)
    return a;
  if (!n.modified_)
    return ds(e, n.base_, !0), n.base_;
  if (!n.finalized_) {
    n.finalized_ = !0, n.scope_.unfinalizedDrafts_--;
    const t = n.copy_;
    let s = t, o = !1;
    n.type_ === 3 && (s = new Set(t), t.clear(), o = !0), us(
      s,
      (l, u) => xf(
        e,
        n,
        t,
        l,
        u,
        i,
        o
      ),
      r
    ), ds(e, t, !1), i && e.patches_ && un("Patches").generatePatches_(
      n,
      i,
      e.patches_,
      e.inversePatches_
    );
  }
  return n.copy_;
}
function xf(e, a, i, r, n, t, s) {
  if (n == null || typeof n != "object" && !s)
    return;
  const o = Ds(n);
  if (!(o && !s)) {
    if (Er.NODE_ENV !== "production" && n === i && jt(5), En(n)) {
      const l = t && a && a.type_ !== 3 && // Set objects are atomic since they have no keys.
      !mo(a.assigned_, r) ? t.concat(r) : void 0, u = cs(e, n, l);
      if (Ov(i, r, u), En(u))
        e.canAutoFreeze_ = !1;
      else
        return;
    } else s && i.add(n);
    if (on(n) && !o) {
      if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1 || a && a.base_ && a.base_[r] === n && o)
        return;
      cs(e, n), (!a || !a.scope_.parent_) && typeof r != "symbol" && (Ar(i) ? i.has(r) : Object.prototype.propertyIsEnumerable.call(i, r)) && ds(e, n);
    }
  }
}
function ds(e, a, i = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && cu(a, i);
}
function E0(e, a) {
  const i = Array.isArray(e), r = {
    type_: i ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: a ? a.scope_ : Ev(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: a,
    // The base state.
    base_: e,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let n = r, t = du;
  i && (n = [r], t = pr);
  const { revoke: s, proxy: o } = Proxy.revocable(n, t);
  return r.draft_ = o, r.revoke_ = s, o;
}
var du = {
  get(e, a) {
    if (a === Ft)
      return e;
    const i = Za(e);
    if (!mo(i, a))
      return A0(e, i, a);
    const r = i[a];
    return e.finalized_ || !on(r) ? r : r === Ll(e.base_, a) ? (ql(e), e.copy_[a] = go(r, e)) : r;
  },
  has(e, a) {
    return a in Za(e);
  },
  ownKeys(e) {
    return Reflect.ownKeys(Za(e));
  },
  set(e, a, i) {
    const r = Av(Za(e), a);
    if (r?.set)
      return r.set.call(e.draft_, i), !0;
    if (!e.modified_) {
      const n = Ll(Za(e), a), t = n?.[Ft];
      if (t && t.base_ === i)
        return e.copy_[a] = i, e.assigned_[a] = !1, !0;
      if (C0(i, n) && (i !== void 0 || mo(e.base_, a)))
        return !0;
      ql(e), yo(e);
    }
    return e.copy_[a] === i && // special case: handle new props with value 'undefined'
    (i !== void 0 || a in e.copy_) || // special case: NaN
    Number.isNaN(i) && Number.isNaN(e.copy_[a]) || (e.copy_[a] = i, e.assigned_[a] = !0), !0;
  },
  deleteProperty(e, a) {
    return Ll(e.base_, a) !== void 0 || a in e.base_ ? (e.assigned_[a] = !1, ql(e), yo(e)) : delete e.assigned_[a], e.copy_ && delete e.copy_[a], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(e, a) {
    const i = Za(e), r = Reflect.getOwnPropertyDescriptor(i, a);
    return r && {
      writable: !0,
      configurable: e.type_ !== 1 || a !== "length",
      enumerable: r.enumerable,
      value: i[a]
    };
  },
  defineProperty() {
    jt(11);
  },
  getPrototypeOf(e) {
    return mr(e.base_);
  },
  setPrototypeOf() {
    jt(12);
  }
}, pr = {};
us(du, (e, a) => {
  pr[e] = function() {
    return arguments[0] = arguments[0][0], a.apply(this, arguments);
  };
});
pr.deleteProperty = function(e, a) {
  return Er.NODE_ENV !== "production" && isNaN(parseInt(a)) && jt(13), pr.set.call(this, e, a, void 0);
};
pr.set = function(e, a, i) {
  return Er.NODE_ENV !== "production" && a !== "length" && isNaN(parseInt(a)) && jt(14), du.set.call(this, e[0], a, i, e[0]);
};
function Ll(e, a) {
  const i = e[Ft];
  return (i ? Za(i) : e)[a];
}
function A0(e, a, i) {
  const r = Av(a, i);
  return r ? "value" in r ? r.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    r.get?.call(e.draft_)
  ) : void 0;
}
function Av(e, a) {
  if (!(a in e))
    return;
  let i = mr(e);
  for (; i; ) {
    const r = Object.getOwnPropertyDescriptor(i, a);
    if (r)
      return r;
    i = mr(i);
  }
}
function yo(e) {
  e.modified_ || (e.modified_ = !0, e.parent_ && yo(e.parent_));
}
function ql(e) {
  e.copy_ || (e.copy_ = vo(
    e.base_,
    e.scope_.immer_.useStrictShallowCopy_
  ));
}
var T0 = class {
  constructor(e) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.useStrictIteration_ = !0, this.produce = (a, i, r) => {
      if (typeof a == "function" && typeof i != "function") {
        const t = i;
        i = a;
        const s = this;
        return function(l = t, ...u) {
          return s.produce(l, (c) => i.call(this, c, ...u));
        };
      }
      typeof i != "function" && jt(6), r !== void 0 && typeof r != "function" && jt(7);
      let n;
      if (on(a)) {
        const t = Pf(this), s = go(a, void 0);
        let o = !0;
        try {
          n = i(s), o = !1;
        } finally {
          o ? po(t) : ho(t);
        }
        return _f(t, r), Cf(n, t);
      } else if (!a || typeof a != "object") {
        if (n = i(a), n === void 0 && (n = a), n === Vv && (n = void 0), this.autoFreeze_ && cu(n, !0), r) {
          const t = [], s = [];
          un("Patches").generateReplacementPatches_(a, n, t, s), r(t, s);
        }
        return n;
      } else
        jt(1, a);
    }, this.produceWithPatches = (a, i) => {
      if (typeof a == "function")
        return (s, ...o) => this.produceWithPatches(s, (l) => a(l, ...o));
      let r, n;
      return [this.produce(a, i, (s, o) => {
        r = s, n = o;
      }), r, n];
    }, typeof e?.autoFreeze == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof e?.useStrictShallowCopy == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy), typeof e?.useStrictIteration == "boolean" && this.setUseStrictIteration(e.useStrictIteration);
  }
  createDraft(e) {
    on(e) || jt(8), En(e) && (e = j0(e));
    const a = Pf(this), i = go(e, void 0);
    return i[Ft].isManual_ = !0, ho(a), i;
  }
  finishDraft(e, a) {
    const i = e && e[Ft];
    (!i || !i.isManual_) && jt(9);
    const { scope_: r } = i;
    return _f(r, a), Cf(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(e) {
    this.autoFreeze_ = e;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e;
  }
  /**
   * Pass false to use faster iteration that skips non-enumerable properties
   * but still handles symbols for compatibility.
   *
   * By default, strict iteration is enabled (includes all own properties).
   */
  setUseStrictIteration(e) {
    this.useStrictIteration_ = e;
  }
  shouldUseStrictIteration() {
    return this.useStrictIteration_;
  }
  applyPatches(e, a) {
    let i;
    for (i = a.length - 1; i >= 0; i--) {
      const n = a[i];
      if (n.path.length === 0 && n.op === "replace") {
        e = n.value;
        break;
      }
    }
    i > -1 && (a = a.slice(i + 1));
    const r = un("Patches").applyPatches_;
    return En(e) ? r(e, a) : this.produce(
      e,
      (n) => r(n, a)
    );
  }
};
function go(e, a) {
  const i = Ar(e) ? un("MapSet").proxyMap_(e, a) : js(e) ? un("MapSet").proxySet_(e, a) : E0(e, a);
  return (a ? a.scope_ : Ev()).drafts_.push(i), i;
}
function j0(e) {
  return En(e) || jt(10, e), Tv(e);
}
function Tv(e) {
  if (!on(e) || Ds(e))
    return e;
  const a = e[Ft];
  let i, r = !0;
  if (a) {
    if (!a.modified_)
      return a.base_;
    a.finalized_ = !0, i = vo(e, a.scope_.immer_.useStrictShallowCopy_), r = a.scope_.immer_.shouldUseStrictIteration();
  } else
    i = vo(e, !0);
  return us(
    i,
    (n, t) => {
      Ov(i, n, Tv(t));
    },
    r
  ), a && (a.finalized_ = !1), i;
}
var bo = new T0(), gt = bo.produce, D0 = /* @__PURE__ */ bo.setAutoFreeze.bind(bo);
const M0 = {
  errorOneOf: "chose one",
  errorRequired: "required information",
  addItem: "Add item",
  delete: "Delete",
  edit: "Edit",
  confirm: "Confirm",
  close: "Close",
  duplicate: "Duplicate",
  copy: "Copy",
  paste: "Paste",
  sort: "Sort",
  up: "Move up",
  down: "Move down",
  showHelp: "Show a help message",
  mdeLink1: "[Link title",
  mdeLink2: "](link url)",
  mdeImg1: "![](",
  mdeImg2: "image url)",
  mdeTable1: "",
  mdeTable2: `

| Column 1 | Column 2 | Column 3 |
| -------- | -------- | -------- |
| Text     | Text     | Text     |

`,
  bold: "Bold",
  italic: "Italic",
  heading: "Title",
  quote: "Quote",
  unorderedList: "Unordered list",
  orderedList: "Ordered list",
  createLink: "Create a link",
  insertImage: "Insert an image",
  createTable: "Create a table",
  preview: "Aperçu du rendu",
  mdeGuide: "Documentation de la syntaxe",
  undo: "Undo",
  redo: "Redo",
  default: "default: ",
  name: "name: ",
  examples: "Examples: ",
  deprecated: "Warning, this information is deprecated.",
  // see L and LT format https://github.com/iamkun/dayjs/blob/dev/src/locale/en-gb.js
  keyboardDate: "MM/DD/YYYY",
  keyboardDateTime: "MM/DD/YYYY HH:mm"
}, R0 = {
  errorOneOf: "choisissez une valeur",
  errorRequired: "information obligatoire",
  addItem: "Ajouter un élément",
  delete: "Supprimer",
  edit: "Éditer",
  confirm: "Confirmer",
  close: "Fermer",
  duplicate: "Dupliquer",
  copy: "Copier",
  paste: "Coller",
  sort: "Trier",
  up: "Décaler vers le haut",
  down: "Décaler vers le bas",
  showHelp: "Afficher un message d'aide",
  mdeLink1: "[titre du lien",
  mdeLink2: "](adresse du lien)",
  mdeImg1: "![](",
  mdeImg2: "adresse de l'image)",
  mdeTable1: "",
  mdeTable2: `

| Colonne 1 | Colonne 2 | Colonne 3 |
| -------- | -------- | -------- |
| Texte     | Texte     | Texte     |

`,
  bold: "Gras",
  italic: "Italique",
  heading: "Titre",
  quote: "Citation",
  unorderedList: "Liste à puce",
  orderedList: "Liste numérotée",
  createLink: "Créer un lien",
  insertImage: "Insérer une image",
  createTable: "Créer un tableau",
  preview: "Preview",
  mdeGuide: "Syntax documentation",
  undo: "Défaire",
  redo: "Refaire",
  default: "défaut : ",
  name: "nom : ",
  examples: "Exemples : ",
  deprecated: "Attention, cette information est obsolète.",
  // see L and LT format https://github.com/iamkun/dayjs/blob/dev/src/locale/fr.js
  keyboardDate: "JJ/MM/AAAA",
  keyboardDateTime: "JJ/MM/AAAA HH:mm"
}, N0 = {
  errorOneOf: "Kies er een",
  errorRequired: "benodigde informatie",
  addItem: "Item toevoegen",
  delete: "Verwijderen",
  confirm: "Bevestigen",
  edit: "Bewerken",
  close: "Sluiten",
  duplicate: "Verveelvoudigen",
  copy: "Kopiëren",
  paste: "Plakken",
  sort: "Sorteren",
  up: "Omhoog verplaatsen",
  down: "Omlaag verplaatsen",
  showHelp: "Toon helpbericht",
  mdeLink1: "[Link titel",
  mdeLink2: "](link url)",
  mdeImg1: "![](",
  mdeImg2: "afbeelding url)",
  mdeTable1: "",
  mdeTable2: `

| Kolom 1  | Kolom 2  | Kolom 3  |
| -------- | -------- | -------- |
| Tekst    | Tekst    | Tekst    |

`,
  bold: "Vet",
  italic: "Cursief",
  heading: "Titel",
  quote: "Citaat",
  unorderedList: "Ongeordende lijst",
  orderedList: "Geordende lijst",
  createLink: "Maak een koppeling",
  insertImage: "Afbeelding invoegen",
  createTable: "Tabel aanmaken",
  preview: "Voorbeeld",
  mdeGuide: "Documentatie over syntaxis",
  undo: "Ongedaan maken",
  redo: "Opnieuw",
  default: "standaard: ",
  name: "naam: ",
  examples: "Voorbeelden: ",
  deprecated: "Waarschuwing, deze informatie is verouderd.",
  // see L and LT format https://github.com/iamkun/dayjs/blob/dev/src/locale/nl.js
  keyboardDate: "DD-MM-YYYY",
  keyboardDateTime: "DD-MM-YYYY HH:mm"
}, L0 = {
  errorOneOf: "Wählen Sie eine Option",
  errorRequired: "Erforderliche Information",
  addItem: "Element hinzufügen",
  delete: "Löschen",
  edit: "Bearbeiten",
  confirm: "Bestätigen",
  close: "Schließen",
  duplicate: "Duplizieren",
  copy: "Kopie",
  paste: "Paste",
  sort: "Sortieren",
  up: "Nach oben verschieben",
  down: "Nach unten verschieben",
  showHelp: "Hilfemeldung anzeigen",
  mdeLink1: "[Link-Titel",
  mdeLink2: "](Link-URL)",
  mdeImg1: "![](",
  mdeImg2: "Bild-URL)",
  mdeTable1: "",
  mdeTable2: `

| Spalte 1 | Spalte 2 | Spalte 3 |
| -------- | -------- | -------- |
| Text     | Text     | Text     |

`,
  bold: "Fett",
  italic: "Kursiv",
  heading: "Titel",
  quote: "Zitat",
  unorderedList: "Ungeordnete Liste",
  orderedList: "Geordnete Liste",
  createLink: "Link erstellen",
  insertImage: "Bild einfügen",
  createTable: "Tabelle erstellen",
  preview: "Vorschau",
  mdeGuide: "Syntax-Dokumentation",
  undo: "Rückgängig",
  redo: "Wiederholen",
  default: "standard: ",
  name: "name: ",
  examples: "Beispiele: ",
  deprecated: "Achtung, diese Information ist veraltet.",
  // see L and LT format https://github.com/iamkun/dayjs/blob/dev/src/locale/de.js
  keyboardDate: "TT.MM.JJJJ",
  keyboardDateTime: "TT.MM.JJJJ HH:mm"
}, Vf = {
  en: M0,
  fr: R0,
  nl: N0,
  de: L0
};
function fs(e = [], a = []) {
  if (!e || !a || e.length !== a.length) return a;
  for (let i = 0; i < e.length; i++)
    if (e[i] !== a[i]) return a;
  return e;
}
function q0(e = {}, a = {}) {
  if (!e || !a) return a;
  const i = Object.keys(e), r = Object.keys(a);
  if (i.length !== r.length) return a;
  for (const n of i)
    if (e[n] !== a[n]) return a;
  return e;
}
function jv(e = [], a = []) {
  if (!e || !a) return e === a;
  if (e.length !== a.length) return !1;
  for (let i = 0; i < e.length; i++)
    if (e[i] !== a[i]) return !1;
  return !0;
}
const z0 = (
  /** @type {typeof ajvModule.default} */
  dv
), B0 = (e) => {
  let a = e.ajv;
  if (!a) {
    const o = { allErrors: !0, strict: !1, verbose: !0, ...e.ajvOptions }, l = new z0(o);
    mv.default(l), vv.default(l), a = l;
  }
  try {
    a.addKeyword("layout");
  } catch {
  }
  try {
    a.addKeyword("__pointer");
  } catch {
  }
  let i = e.markdown;
  i || (i = (l) => We.parse(l, e.markedOptions));
  const r = e.defaultLocale || "en", n = e.locale || r, t = { ...Vf[n] || Vf[r] };
  e.messages && Object.assign(t, e.messages);
  const s = lg.reduce(
    (o, l) => (o[l.name] = l, o),
    /** @type {Record<string, import('@json-layout/vocabulary').ComponentInfo>} */
    {}
  );
  if (e.components) {
    for (const o of Object.keys(e.components))
      s[o] = { ...e.components[o], name: o };
    Object.assign(s, e.components);
  }
  return {
    ajv: a,
    markdown: i,
    useDescription: ["help", "subtitle"],
    useDefault: "data",
    useName: !1,
    useExamples: "items",
    useDeprecated: !1,
    useTitle: "label",
    ...e,
    locale: n,
    defaultLocale: r,
    messages: t,
    components: s,
    xI18n: !!e.xI18n
  };
}, F0 = gt((e, a) => {
  for (const i of ["ajv", "ajvOptions", "code", "markdown", "markedOptions", "xI18n", "locale", "defaultLocale", "messages", "optionsKeys", "components", "useDescription", "useDefault", "useName", "useExamples", "useDeprecated", "useTitle"])
    if (i in a) {
      if (i === "components" && jv(Object.keys(e.components ?? []), Object.keys(a.components ?? [])))
        continue;
      e[i] = a[i];
    } else
      delete e[i];
}), If = (
  /** @type {typeof ajvLocalizeModule.default} */
  Ky
);
function K0(e, a = {}) {
  const i = B0(a), r = (
    /** @type {import('ajv').SchemaObject} */
    na(e)
  );
  r.$id = r.$id ?? "_jl";
  const n = qk(r, i.ajv, i.locale, i.defaultLocale);
  i.xI18n && oo(r, i.locale, i.defaultLocale);
  const t = [], s = {}, o = [], l = {}, u = {}, c = {}, d = `${r.$id}#`;
  for (u[d] = "recursing", u[d] = Ji(
    r,
    r.$id,
    i,
    n,
    u,
    c,
    t,
    l,
    s,
    o,
    d,
    "main"
  ); ; ) {
    let h = !1;
    for (const y of Object.values(c)) {
      for (const m of [...y.propertyKeys])
        if (m.startsWith("$")) {
          const p = c[m.replace("$", "")];
          y.propertyKeys = [...new Set(y.propertyKeys.filter((b) => b !== m).concat(p.propertyKeys))], h = !0;
        }
      for (const m of [...y.roPropertyKeys])
        if (m.startsWith("$")) {
          const p = c[m.replace("$", "")];
          y.roPropertyKeys = [...new Set(y.roPropertyKeys.filter((b) => b !== m).concat(p.roPropertyKeys))], h = !0;
        }
    }
    if (!h) break;
  }
  i.ajv.removeSchema(r.$id), i.ajv.addSchema(r);
  const f = i.ajv.opts.uriResolver, v = {};
  for (const h of t) {
    const y = f.resolve(r.$id, h);
    v[h] = i.ajv.compile({ $ref: y });
  }
  const g = [];
  for (const h of o) {
    const y = h.pure ? ["data", h.dataAlias, "options", "context", "display", "layout", "readOnly", "summary", "validates"] : ["data", h.dataAlias, "options", "context", "display", "layout", "readOnly", "summary", "validates", "rootData", "parent"];
    h.type === "js-fn" && g.push(
      /** @type {CompiledExpression} */
      new Function(...y, h.expr)
    ), h.type === "js-eval" && g.push(
      /** @type {CompiledExpression} */
      new Function(...y, "return (" + h.expr + ")")
    ), h.type === "js-tpl" && g.push(
      /** @type {CompiledExpression} */
      new Function(...y, "return `" + h.expr + "`")
    );
  }
  return Object.keys(l).length && console.error("JSON layout encountered some validation errors:", l), {
    options: i,
    schema: r,
    mainTree: d,
    skeletonTrees: u,
    skeletonNodes: c,
    validates: v,
    validationErrors: l,
    normalizedLayouts: s,
    expressions: g,
    locale: i.locale,
    messages: i.messages,
    components: i.components,
    // @ts-ignore
    localizeErrors: If[i.locale] || If.en
  };
}
function ee(e, a) {
  return (i) => Object.keys(e).reduce((r, n) => {
    const s = typeof e[n] == "object" && e[n] != null && !Array.isArray(e[n]) ? e[n] : {
      type: e[n]
    };
    return i && n in i ? r[n] = {
      ...s,
      default: i[n]
    } : r[n] = s, a && !r[n].source && (r[n].source = a), r;
  }, {});
}
const Se = ee({
  class: [String, Array, Object],
  style: {
    type: [String, Array, Object],
    default: null
  }
}, "component");
function Oa(e) {
  Ps(`Vuetify: ${e}`);
}
function fu(e) {
  Ps(`Vuetify error: ${e}`);
}
function H0(e, a) {
  a = Array.isArray(a) ? a.slice(0, -1).map((i) => `'${i}'`).join(", ") + ` or '${a.at(-1)}'` : `'${a}'`, Ps(`[Vuetify UPGRADE] '${e}' is deprecated, use ${a} instead.`);
}
const et = typeof window < "u", mu = et && "IntersectionObserver" in window, Of = et && "EyeDropper" in window, Dv = et && "matchMedia" in window && typeof window.matchMedia == "function", cn = () => Dv && window.matchMedia("(prefers-reduced-motion: reduce)").matches;
function Ef(e, a, i) {
  U0(e, a), a.set(e, i);
}
function U0(e, a) {
  if (a.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object");
}
function Af(e, a, i) {
  return e.set(Mv(e, a), i), i;
}
function $a(e, a) {
  return e.get(Mv(e, a));
}
function Mv(e, a, i) {
  if (typeof e == "function" ? e === a : e.has(a)) return arguments.length < 3 ? a : i;
  throw new TypeError("Private element is not present on this object");
}
function Rv(e, a, i) {
  const r = a.length - 1;
  if (r < 0) return e === void 0 ? i : e;
  for (let n = 0; n < r; n++) {
    if (e == null)
      return i;
    e = e[a[n]];
  }
  return e == null || e[a[r]] === void 0 ? i : e[a[r]];
}
function W0(e, a, i) {
  return e == null || !a || typeof a != "string" ? i : e[a] !== void 0 ? e[a] : (a = a.replace(/\[(\w+)\]/g, ".$1"), a = a.replace(/^\./, ""), Rv(e, a.split("."), i));
}
function It(e, a, i) {
  if (a === !0) return e === void 0 ? i : e;
  if (a == null || typeof a == "boolean") return i;
  if (e !== Object(e)) {
    if (typeof a != "function") return i;
    const n = a(e, i);
    return typeof n > "u" ? i : n;
  }
  if (typeof a == "string") return W0(e, a, i);
  if (Array.isArray(a)) return Rv(e, a, i);
  if (typeof a != "function") return i;
  const r = a(e, i);
  return typeof r > "u" ? i : r;
}
function Bn(e) {
  let a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  return Array.from({
    length: e
  }, (i, r) => a + r);
}
function he(e) {
  let a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "px";
  if (e == null || e === "")
    return;
  const i = Number(e);
  return isNaN(i) ? String(e) : isFinite(i) ? `${i}${a}` : void 0;
}
function ms(e) {
  return e !== null && typeof e == "object" && !Array.isArray(e);
}
function ko(e) {
  let a;
  return e !== null && typeof e == "object" && ((a = Object.getPrototypeOf(e)) === Object.prototype || a === null);
}
function Nv(e) {
  if (e && "$el" in e) {
    const a = e.$el;
    return a?.nodeType === Node.TEXT_NODE ? a.nextElementSibling : a;
  }
  return e;
}
const G0 = Object.freeze({
  enter: "Enter",
  tab: "Tab",
  delete: "Delete",
  esc: "Escape",
  space: "Space",
  up: "ArrowUp",
  down: "ArrowDown",
  left: "ArrowLeft",
  right: "ArrowRight",
  end: "End",
  home: "Home",
  del: "Delete",
  backspace: "Backspace",
  insert: "Insert",
  pageup: "PageUp",
  pagedown: "PageDown",
  shift: "Shift"
});
function Lv(e) {
  return Object.keys(e);
}
function Qa(e, a) {
  return a.every((i) => e.hasOwnProperty(i));
}
function za(e, a) {
  const i = {};
  for (const r of a)
    Object.prototype.hasOwnProperty.call(e, r) && (i[r] = e[r]);
  return i;
}
function wo(e, a, i) {
  const r = /* @__PURE__ */ Object.create(null), n = /* @__PURE__ */ Object.create(null);
  for (const t in e)
    a.some((s) => s instanceof RegExp ? s.test(t) : s === t) ? r[t] = e[t] : n[t] = e[t];
  return [r, n];
}
function Le(e, a) {
  const i = {
    ...e
  };
  return a.forEach((r) => delete i[r]), i;
}
const qv = /^on[^a-z]/, zv = (e) => qv.test(e), Y0 = ["onAfterscriptexecute", "onAnimationcancel", "onAnimationend", "onAnimationiteration", "onAnimationstart", "onAuxclick", "onBeforeinput", "onBeforescriptexecute", "onChange", "onClick", "onCompositionend", "onCompositionstart", "onCompositionupdate", "onContextmenu", "onCopy", "onCut", "onDblclick", "onFocusin", "onFocusout", "onFullscreenchange", "onFullscreenerror", "onGesturechange", "onGestureend", "onGesturestart", "onGotpointercapture", "onInput", "onKeydown", "onKeypress", "onKeyup", "onLostpointercapture", "onMousedown", "onMousemove", "onMouseout", "onMouseover", "onMouseup", "onMousewheel", "onPaste", "onPointercancel", "onPointerdown", "onPointerenter", "onPointerleave", "onPointermove", "onPointerout", "onPointerover", "onPointerup", "onReset", "onSelect", "onSubmit", "onTouchcancel", "onTouchend", "onTouchmove", "onTouchstart", "onTransitioncancel", "onTransitionend", "onTransitionrun", "onTransitionstart", "onWheel"], X0 = ["ArrowUp", "ArrowDown", "ArrowRight", "ArrowLeft", "Enter", "Escape", "Tab", " "];
function Z0(e) {
  return e.isComposing && X0.includes(e.key);
}
function Ba(e) {
  const [a, i] = wo(e, [qv]), r = Le(a, Y0), [n, t] = wo(i, ["class", "style", "id", "inert", /^data-/]);
  return Object.assign(n, a), Object.assign(t, r), [n, t];
}
function Ze(e) {
  return e == null ? [] : Array.isArray(e) ? e : [e];
}
function Bv(e, a) {
  let i = 0;
  const r = function() {
    for (var n = arguments.length, t = new Array(n), s = 0; s < n; s++)
      t[s] = arguments[s];
    clearTimeout(i), i = setTimeout(() => e(...t), Y(a));
  };
  return r.clear = () => {
    clearTimeout(i);
  }, r.immediate = e, r;
}
function Xe(e) {
  let a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
  return Math.max(a, Math.min(i, e));
}
function Tf(e) {
  const a = e.toString().trim();
  return a.includes(".") ? a.length - a.indexOf(".") - 1 : 0;
}
function jf(e, a) {
  let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "0";
  return e + i.repeat(Math.max(0, a - e.length));
}
function J0(e) {
  let a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
  const i = [];
  let r = 0;
  for (; r < e.length; )
    i.push(e.substr(r, a)), r += a;
  return i;
}
function Df(e) {
  let a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1e3;
  if (e < a)
    return `${e} B`;
  const i = a === 1024 ? ["Ki", "Mi", "Gi"] : ["k", "M", "G"];
  let r = -1;
  for (; Math.abs(e) >= a && r < i.length - 1; )
    e /= a, ++r;
  return `${e.toFixed(1)} ${i[r]}B`;
}
function Va() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, i = arguments.length > 2 ? arguments[2] : void 0;
  const r = {};
  for (const n in e)
    r[n] = e[n];
  for (const n in a) {
    const t = e[n], s = a[n];
    if (ko(t) && ko(s)) {
      r[n] = Va(t, s, i);
      continue;
    }
    if (i && Array.isArray(t) && Array.isArray(s)) {
      r[n] = i(t, s);
      continue;
    }
    r[n] = s;
  }
  return r;
}
function Fv(e) {
  return e.map((a) => a.type === pe ? Fv(a.children) : a).flat();
}
function tn() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
  if (tn.cache.has(e)) return tn.cache.get(e);
  const a = e.replace(/[^a-z]/gi, "-").replace(/\B([A-Z])/g, "-$1").toLowerCase();
  return tn.cache.set(e, a), a;
}
tn.cache = /* @__PURE__ */ new Map();
function ir(e, a) {
  if (!a || typeof a != "object") return [];
  if (Array.isArray(a))
    return a.map((i) => ir(e, i)).flat(1);
  if (a.suspense)
    return ir(e, a.ssContent);
  if (Array.isArray(a.children))
    return a.children.map((i) => ir(e, i)).flat(1);
  if (a.component) {
    if (Object.getOwnPropertyDescriptor(a.component.provides, e))
      return [a.component];
    if (a.component.subTree)
      return ir(e, a.component.subTree).flat(1);
  }
  return [];
}
var Pn = /* @__PURE__ */ new WeakMap(), Ga = /* @__PURE__ */ new WeakMap();
class Q0 {
  constructor(a) {
    Ef(this, Pn, []), Ef(this, Ga, 0), this.size = a;
  }
  get isFull() {
    return $a(Pn, this).length === this.size;
  }
  push(a) {
    $a(Pn, this)[$a(Ga, this)] = a, Af(Ga, this, ($a(Ga, this) + 1) % this.size);
  }
  values() {
    return $a(Pn, this).slice($a(Ga, this)).concat($a(Pn, this).slice(0, $a(Ga, this)));
  }
  clear() {
    $a(Pn, this).length = 0, Af(Ga, this, 0);
  }
}
function ew(e) {
  return "touches" in e ? {
    clientX: e.touches[0].clientX,
    clientY: e.touches[0].clientY
  } : {
    clientX: e.clientX,
    clientY: e.clientY
  };
}
function vu(e) {
  const a = rn({});
  wt(() => {
    const r = e();
    for (const n in r)
      a[n] = r[n];
  }, {
    flush: "sync"
  });
  const i = {};
  for (const r in a)
    i[r] = W(() => a[r]);
  return i;
}
function vs(e, a) {
  return e.includes(a);
}
function Kv(e) {
  return e[2].toLowerCase() + e.slice(3);
}
const Et = () => [Function, Array];
function Mf(e, a) {
  return a = "on" + Pr(a), !!(e[a] || e[`${a}Once`] || e[`${a}Capture`] || e[`${a}OnceCapture`] || e[`${a}CaptureOnce`]);
}
function Ms(e) {
  for (var a = arguments.length, i = new Array(a > 1 ? a - 1 : 0), r = 1; r < a; r++)
    i[r - 1] = arguments[r];
  if (Array.isArray(e))
    for (const n of e)
      n(...i);
  else typeof e == "function" && e(...i);
}
function an(e) {
  let a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
  const i = ["button", "[href]", 'input:not([type="hidden"])', "select", "textarea", "details:not(:has(> summary))", "details > summary", "[tabindex]", '[contenteditable]:not([contenteditable="false"])', "audio[controls]", "video[controls]"].map((n) => `${n}${a ? ':not([tabindex="-1"])' : ""}:not([disabled], [inert])`).join(", ");
  let r;
  try {
    r = [...e.querySelectorAll(i)];
  } catch (n) {
    return fu(String(n)), [];
  }
  return r.filter((n) => !n.closest("[inert]")).filter((n) => !!n.offsetParent || n.getClientRects().length > 0).filter((n) => !n.parentElement?.closest("details:not([open])") || n.tagName === "SUMMARY" && n.parentElement?.tagName === "DETAILS");
}
function Hv(e, a, i) {
  let r, n = e.indexOf(document.activeElement);
  const t = a === "next" ? 1 : -1;
  do
    n += t, r = e[n];
  while ((!r || r.offsetParent == null || !(i?.(r) ?? !0)) && n < e.length && n >= 0);
  return r;
}
function cr(e, a) {
  const i = an(e);
  if (a == null)
    (e === document.activeElement || !e.contains(document.activeElement)) && i[0]?.focus();
  else if (a === "first")
    i[0]?.focus();
  else if (a === "last")
    i.at(-1)?.focus();
  else if (typeof a == "number")
    i[a]?.focus();
  else {
    const r = Hv(i, a);
    r ? r.focus() : cr(e, a === "next" ? "first" : "last");
  }
}
function Uv() {
}
function An(e, a) {
  if (!(et && typeof CSS < "u" && typeof CSS.supports < "u" && CSS.supports(`selector(${a})`))) return null;
  try {
    return !!e && e.matches(a);
  } catch {
    return null;
  }
}
function Rs(e) {
  return e.some((a) => ry(a) ? a.type === iy ? !1 : a.type !== pe || Rs(a.children) : !0) ? e : null;
}
function tw(e, a) {
  if (!et || e === 0)
    return a(), () => {
    };
  const i = window.setTimeout(a, e);
  return () => window.clearTimeout(i);
}
function aw(e, a) {
  const i = e.clientX, r = e.clientY, n = a.getBoundingClientRect(), t = n.left, s = n.top, o = n.right, l = n.bottom;
  return i >= t && i <= o && r >= s && r <= l;
}
function ps() {
  const e = fe(), a = (i) => {
    e.value = i;
  };
  return Object.defineProperty(a, "value", {
    enumerable: !0,
    get: () => e.value,
    set: (i) => e.value = i
  }), Object.defineProperty(a, "el", {
    enumerable: !0,
    get: () => Nv(e.value)
  }), a;
}
function Tn(e) {
  const a = e.key.length === 1, i = !e.ctrlKey && !e.metaKey && !e.altKey;
  return a && i;
}
function dn(e) {
  return typeof e == "string" || typeof e == "number" || typeof e == "boolean" || typeof e == "bigint";
}
function hs(e) {
  return "\\^$*+?.()|{}[]".includes(e) ? `\\${e}` : e;
}
function nw(e, a, i) {
  const r = new RegExp(`[\\d\\-${hs(i)}]`), n = e.split("").filter((s) => r.test(s)).filter((s, o, l) => o === 0 && /[-]/.test(s) || // sign allowed at the start
  s === i && o === l.indexOf(s) || // decimal separator allowed only once
  /\d/.test(s)).join("");
  if (a === 0)
    return n.split(i)[0];
  const t = new RegExp(`${hs(i)}\\d`);
  if (a !== null && t.test(n)) {
    const s = n.split(i);
    return [s[0], s[1].substring(0, a)].join(i);
  }
  return n;
}
function rw(e) {
  const a = {};
  for (const i in e)
    a[Cs(i)] = e[i];
  return a;
}
function iw(e) {
  const a = ["checked", "disabled"];
  return Object.fromEntries(Object.entries(e).filter((i) => {
    let [r, n] = i;
    return a.includes(r) ? !!n : n !== void 0;
  }));
}
function Rf(e) {
  const a = (i) => Array.isArray(i) ? i.map((r) => a(r)) : ns(i) || ay(i) || ny(i) ? a(Ye(i)) : ko(i) ? Object.keys(i).reduce((r, n) => (r[n] = a(i[n]), r), {}) : i;
  return a(e);
}
const Wv = ["top", "bottom"], sw = ["start", "end", "left", "right"];
function So(e, a) {
  let [i, r] = e.split(" ");
  return r || (r = vs(Wv, i) ? "start" : vs(sw, i) ? "top" : "center"), {
    side: Nf(i, a),
    align: Nf(r, a)
  };
}
function Nf(e, a) {
  return e === "start" ? a ? "right" : "left" : e === "end" ? a ? "left" : "right" : e;
}
function zl(e) {
  return {
    side: {
      center: "center",
      top: "bottom",
      bottom: "top",
      left: "right",
      right: "left"
    }[e.side],
    align: e.align
  };
}
function Bl(e) {
  return {
    side: e.side,
    align: {
      center: "center",
      top: "bottom",
      bottom: "top",
      left: "right",
      right: "left"
    }[e.align]
  };
}
function Lf(e) {
  return {
    side: e.align,
    align: e.side
  };
}
function qf(e) {
  return vs(Wv, e.side) ? "y" : "x";
}
class Ut {
  constructor(a) {
    const i = document.body.currentCSSZoom ?? 1, r = a instanceof Element, n = r ? 1 + (1 - i) / i : 1, {
      x: t,
      y: s,
      width: o,
      height: l
    } = r ? a.getBoundingClientRect() : a;
    this.x = t * n, this.y = s * n, this.width = o * n, this.height = l * n;
  }
  get top() {
    return this.y;
  }
  get bottom() {
    return this.y + this.height;
  }
  get left() {
    return this.x;
  }
  get right() {
    return this.x + this.width;
  }
}
function zf(e, a) {
  return {
    x: {
      before: Math.max(0, a.left - e.left),
      after: Math.max(0, e.right - a.right)
    },
    y: {
      before: Math.max(0, a.top - e.top),
      after: Math.max(0, e.bottom - a.bottom)
    }
  };
}
function Gv(e) {
  if (Array.isArray(e)) {
    const a = document.body.currentCSSZoom ?? 1, i = 1 + (1 - a) / a;
    return new Ut({
      x: e[0] * i,
      y: e[1] * i,
      width: 0 * i,
      height: 0 * i
    });
  } else
    return new Ut(e);
}
function lw(e) {
  if (e === document.documentElement)
    if (visualViewport) {
      const a = document.body.currentCSSZoom ?? 1;
      return new Ut({
        x: visualViewport.scale > 1 ? 0 : visualViewport.offsetLeft,
        y: visualViewport.scale > 1 ? 0 : visualViewport.offsetTop,
        width: visualViewport.width * visualViewport.scale / a,
        height: visualViewport.height * visualViewport.scale / a
      });
    } else
      return new Ut({
        x: 0,
        y: 0,
        width: document.documentElement.clientWidth,
        height: document.documentElement.clientHeight
      });
  else
    return new Ut(e);
}
function pu(e) {
  const a = new Ut(e), i = getComputedStyle(e), r = i.transform;
  if (r) {
    let n, t, s, o, l;
    if (r.startsWith("matrix3d("))
      n = r.slice(9, -1).split(/, /), t = Number(n[0]), s = Number(n[5]), o = Number(n[12]), l = Number(n[13]);
    else if (r.startsWith("matrix("))
      n = r.slice(7, -1).split(/, /), t = Number(n[0]), s = Number(n[3]), o = Number(n[4]), l = Number(n[5]);
    else
      return new Ut(a);
    const u = i.transformOrigin, c = a.x - o - (1 - t) * parseFloat(u), d = a.y - l - (1 - s) * parseFloat(u.slice(u.indexOf(" ") + 1)), f = t ? a.width / t : e.offsetWidth + 1, v = s ? a.height / s : e.offsetHeight + 1;
    return new Ut({
      x: c,
      y: d,
      width: f,
      height: v
    });
  } else
    return new Ut(a);
}
function _a(e, a, i) {
  if (typeof e.animate > "u") return {
    finished: Promise.resolve()
  };
  let r;
  try {
    r = e.animate(a, i);
  } catch {
    return {
      finished: Promise.resolve()
    };
  }
  return typeof r.finished > "u" && (r.finished = new Promise((n) => {
    r.onfinish = () => {
      n(r);
    };
  })), r;
}
const es = /* @__PURE__ */ new WeakMap();
function ow(e, a) {
  Object.keys(a).forEach((i) => {
    if (zv(i)) {
      const r = Kv(i), n = es.get(e);
      if (a[i] == null)
        n?.forEach((t) => {
          const [s, o] = t;
          s === r && (e.removeEventListener(r, o), n.delete(t));
        });
      else if (!n || ![...n].some((t) => t[0] === r && t[1] === a[i])) {
        e.addEventListener(r, a[i]);
        const t = n || /* @__PURE__ */ new Set();
        t.add([r, a[i]]), es.has(e) || es.set(e, t);
      }
    } else
      a[i] == null ? e.removeAttribute(i) : e.setAttribute(i, a[i]);
  });
}
function uw(e, a) {
  Object.keys(a).forEach((i) => {
    if (zv(i)) {
      const r = Kv(i), n = es.get(e);
      n?.forEach((t) => {
        const [s, o] = t;
        s === r && (e.removeEventListener(r, o), n.delete(t));
      });
    } else
      e.removeAttribute(i);
  });
}
const Cn = 2.4, Bf = 0.2126729, Ff = 0.7151522, Kf = 0.072175, cw = 0.55, dw = 0.58, fw = 0.57, mw = 0.62, Ki = 0.03, Hf = 1.45, vw = 5e-4, pw = 1.25, hw = 1.25, Uf = 0.078, Wf = 12.82051282051282, Hi = 0.06, Gf = 1e-3;
function Yf(e, a) {
  const i = (e.r / 255) ** Cn, r = (e.g / 255) ** Cn, n = (e.b / 255) ** Cn, t = (a.r / 255) ** Cn, s = (a.g / 255) ** Cn, o = (a.b / 255) ** Cn;
  let l = i * Bf + r * Ff + n * Kf, u = t * Bf + s * Ff + o * Kf;
  if (l <= Ki && (l += (Ki - l) ** Hf), u <= Ki && (u += (Ki - u) ** Hf), Math.abs(u - l) < vw) return 0;
  let c;
  if (u > l) {
    const d = (u ** cw - l ** dw) * pw;
    c = d < Gf ? 0 : d < Uf ? d - d * Wf * Hi : d - Hi;
  } else {
    const d = (u ** mw - l ** fw) * hw;
    c = d > -Gf ? 0 : d > -Uf ? d - d * Wf * Hi : d + Hi;
  }
  return c * 100;
}
const yw = [[0.4124, 0.3576, 0.1805], [0.2126, 0.7152, 0.0722], [0.0193, 0.1192, 0.9505]], gw = (e) => e <= 0.04045 ? e / 12.92 : ((e + 0.055) / 1.055) ** 2.4;
function bw(e) {
  let {
    r: a,
    g: i,
    b: r
  } = e;
  const n = [0, 0, 0], t = gw, s = yw;
  a = t(a / 255), i = t(i / 255), r = t(r / 255);
  for (let o = 0; o < 3; ++o)
    n[o] = s[o][0] * a + s[o][1] * i + s[o][2] * r;
  return n;
}
function $o(e) {
  return !!e && /^(#|var\(--|(rgb|hsl)a?\()/.test(e);
}
function kw(e) {
  return $o(e) && !/^((rgb|hsl)a?\()?var\(--/.test(e);
}
const Xf = /^(?<fn>(?:rgb|hsl)a?)\((?<values>.+)\)/, ww = {
  rgb: (e, a, i, r) => ({
    r: e,
    g: a,
    b: i,
    a: r
  }),
  rgba: (e, a, i, r) => ({
    r: e,
    g: a,
    b: i,
    a: r
  }),
  hsl: (e, a, i, r) => Zf({
    h: e,
    s: a,
    l: i,
    a: r
  }),
  hsla: (e, a, i, r) => Zf({
    h: e,
    s: a,
    l: i,
    a: r
  }),
  hsv: (e, a, i, r) => va({
    h: e,
    s: a,
    v: i,
    a: r
  }),
  hsva: (e, a, i, r) => va({
    h: e,
    s: a,
    v: i,
    a: r
  })
};
function Ia(e) {
  if (typeof e == "number")
    return (isNaN(e) || e < 0 || e > 16777215) && Oa(`'${e}' is not a valid hex color`), {
      r: (e & 16711680) >> 16,
      g: (e & 65280) >> 8,
      b: e & 255
    };
  if (typeof e == "string" && Xf.test(e)) {
    const {
      groups: a
    } = e.match(Xf), {
      fn: i,
      values: r
    } = a, n = r.split(/,\s*|\s*\/\s*|\s+/).map((t, s) => t.endsWith("%") || // unitless slv are %
    s > 0 && s < 3 && ["hsl", "hsla", "hsv", "hsva"].includes(i) ? parseFloat(t) / 100 : parseFloat(t));
    return ww[i](...n);
  } else if (typeof e == "string") {
    let a = e.startsWith("#") ? e.slice(1) : e;
    [3, 4].includes(a.length) ? a = a.split("").map((r) => r + r).join("") : [6, 8].includes(a.length) || Oa(`'${e}' is not a valid hex(a) color`);
    const i = parseInt(a, 16);
    return (isNaN(i) || i < 0 || i > 4294967295) && Oa(`'${e}' is not a valid hex(a) color`), Zv(a);
  } else if (typeof e == "object") {
    if (Qa(e, ["r", "g", "b"]))
      return e;
    if (Qa(e, ["h", "s", "l"]))
      return va(hu(e));
    if (Qa(e, ["h", "s", "v"]))
      return va(e);
  }
  throw new TypeError(`Invalid color: ${e == null ? e : String(e) || e.constructor.name}
Expected #hex, #hexa, rgb(), rgba(), hsl(), hsla(), object or number`);
}
function va(e) {
  const {
    h: a,
    s: i,
    v: r,
    a: n
  } = e, t = (o) => {
    const l = (o + a / 60) % 6;
    return r - r * i * Math.max(Math.min(l, 4 - l, 1), 0);
  }, s = [t(5), t(3), t(1)].map((o) => Math.round(o * 255));
  return {
    r: s[0],
    g: s[1],
    b: s[2],
    a: n
  };
}
function Zf(e) {
  return va(hu(e));
}
function Tr(e) {
  if (!e) return {
    h: 0,
    s: 1,
    v: 1,
    a: 1
  };
  const a = e.r / 255, i = e.g / 255, r = e.b / 255, n = Math.max(a, i, r), t = Math.min(a, i, r);
  let s = 0;
  n !== t && (n === a ? s = 60 * (0 + (i - r) / (n - t)) : n === i ? s = 60 * (2 + (r - a) / (n - t)) : n === r && (s = 60 * (4 + (a - i) / (n - t)))), s < 0 && (s = s + 360);
  const o = n === 0 ? 0 : (n - t) / n, l = [s, o, n];
  return {
    h: l[0],
    s: l[1],
    v: l[2],
    a: e.a
  };
}
function _o(e) {
  const {
    h: a,
    s: i,
    v: r,
    a: n
  } = e, t = r - r * i / 2, s = t === 1 || t === 0 ? 0 : (r - t) / Math.min(t, 1 - t);
  return {
    h: a,
    s,
    l: t,
    a: n
  };
}
function hu(e) {
  const {
    h: a,
    s: i,
    l: r,
    a: n
  } = e, t = r + i * Math.min(r, 1 - r), s = t === 0 ? 0 : 2 - 2 * r / t;
  return {
    h: a,
    s,
    v: t,
    a: n
  };
}
function Yv(e) {
  let {
    r: a,
    g: i,
    b: r,
    a: n
  } = e;
  return n === void 0 ? `rgb(${a}, ${i}, ${r})` : `rgba(${a}, ${i}, ${r}, ${n})`;
}
function Xv(e) {
  return Yv(va(e));
}
function Ui(e) {
  const a = Math.round(e).toString(16);
  return ("00".substr(0, 2 - a.length) + a).toUpperCase();
}
function Sw(e) {
  let {
    r: a,
    g: i,
    b: r,
    a: n
  } = e;
  return `#${[Ui(a), Ui(i), Ui(r), n !== void 0 ? Ui(Math.round(n * 255)) : ""].join("")}`;
}
function Zv(e) {
  e = _w(e);
  let [a, i, r, n] = J0(e, 2).map((t) => parseInt(t, 16));
  return n = n === void 0 ? n : n / 255, {
    r: a,
    g: i,
    b: r,
    a: n
  };
}
function $w(e) {
  const a = Zv(e);
  return Tr(a);
}
function Jv(e) {
  return Sw(va(e));
}
function _w(e) {
  return e.startsWith("#") && (e = e.slice(1)), e = e.replace(/([^0-9a-f])/gi, "F"), (e.length === 3 || e.length === 4) && (e = e.split("").map((a) => a + a).join("")), e.length !== 6 && (e = jf(jf(e, 6), 8, "F")), e;
}
function Jf(e) {
  const a = Ia(e);
  return bw(a)[1];
}
function Pw(e, a) {
  const i = Jf(e), r = Jf(a), n = Math.max(i, r), t = Math.min(i, r);
  return (n + 0.05) / (t + 0.05);
}
function Cw(e) {
  const a = Math.abs(Yf(Ia(0), Ia(e)));
  return Math.abs(Yf(Ia(16777215), Ia(e))) > Math.min(a, 50) ? "#fff" : "#000";
}
function ft(e, a) {
  const i = xs();
  if (!i)
    throw new Error(`[Vuetify] ${e} must be called from inside a setup function`);
  return i;
}
function ga() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "composables";
  const a = ft(e).type;
  return tn(a?.aliasName || a?.name);
}
function xw(e) {
  let a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ft("injectSelf");
  const {
    provides: i
  } = a;
  if (i && e in i)
    return i[e];
}
const ys = /* @__PURE__ */ Symbol.for("vuetify:defaults");
function yu() {
  const e = qe(ys);
  if (!e) throw new Error("[Vuetify] Could not find defaults instance");
  return e;
}
function da(e, a) {
  const i = yu(), r = ie(e), n = I(() => {
    if (Y(a?.disabled)) return i.value;
    const s = Y(a?.scoped), o = Y(a?.reset), l = Y(a?.root);
    if (r.value == null && !(s || o || l)) return i.value;
    let u = Va(r.value, {
      prev: i.value
    });
    if (s) return u;
    if (o || l) {
      const c = Number(o || 1 / 0);
      for (let d = 0; d <= c && !(!u || !("prev" in u)); d++)
        u = u.prev;
      return u && typeof l == "string" && l in u && (u = Va(Va(u, {
        prev: u
      }), u[l])), u;
    }
    return u.prev ? Va(u.prev, u) : u;
  });
  return ht(ys, n), n;
}
function Vw(e, a) {
  return e.props && (typeof e.props[a] < "u" || typeof e.props[tn(a)] < "u");
}
function Qv() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, a = arguments.length > 1 ? arguments[1] : void 0, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : yu();
  const r = ft("useDefaults");
  if (a = a ?? r.type.name ?? r.type.__name, !a)
    throw new Error("[Vuetify] Could not determine component name");
  const n = I(() => i.value?.[e._as ?? a]), t = new Proxy(e, {
    get(l, u) {
      const c = Reflect.get(l, u);
      if (u === "class" || u === "style")
        return [n.value?.[u], c].filter((v) => v != null);
      if (Vw(r.vnode, u)) return c;
      const d = n.value?.[u];
      if (d !== void 0) return d;
      const f = i.value?.global?.[u];
      return f !== void 0 ? f : c;
    }
  }), s = fe();
  wt(() => {
    if (n.value) {
      const l = Object.entries(n.value).filter((u) => {
        let [c] = u;
        return c.startsWith(c[0].toUpperCase());
      });
      s.value = l.length ? Object.fromEntries(l) : void 0;
    } else
      s.value = void 0;
  });
  function o() {
    const l = xw(ys, r);
    ht(ys, I(() => s.value ? Va(l?.value ?? {}, s.value) : l?.value));
  }
  return {
    props: t,
    provideSubDefaults: o
  };
}
function Ge() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, a = arguments.length > 1 ? arguments[1] : void 0;
  const {
    props: i,
    provideSubDefaults: r
  } = Qv(e, a);
  return r(), i;
}
function ba(e) {
  if (e._setup = e._setup ?? e.setup, !e.name)
    return Oa("The component is missing an explicit name, unable to generate default prop value"), e;
  if (e._setup) {
    e.props = ee(e.props ?? {}, e.name)();
    const a = Object.keys(e.props).filter((i) => i !== "class" && i !== "style");
    e.filterProps = function(r) {
      return za(r, a);
    }, e.props._as = String, e.setup = function(r, n) {
      const t = yu();
      if (!t.value) return e._setup(r, n);
      const {
        props: s,
        provideSubDefaults: o
      } = Qv(r, r._as ?? e.name, t), l = e._setup(s, n);
      return o(), l;
    };
  }
  return e;
}
function de() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
  return (a) => (e ? ba : dt)(a);
}
function Fn(e) {
  let a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "div", i = arguments.length > 2 ? arguments[2] : void 0;
  return de()({
    name: i ?? Pr(Cs(e.replace(/__/g, "-"))),
    props: {
      tag: {
        type: String,
        default: a
      },
      ...Se()
    },
    setup(r, n) {
      let {
        slots: t
      } = n;
      return () => Oe(r.tag, {
        class: [e, r.class],
        style: r.style
      }, t.default?.());
    }
  });
}
function Iw(e, a, i, r) {
  if (!i || dn(e) || dn(a)) return;
  const n = i.get(e);
  if (n)
    n.set(a, r);
  else {
    const t = /* @__PURE__ */ new WeakMap();
    t.set(a, r), i.set(e, t);
  }
}
function Ow(e, a, i) {
  if (!i || dn(e) || dn(a)) return null;
  const r = i.get(e)?.get(a);
  if (typeof r == "boolean") return r;
  const n = i.get(a)?.get(e);
  return typeof n == "boolean" ? n : null;
}
function bt(e, a) {
  let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : /* @__PURE__ */ new WeakMap();
  if (e === a) return !0;
  if (e instanceof Date && a instanceof Date && e.getTime() !== a.getTime() || e !== Object(e) || a !== Object(a))
    return !1;
  const r = Object.keys(e);
  if (r.length !== Object.keys(a).length)
    return !1;
  const n = Ow(e, a, i);
  return n || (Iw(e, a, i, !0), r.every((t) => bt(e[t], a[t], i)));
}
function ep(e) {
  if (typeof e.getRootNode != "function") {
    for (; e.parentNode; ) e = e.parentNode;
    return e !== document ? null : document;
  }
  const a = e.getRootNode();
  return a !== document && a.getRootNode({
    composed: !0
  }) !== document ? null : a;
}
const hr = "cubic-bezier(0.4, 0, 0.2, 1)", Qf = "cubic-bezier(0.0, 0, 0.2, 1)", em = "cubic-bezier(0.4, 0, 1, 1)", Ew = {
  linear: (e) => e,
  easeInQuad: (e) => e ** 2,
  easeOutQuad: (e) => e * (2 - e),
  easeInOutQuad: (e) => e < 0.5 ? 2 * e ** 2 : -1 + (4 - 2 * e) * e,
  easeInCubic: (e) => e ** 3,
  easeOutCubic: (e) => --e ** 3 + 1,
  easeInOutCubic: (e) => e < 0.5 ? 4 * e ** 3 : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1,
  easeInQuart: (e) => e ** 4,
  easeOutQuart: (e) => 1 - --e ** 4,
  easeInOutQuart: (e) => e < 0.5 ? 8 * e ** 4 : 1 - 8 * --e ** 4,
  easeInQuint: (e) => e ** 5,
  easeOutQuint: (e) => 1 + --e ** 5,
  easeInOutQuint: (e) => e < 0.5 ? 16 * e ** 5 : 1 + 16 * --e ** 5,
  instant: (e) => 1
};
function gu(e) {
  let a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
  for (; e; ) {
    if (a ? Aw(e) : bu(e)) return e;
    e = e.parentElement;
  }
  return document.scrollingElement;
}
function gs(e, a) {
  const i = [];
  if (a && e && !a.contains(e)) return i;
  for (; e && (bu(e) && i.push(e), e !== a); )
    e = e.parentElement;
  return i;
}
function bu(e) {
  if (!e || e.nodeType !== Node.ELEMENT_NODE) return !1;
  const a = window.getComputedStyle(e), i = a.overflowY === "scroll" || a.overflowY === "auto" && e.scrollHeight > e.clientHeight, r = a.overflowX === "scroll" || a.overflowX === "auto" && e.scrollWidth > e.clientWidth;
  return i || r;
}
function Aw(e) {
  if (!e || e.nodeType !== Node.ELEMENT_NODE) return !1;
  const a = window.getComputedStyle(e);
  return ["scroll", "auto"].includes(a.overflowY);
}
function Tw(e) {
  for (; e; ) {
    if (window.getComputedStyle(e).position === "fixed")
      return !0;
    e = e.offsetParent;
  }
  return !1;
}
function me(e) {
  const a = ft("useRender");
  a.render = e;
}
function jw(e, a) {
  let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
    leading: !0,
    trailing: !0
  }, r = 0, n = 0, t = !1, s = 0;
  function o() {
    clearTimeout(r), t = !1, s = 0;
  }
  const l = function() {
    for (var u = arguments.length, c = new Array(u), d = 0; d < u; d++)
      c[d] = arguments[d];
    clearTimeout(r);
    const f = Date.now();
    s || (s = f);
    const v = f - Math.max(s, n);
    function g() {
      n = Date.now(), r = setTimeout(o, a), e(...c);
    }
    t ? v >= a ? g() : i.trailing && (r = setTimeout(g, a - v)) : (t = !0, i.leading && g());
  };
  return l.clear = o, l.immediate = e, l;
}
const Mt = ee({
  height: [Number, String],
  maxHeight: [Number, String],
  maxWidth: [Number, String],
  minHeight: [Number, String],
  minWidth: [Number, String],
  width: [Number, String]
}, "dimension");
function Rt(e) {
  return {
    dimensionStyles: I(() => {
      const i = {}, r = he(e.height), n = he(e.maxHeight), t = he(e.maxWidth), s = he(e.minHeight), o = he(e.minWidth), l = he(e.width);
      return r != null && (i.height = r), n != null && (i.maxHeight = n), t != null && (i.maxWidth = t), s != null && (i.minHeight = s), o != null && (i.minWidth = o), l != null && (i.width = l), i;
    })
  };
}
function Na(e, a) {
  let i;
  function r() {
    i = Ho(), i.run(() => a.length ? a(() => {
      i?.stop(), r();
    }) : a());
  }
  ce(e, (n) => {
    n && !i ? r() : n || (i?.stop(), i = void 0);
  }, {
    immediate: !0
  }), st(() => {
    i?.stop();
  });
}
function $e(e, a, i) {
  let r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : (d) => d, n = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : (d) => d;
  const t = ft("useProxiedModel"), s = ie(e[a] !== void 0 ? e[a] : i), o = tn(a), u = o !== a ? I(() => (e[a], !!((t.vnode.props?.hasOwnProperty(a) || t.vnode.props?.hasOwnProperty(o)) && (t.vnode.props?.hasOwnProperty(`onUpdate:${a}`) || t.vnode.props?.hasOwnProperty(`onUpdate:${o}`))))) : I(() => (e[a], !!(t.vnode.props?.hasOwnProperty(a) && t.vnode.props?.hasOwnProperty(`onUpdate:${a}`))));
  Na(() => !u.value, () => {
    ce(() => e[a], (d) => {
      s.value = d;
    });
  });
  const c = I({
    get() {
      const d = e[a];
      return r(u.value ? d : s.value);
    },
    set(d) {
      const f = n(d), v = Ye(u.value ? e[a] : s.value);
      v === f || r(v) === d || (s.value = f, t?.emit(`update:${a}`, f));
    }
  });
  return Object.defineProperty(c, "externalValue", {
    get: () => u.value ? e[a] : s.value
  }), c;
}
const tp = /* @__PURE__ */ Symbol.for("vuetify:locale");
function nt() {
  const e = qe(tp);
  if (!e) throw new Error("[Vuetify] Could not find injected locale instance");
  return e;
}
function St() {
  const e = qe(tp);
  if (!e) throw new Error("[Vuetify] Could not find injected rtl instance");
  return {
    isRtl: e.isRtl,
    rtlClasses: e.rtlClasses
  };
}
const Be = ee({
  tag: {
    type: [String, Object, Function],
    default: "div"
  }
}, "tag"), Dw = ee({
  fluid: {
    type: Boolean,
    default: !1
  },
  ...Se(),
  ...Mt(),
  ...Be()
}, "VContainer"), jr = de()({
  name: "VContainer",
  props: Dw(),
  setup(e, a) {
    let {
      slots: i
    } = a;
    const {
      rtlClasses: r
    } = St(), {
      dimensionStyles: n
    } = Rt(e);
    return me(() => C(e.tag, {
      class: ue(["v-container", {
        "v-container--fluid": e.fluid
      }, r.value, e.class]),
      style: be([n.value, e.style])
    }, i)), {};
  }
}), Ns = ["sm", "md", "lg", "xl", "xxl"], Mw = /* @__PURE__ */ Symbol.for("vuetify:display"), ap = ee({
  mobile: {
    type: Boolean,
    default: !1
  },
  mobileBreakpoint: [Number, String]
}, "display");
function Dr() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
    mobile: null
  }, a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ga();
  const i = qe(Mw);
  if (!i) throw new Error("Could not find Vuetify display injection");
  const r = I(() => e.mobile ? !0 : typeof e.mobileBreakpoint == "number" ? i.width.value < e.mobileBreakpoint : e.mobileBreakpoint ? i.width.value < i.thresholds.value[e.mobileBreakpoint] : e.mobile === null ? i.mobile.value : !1), n = W(() => a ? {
    [`${a}--mobile`]: r.value
  } : {});
  return {
    ...i,
    displayClasses: n,
    mobile: r
  };
}
const np = Ns.reduce((e, a) => (e[a] = {
  type: [Boolean, String, Number],
  default: !1
}, e), {}), rp = Ns.reduce((e, a) => {
  const i = "offset" + Pr(a);
  return e[i] = {
    type: [String, Number],
    default: null
  }, e;
}, {}), ip = Ns.reduce((e, a) => {
  const i = "order" + Pr(a);
  return e[i] = {
    type: [String, Number],
    default: null
  }, e;
}, {}), tm = {
  col: Object.keys(np),
  offset: Object.keys(rp),
  order: Object.keys(ip)
};
function Rw(e, a, i) {
  let r = e;
  if (!(i == null || i === !1)) {
    if (a) {
      const n = a.replace(e, "");
      r += `-${n}`;
    }
    return e === "col" && (r = "v-" + r), e === "col" && (i === "" || i === !0) || (r += `-${i}`), r.toLowerCase();
  }
}
const Nw = ["auto", "start", "end", "center", "baseline", "stretch"], Lw = ee({
  cols: {
    type: [Boolean, String, Number],
    default: !1
  },
  ...np,
  offset: {
    type: [String, Number],
    default: null
  },
  ...rp,
  order: {
    type: [String, Number],
    default: null
  },
  ...ip,
  alignSelf: {
    type: String,
    default: null,
    validator: (e) => Nw.includes(e)
  },
  ...Se(),
  ...Be()
}, "VCol"), sp = de()({
  name: "VCol",
  props: Lw(),
  setup(e, a) {
    let {
      slots: i
    } = a;
    const r = I(() => {
      const n = [];
      let t;
      for (t in tm)
        tm[t].forEach((o) => {
          const l = e[o], u = Rw(t, o, l);
          u && n.push(u);
        });
      const s = n.some((o) => o.startsWith("v-col-"));
      return n.push({
        // Default to .v-col if no other col-{bp}-* classes generated nor `cols` specified.
        "v-col": !s || !e.cols,
        [`v-col-${e.cols}`]: e.cols,
        [`offset-${e.offset}`]: e.offset,
        [`order-${e.order}`]: e.order,
        [`align-self-${e.alignSelf}`]: e.alignSelf
      }), n;
    });
    return () => Oe(e.tag, {
      class: [r.value, e.class],
      style: e.style
    }, i.default?.());
  }
}), ku = ["start", "end", "center"], lp = ["space-between", "space-around", "space-evenly"];
function wu(e, a) {
  return Ns.reduce((i, r) => {
    const n = e + Pr(r);
    return i[n] = a(), i;
  }, {});
}
const qw = [...ku, "baseline", "stretch"], op = (e) => qw.includes(e), up = wu("align", () => ({
  type: String,
  default: null,
  validator: op
})), zw = [...ku, ...lp], cp = (e) => zw.includes(e), dp = wu("justify", () => ({
  type: String,
  default: null,
  validator: cp
})), Bw = [...ku, ...lp, "stretch"], fp = (e) => Bw.includes(e), mp = wu("alignContent", () => ({
  type: String,
  default: null,
  validator: fp
})), am = {
  align: Object.keys(up),
  justify: Object.keys(dp),
  alignContent: Object.keys(mp)
}, Fw = {
  align: "align",
  justify: "justify",
  alignContent: "align-content"
};
function Kw(e, a, i) {
  let r = Fw[e];
  if (i != null) {
    if (a) {
      const n = a.replace(e, "");
      r += `-${n}`;
    }
    return r += `-${i}`, r.toLowerCase();
  }
}
const Hw = ee({
  dense: Boolean,
  noGutters: Boolean,
  align: {
    type: String,
    default: null,
    validator: op
  },
  ...up,
  justify: {
    type: String,
    default: null,
    validator: cp
  },
  ...dp,
  alignContent: {
    type: String,
    default: null,
    validator: fp
  },
  ...mp,
  ...Se(),
  ...Be()
}, "VRow"), sa = de()({
  name: "VRow",
  props: Hw(),
  setup(e, a) {
    let {
      slots: i
    } = a;
    const r = I(() => {
      const n = [];
      let t;
      for (t in am)
        am[t].forEach((s) => {
          const o = e[s], l = Kw(t, s, o);
          l && n.push(l);
        });
      return n.push({
        "v-row--no-gutters": e.noGutters,
        "v-row--dense": e.dense,
        [`align-${e.align}`]: e.align,
        [`justify-${e.justify}`]: e.justify,
        [`align-content-${e.alignContent}`]: e.alignContent
      }), n;
    });
    return () => Oe(e.tag, {
      class: ["v-row", r.value, e.class],
      style: e.style
    }, i.default?.());
  }
}), yr = Fn("v-spacer", "div", "VSpacer");
var Wi = { exports: {} }, Fl, nm;
function Uw() {
  if (nm) return Fl;
  nm = 1;
  var e = 1e3, a = e * 60, i = a * 60, r = i * 24, n = r * 7, t = r * 365.25;
  Fl = function(c, d) {
    d = d || {};
    var f = typeof c;
    if (f === "string" && c.length > 0)
      return s(c);
    if (f === "number" && isFinite(c))
      return d.long ? l(c) : o(c);
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(c)
    );
  };
  function s(c) {
    if (c = String(c), !(c.length > 100)) {
      var d = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        c
      );
      if (d) {
        var f = parseFloat(d[1]), v = (d[2] || "ms").toLowerCase();
        switch (v) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return f * t;
          case "weeks":
          case "week":
          case "w":
            return f * n;
          case "days":
          case "day":
          case "d":
            return f * r;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return f * i;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return f * a;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return f * e;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return f;
          default:
            return;
        }
      }
    }
  }
  function o(c) {
    var d = Math.abs(c);
    return d >= r ? Math.round(c / r) + "d" : d >= i ? Math.round(c / i) + "h" : d >= a ? Math.round(c / a) + "m" : d >= e ? Math.round(c / e) + "s" : c + "ms";
  }
  function l(c) {
    var d = Math.abs(c);
    return d >= r ? u(c, d, r, "day") : d >= i ? u(c, d, i, "hour") : d >= a ? u(c, d, a, "minute") : d >= e ? u(c, d, e, "second") : c + " ms";
  }
  function u(c, d, f, v) {
    var g = d >= f * 1.5;
    return Math.round(c / f) + " " + v + (g ? "s" : "");
  }
  return Fl;
}
var Kl, rm;
function Ww() {
  if (rm) return Kl;
  rm = 1;
  function e(a) {
    r.debug = r, r.default = r, r.coerce = u, r.disable = o, r.enable = t, r.enabled = l, r.humanize = Uw(), r.destroy = c, Object.keys(a).forEach((d) => {
      r[d] = a[d];
    }), r.names = [], r.skips = [], r.formatters = {};
    function i(d) {
      let f = 0;
      for (let v = 0; v < d.length; v++)
        f = (f << 5) - f + d.charCodeAt(v), f |= 0;
      return r.colors[Math.abs(f) % r.colors.length];
    }
    r.selectColor = i;
    function r(d) {
      let f, v = null, g, h;
      function y(...m) {
        if (!y.enabled)
          return;
        const p = y, b = Number(/* @__PURE__ */ new Date()), w = b - (f || b);
        p.diff = w, p.prev = f, p.curr = b, f = b, m[0] = r.coerce(m[0]), typeof m[0] != "string" && m.unshift("%O");
        let k = 0;
        m[0] = m[0].replace(/%([a-zA-Z%])/g, (_, P) => {
          if (_ === "%%")
            return "%";
          k++;
          const M = r.formatters[P];
          if (typeof M == "function") {
            const q = m[k];
            _ = M.call(p, q), m.splice(k, 1), k--;
          }
          return _;
        }), r.formatArgs.call(p, m), (p.log || r.log).apply(p, m);
      }
      return y.namespace = d, y.useColors = r.useColors(), y.color = r.selectColor(d), y.extend = n, y.destroy = r.destroy, Object.defineProperty(y, "enabled", {
        enumerable: !0,
        configurable: !1,
        get: () => v !== null ? v : (g !== r.namespaces && (g = r.namespaces, h = r.enabled(d)), h),
        set: (m) => {
          v = m;
        }
      }), typeof r.init == "function" && r.init(y), y;
    }
    function n(d, f) {
      const v = r(this.namespace + (typeof f > "u" ? ":" : f) + d);
      return v.log = this.log, v;
    }
    function t(d) {
      r.save(d), r.namespaces = d, r.names = [], r.skips = [];
      const f = (typeof d == "string" ? d : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
      for (const v of f)
        v[0] === "-" ? r.skips.push(v.slice(1)) : r.names.push(v);
    }
    function s(d, f) {
      let v = 0, g = 0, h = -1, y = 0;
      for (; v < d.length; )
        if (g < f.length && (f[g] === d[v] || f[g] === "*"))
          f[g] === "*" ? (h = g, y = v, g++) : (v++, g++);
        else if (h !== -1)
          g = h + 1, y++, v = y;
        else
          return !1;
      for (; g < f.length && f[g] === "*"; )
        g++;
      return g === f.length;
    }
    function o() {
      const d = [
        ...r.names,
        ...r.skips.map((f) => "-" + f)
      ].join(",");
      return r.enable(""), d;
    }
    function l(d) {
      for (const f of r.skips)
        if (s(d, f))
          return !1;
      for (const f of r.names)
        if (s(d, f))
          return !0;
      return !1;
    }
    function u(d) {
      return d instanceof Error ? d.stack || d.message : d;
    }
    function c() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    return r.enable(r.load()), r;
  }
  return Kl = e, Kl;
}
var im;
function Gw() {
  return im || (im = 1, (function(e, a) {
    var i = {};
    a.formatArgs = n, a.save = t, a.load = s, a.useColors = r, a.storage = o(), a.destroy = /* @__PURE__ */ (() => {
      let u = !1;
      return () => {
        u || (u = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
      };
    })(), a.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function r() {
      if (typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs))
        return !0;
      if (typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))
        return !1;
      let u;
      return typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator < "u" && navigator.userAgent && (u = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(u[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function n(u) {
      if (u[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + u[0] + (this.useColors ? "%c " : " ") + "+" + e.exports.humanize(this.diff), !this.useColors)
        return;
      const c = "color: " + this.color;
      u.splice(1, 0, c, "color: inherit");
      let d = 0, f = 0;
      u[0].replace(/%[a-zA-Z%]/g, (v) => {
        v !== "%%" && (d++, v === "%c" && (f = d));
      }), u.splice(f, 0, c);
    }
    a.log = console.debug || console.log || (() => {
    });
    function t(u) {
      try {
        u ? a.storage.setItem("debug", u) : a.storage.removeItem("debug");
      } catch {
      }
    }
    function s() {
      let u;
      try {
        u = a.storage.getItem("debug") || a.storage.getItem("DEBUG");
      } catch {
      }
      return !u && typeof process < "u" && "env" in process && (u = i.DEBUG), u;
    }
    function o() {
      try {
        return localStorage;
      } catch {
      }
    }
    e.exports = Ww()(a);
    const { formatters: l } = e.exports;
    l.j = function(u) {
      try {
        return JSON.stringify(u);
      } catch (c) {
        return "[UnexpectedJSONParseError]: " + c.message;
      }
    };
  })(Wi, Wi.exports)), Wi.exports;
}
var Yw = Gw();
const Jt = /* @__PURE__ */ xr(Yw), Pe = [String, Function, Object, Array], Xw = /* @__PURE__ */ Symbol.for("vuetify:icons"), Ls = ee({
  icon: {
    type: Pe
  },
  // Could not remove this and use makeTagProps, types complained because it is not required
  tag: {
    type: [String, Object, Function],
    required: !0
  }
}, "icon"), sm = de()({
  name: "VComponentIcon",
  props: Ls(),
  setup(e, a) {
    let {
      slots: i
    } = a;
    return () => {
      const r = e.icon;
      return C(e.tag, null, {
        default: () => [e.icon ? C(r, null, null) : i.default?.()]
      });
    };
  }
}), Zw = ba({
  name: "VSvgIcon",
  inheritAttrs: !1,
  props: Ls(),
  setup(e, a) {
    let {
      attrs: i
    } = a;
    return () => C(e.tag, re(i, {
      style: null
    }), {
      default: () => [D("svg", {
        class: "v-icon__svg",
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 24 24",
        role: "img",
        "aria-hidden": "true"
      }, [Array.isArray(e.icon) ? e.icon.map((r) => Array.isArray(r) ? D("path", {
        d: r[0],
        "fill-opacity": r[1]
      }, null) : D("path", {
        d: r
      }, null)) : D("path", {
        d: e.icon
      }, null)])]
    });
  }
});
ba({
  name: "VLigatureIcon",
  props: Ls(),
  setup(e) {
    return () => C(e.tag, null, {
      default: () => [e.icon]
    });
  }
});
ba({
  name: "VClassIcon",
  props: Ls(),
  setup(e) {
    return () => C(e.tag, {
      class: ue(e.icon)
    }, null);
  }
});
const Jw = (e) => {
  const a = qe(Xw);
  if (!a) throw new Error("Missing Vuetify Icons provide!");
  return {
    iconData: I(() => {
      const r = ot(e);
      if (!r) return {
        component: sm
      };
      let n = r;
      if (typeof n == "string" && (n = n.trim(), n.startsWith("$") && (n = a.aliases?.[n.slice(1)])), n || Oa(`Could not find aliased icon "${r}"`), Array.isArray(n))
        return {
          component: Zw,
          icon: n
        };
      if (typeof n != "string")
        return {
          component: sm,
          icon: n
        };
      const t = Object.keys(a.sets).find((l) => typeof n == "string" && n.startsWith(`${l}:`)), s = t ? n.slice(t.length + 1) : n;
      return {
        component: a.sets[t ?? a.defaultSet].component,
        icon: s
      };
    })
  };
}, Qw = /* @__PURE__ */ Symbol.for("vuetify:date-options");
function eS(e, a, i) {
  const r = vp(e, a, i), n = [a];
  for (let t = 1; t < r; t++) {
    const s = e.addDays(a, t);
    n.push(s);
  }
  return i && n.push(e.endOfDay(i)), n;
}
function vp(e, a, i) {
  const r = [`${e.toISO(i ?? a).split("T")[0]}T00:00:00Z`, `${e.toISO(a).split("T")[0]}T00:00:00Z`];
  return typeof e.date() == "string" ? e.getDiff(r[0], r[1], "days") : e.getDiff(e.date(r[0]), e.date(r[1]), "days");
}
function tS(e, a) {
  const i = rn(typeof e.adapter == "function" ? new e.adapter({
    locale: e.locale[a.current.value] ?? a.current.value,
    formats: e.formats
  }) : e.adapter);
  return ce(a.current, (r) => {
    i.locale = e.locale[r] ?? r ?? i.locale;
  }), i;
}
function Fa() {
  const e = qe(Qw);
  if (!e) throw new Error("[Vuetify] Could not find injected date options");
  const a = nt();
  return tS(e, a);
}
const aS = /* @__PURE__ */ Symbol.for("vuetify:goto");
function nS() {
  return {
    container: void 0,
    duration: 300,
    layout: !1,
    offset: 0,
    easing: "easeInOutCubic",
    patterns: Ew
  };
}
function rS(e) {
  return Su(e) ?? (document.scrollingElement || document.body);
}
function Su(e) {
  return typeof e == "string" ? document.querySelector(e) : Nv(e);
}
function Hl(e, a, i) {
  if (typeof e == "number") return a && i ? -e : e;
  let r = Su(e), n = 0;
  for (; r; )
    n += a ? r.offsetLeft : r.offsetTop, r = r.offsetParent;
  return n;
}
async function lm(e, a, i, r) {
  const n = i ? "scrollLeft" : "scrollTop", t = Va(r?.options ?? nS(), a), s = r?.rtl.value, o = (typeof e == "number" ? e : Su(e)) ?? 0, l = t.container === "parent" && o instanceof HTMLElement ? o.parentElement : rS(t.container), u = cn() ? t.patterns.instant : typeof t.easing == "function" ? t.easing : t.patterns[t.easing];
  if (!u) throw new TypeError(`Easing function "${t.easing}" not found.`);
  let c;
  if (typeof o == "number")
    c = Hl(o, i, s);
  else if (c = Hl(o, i, s) - Hl(l, i, s), t.layout) {
    const g = window.getComputedStyle(o).getPropertyValue("--v-layout-top");
    g && (c -= parseInt(g, 10));
  }
  c += t.offset, c = sS(l, c, !!s, !!i);
  const d = l[n] ?? 0;
  if (c === d) return Promise.resolve(c);
  const f = performance.now();
  return new Promise((v) => requestAnimationFrame(function g(h) {
    const m = (h - f) / t.duration, p = Math.floor(d + (c - d) * u(Xe(m, 0, 1)));
    if (l[n] = p, m >= 1 && Math.abs(p - l[n]) < 10)
      return v(c);
    if (m > 2)
      return Oa("Scroll target is not reachable"), v(l[n]);
    requestAnimationFrame(g);
  }));
}
function iS() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const a = qe(aS), {
    isRtl: i
  } = St();
  if (!a) throw new Error("[Vuetify] Could not find injected goto instance");
  const r = {
    ...a,
    // can be set via VLocaleProvider
    rtl: W(() => a.rtl.value || i.value)
  };
  async function n(t, s) {
    return lm(t, Va(e, s), !1, r);
  }
  return n.horizontal = async (t, s) => lm(t, Va(e, s), !0, r), n;
}
function sS(e, a, i, r) {
  const {
    scrollWidth: n,
    scrollHeight: t
  } = e, [s, o] = e === document.scrollingElement ? [window.innerWidth, window.innerHeight] : [e.offsetWidth, e.offsetHeight];
  let l, u;
  return r ? i ? (l = -(n - s), u = 0) : (l = 0, u = n - s) : (l = 0, u = t + -o), Xe(a, l, u);
}
const Po = /* @__PURE__ */ Symbol.for("vuetify:theme"), Qe = ee({
  theme: String
}, "theme");
function ut(e) {
  ft("provideTheme");
  const a = qe(Po, null);
  if (!a) throw new Error("Could not find Vuetify theme injection");
  const i = W(() => e.theme ?? a.name.value), r = W(() => a.themes.value[i.value]), n = W(() => a.isDisabled ? void 0 : `${a.prefix}theme--${i.value}`), t = {
    ...a,
    name: i,
    current: r,
    themeClasses: n
  };
  return ht(Po, t), t;
}
function qs() {
  ft("useTheme");
  const e = qe(Po, null);
  if (!e) throw new Error("Could not find Vuetify theme injection");
  return e;
}
function fn(e) {
  let a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "content";
  const i = ps(), r = ie();
  if (et) {
    const n = new ResizeObserver((t) => {
      e?.(t, n), t.length && (a === "content" ? r.value = t[0].contentRect : r.value = t[0].target.getBoundingClientRect());
    });
    ha(() => {
      n.disconnect();
    }), ce(() => i.el, (t, s) => {
      s && (n.unobserve(s), r.value = void 0), t && n.observe(t);
    }, {
      flush: "post"
    });
  }
  return {
    resizeRef: i,
    contentRect: Uo(r)
  };
}
const lS = ee({
  defaults: Object,
  disabled: Boolean,
  reset: [Number, String],
  root: [Boolean, String],
  scoped: Boolean
}, "VDefaultsProvider"), je = de(!1)({
  name: "VDefaultsProvider",
  props: lS(),
  setup(e, a) {
    let {
      slots: i
    } = a;
    const {
      defaults: r,
      disabled: n,
      reset: t,
      root: s,
      scoped: o
    } = Gm(e);
    return da(r, {
      reset: t,
      root: s,
      scoped: o,
      disabled: n
    }), () => i.default?.();
  }
}), sr = {
  props: {
    layoutSlot: {
      /** @type import('vue').PropType<import('@json-layout/vocabulary').Slot> */
      type: Object,
      required: !0
    },
    node: {
      /** @type import('vue').PropType<import('../../types.js').VjsfNode> */
      type: Object,
      required: !0
    },
    statefulLayout: {
      /** @type import('vue').PropType<import('../../types.js').VjsfStatefulLayout> */
      type: Object,
      required: !0
    },
    initialContext: {
      /** @type import('vue').PropType<Record<string, any>> */
      type: Object,
      default: () => {
      }
    },
    tag: {
      /** @type import('vue').PropType<string> */
      type: String,
      default: null
    }
  },
  render() {
    const e = this.tag ?? (Oc(this.layoutSlot) ? "p" : "div");
    if (Oc(this.layoutSlot))
      return Oe(e, this.layoutSlot.text);
    if (ng(this.layoutSlot))
      return Oe(e, { innerHTML: this.layoutSlot.markdown });
    if (rg(this.layoutSlot))
      if (!this.statefulLayout.options.vjsfSlots[this.layoutSlot.name])
        console.error(`vjsf: layout references a code slot "${this.layoutSlot.name}" that was not provided.`);
      else {
        const a = {
          ...this.initialContext,
          ...this.layoutSlot.props,
          node: this.node,
          statefulLayout: this.statefulLayout
        };
        return Oe(e, this.statefulLayout.options.vjsfSlots[this.layoutSlot.name](a));
      }
    return null;
  }
}, oS = Fn("v-alert-title"), Aa = ee({
  border: [Boolean, Number, String]
}, "border");
function Ta(e) {
  let a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ga();
  return {
    borderClasses: I(() => {
      const r = e.border;
      return r === !0 || r === "" ? `${a}--border` : typeof r == "string" || r === 0 ? String(r).split(" ").map((n) => `border-${n}`) : [];
    })
  };
}
const uS = [null, "default", "comfortable", "compact"], Kt = ee({
  density: {
    type: String,
    default: "default",
    validator: (e) => uS.includes(e)
  }
}, "density");
function Qt(e) {
  let a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ga();
  return {
    densityClasses: W(() => `${a}--density-${e.density}`)
  };
}
const ea = ee({
  elevation: {
    type: [Number, String],
    validator(e) {
      const a = parseInt(e);
      return !isNaN(a) && a >= 0 && // Material Design has a maximum elevation of 24
      // https://material.io/design/environment/elevation.html#default-elevations
      a <= 24;
    }
  }
}, "elevation");
function ta(e) {
  return {
    elevationClasses: W(() => {
      const i = ns(e) ? e.value : e.elevation;
      return i == null ? [] : [`elevation-${i}`];
    })
  };
}
const $t = ee({
  rounded: {
    type: [Boolean, Number, String],
    default: void 0
  },
  tile: Boolean
}, "rounded");
function _t(e) {
  let a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ga();
  return {
    roundedClasses: I(() => {
      const r = ns(e) ? e.value : e.rounded, n = ns(e) ? !1 : e.tile, t = [];
      if (n || r === !1)
        t.push("rounded-0");
      else if (r === !0 || r === "")
        t.push(`${a}--rounded`);
      else if (typeof r == "string" || r === 0)
        for (const s of String(r).split(" "))
          t.push(`rounded-${s}`);
      return t;
    })
  };
}
function $u(e) {
  return vu(() => {
    const {
      class: a,
      style: i
    } = cS(e);
    return {
      colorClasses: a,
      colorStyles: i
    };
  });
}
function kt(e) {
  const {
    colorClasses: a,
    colorStyles: i
  } = $u(() => ({
    text: ot(e)
  }));
  return {
    textColorClasses: a,
    textColorStyles: i
  };
}
function at(e) {
  const {
    colorClasses: a,
    colorStyles: i
  } = $u(() => ({
    background: ot(e)
  }));
  return {
    backgroundColorClasses: a,
    backgroundColorStyles: i
  };
}
function cS(e) {
  const a = ot(e), i = [], r = {};
  if (a.background)
    if ($o(a.background)) {
      if (r.backgroundColor = a.background, !a.text && kw(a.background)) {
        const n = Ia(a.background);
        if (n.a == null || n.a === 1) {
          const t = Cw(n);
          r.color = t, r.caretColor = t;
        }
      }
    } else
      i.push(`bg-${a.background}`);
  return a.text && ($o(a.text) ? (r.color = a.text, r.caretColor = a.text) : i.push(`text-${a.text}`)), {
    class: i,
    style: r
  };
}
const dS = ["elevated", "flat", "tonal", "outlined", "text", "plain"];
function yn(e, a) {
  return D(pe, null, [e && D("span", {
    key: "overlay",
    class: ue(`${a}__overlay`)
  }, null), D("span", {
    key: "underlay",
    class: ue(`${a}__underlay`)
  }, null)]);
}
const ja = ee({
  color: String,
  variant: {
    type: String,
    default: "elevated",
    validator: (e) => dS.includes(e)
  }
}, "variant");
function Kn(e) {
  let a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ga();
  const i = W(() => {
    const {
      variant: t
    } = ot(e);
    return `${a}--variant-${t}`;
  }), {
    colorClasses: r,
    colorStyles: n
  } = $u(() => {
    const {
      variant: t,
      color: s
    } = ot(e);
    return {
      [["elevated", "flat"].includes(t) ? "background" : "text"]: s
    };
  });
  return {
    colorClasses: r,
    colorStyles: n,
    variantClasses: i
  };
}
const pp = ee({
  baseColor: String,
  divided: Boolean,
  direction: {
    type: String,
    default: "horizontal"
  },
  ...Aa(),
  ...Se(),
  ...Kt(),
  ...ea(),
  ...$t(),
  ...Be(),
  ...Qe(),
  ...ja()
}, "VBtnGroup"), om = de()({
  name: "VBtnGroup",
  props: pp(),
  setup(e, a) {
    let {
      slots: i
    } = a;
    const {
      themeClasses: r
    } = ut(e), {
      densityClasses: n
    } = Qt(e), {
      borderClasses: t
    } = Ta(e), {
      elevationClasses: s
    } = ta(e), {
      roundedClasses: o
    } = _t(e);
    da({
      VBtn: {
        height: W(() => e.direction === "horizontal" ? "auto" : null),
        baseColor: W(() => e.baseColor),
        color: W(() => e.color),
        density: W(() => e.density),
        flat: !0,
        variant: W(() => e.variant)
      }
    }), me(() => C(e.tag, {
      class: ue(["v-btn-group", `v-btn-group--${e.direction}`, {
        "v-btn-group--divided": e.divided
      }, r.value, t.value, n.value, s.value, o.value, e.class]),
      style: be(e.style)
    }, i));
  }
}), Mr = ee({
  modelValue: {
    type: null,
    default: void 0
  },
  multiple: Boolean,
  mandatory: [Boolean, String],
  max: Number,
  selectedClass: String,
  disabled: Boolean
}, "group"), Rr = ee({
  value: null,
  disabled: Boolean,
  selectedClass: String
}, "group-item");
function jn(e, a) {
  let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0;
  const r = ft("useGroupItem");
  if (!r)
    throw new Error("[Vuetify] useGroupItem composable must be used inside a component setup function");
  const n = Xt();
  ht(/* @__PURE__ */ Symbol.for(`${a.description}:id`), n);
  const t = qe(a, null);
  if (!t) {
    if (!i) return t;
    throw new Error(`[Vuetify] Could not find useGroup injection with symbol ${a.description}`);
  }
  const s = W(() => e.value), o = I(() => !!(t.disabled.value || e.disabled));
  function l() {
    t?.register({
      id: n,
      value: s,
      disabled: o
    }, r);
  }
  function u() {
    t?.unregister(n);
  }
  l(), ha(() => u());
  const c = I(() => t.isSelected(n)), d = I(() => t.items.value[0].id === n), f = I(() => t.items.value[t.items.value.length - 1].id === n), v = I(() => c.value && [t.selectedClass.value, e.selectedClass]);
  return ce(c, (g) => {
    r.emit("group:selected", {
      value: g
    });
  }, {
    flush: "sync"
  }), {
    id: n,
    isSelected: c,
    isFirst: d,
    isLast: f,
    toggle: () => t.select(n, !c.value),
    select: (g) => t.select(n, g),
    selectedClass: v,
    value: s,
    disabled: o,
    group: t,
    register: l,
    unregister: u
  };
}
function Hn(e, a) {
  let i = !1;
  const r = rn([]), n = $e(e, "modelValue", [], (f) => f === void 0 ? [] : hp(r, f === null ? [null] : Ze(f)), (f) => {
    const v = mS(r, f);
    return e.multiple ? v : v[0];
  }), t = ft("useGroup");
  function s(f, v) {
    const g = f, h = /* @__PURE__ */ Symbol.for(`${a.description}:id`), m = ir(h, t?.vnode).indexOf(v);
    Y(g.value) === void 0 && (g.value = m, g.useIndexAsValue = !0), m > -1 ? r.splice(m, 0, g) : r.push(g);
  }
  function o(f) {
    if (i) return;
    l();
    const v = r.findIndex((g) => g.id === f);
    r.splice(v, 1);
  }
  function l() {
    const f = r.find((v) => !v.disabled);
    f && e.mandatory === "force" && !n.value.length && (n.value = [f.id]);
  }
  ua(() => {
    l();
  }), ha(() => {
    i = !0;
  }), sy(() => {
    for (let f = 0; f < r.length; f++)
      r[f].useIndexAsValue && (r[f].value = f);
  });
  function u(f, v) {
    const g = r.find((h) => h.id === f);
    if (!(v && g?.disabled))
      if (e.multiple) {
        const h = n.value.slice(), y = h.findIndex((p) => p === f), m = ~y;
        if (v = v ?? !m, m && e.mandatory && h.length <= 1 || !m && e.max != null && h.length + 1 > e.max) return;
        y < 0 && v ? h.push(f) : y >= 0 && !v && h.splice(y, 1), n.value = h;
      } else {
        const h = n.value.includes(f);
        if (e.mandatory && h || !h && !v) return;
        n.value = v ?? !h ? [f] : [];
      }
  }
  function c(f) {
    if (e.multiple && Oa('This method is not supported when using "multiple" prop'), n.value.length) {
      const v = n.value[0], g = r.findIndex((m) => m.id === v);
      let h = (g + f) % r.length, y = r[h];
      for (; y.disabled && h !== g; )
        h = (h + f) % r.length, y = r[h];
      if (y.disabled) return;
      n.value = [r[h].id];
    } else {
      const v = r.find((g) => !g.disabled);
      v && (n.value = [v.id]);
    }
  }
  const d = {
    register: s,
    unregister: o,
    selected: n,
    select: u,
    disabled: W(() => e.disabled),
    prev: () => c(r.length - 1),
    next: () => c(1),
    isSelected: (f) => n.value.includes(f),
    selectedClass: W(() => e.selectedClass),
    items: W(() => r),
    getItemIndex: (f) => fS(r, f)
  };
  return ht(a, d), d;
}
function fS(e, a) {
  const i = hp(e, [a]);
  return i.length ? e.findIndex((r) => r.id === i[0]) : -1;
}
function hp(e, a) {
  const i = [];
  return a.forEach((r) => {
    const n = e.find((s) => bt(r, s.value)), t = e[r];
    n?.value !== void 0 ? i.push(n.id) : t?.useIndexAsValue && i.push(t.id);
  }), i;
}
function mS(e, a) {
  const i = [];
  return a.forEach((r) => {
    const n = e.findIndex((t) => t.id === r);
    if (~n) {
      const t = e[n];
      i.push(t.value !== void 0 ? t.value : n);
    }
  }), i;
}
const yp = /* @__PURE__ */ Symbol.for("vuetify:v-btn-toggle"), vS = ee({
  ...pp(),
  ...Mr()
}, "VBtnToggle");
de()({
  name: "VBtnToggle",
  props: vS(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, a) {
    let {
      slots: i
    } = a;
    const {
      isSelected: r,
      next: n,
      prev: t,
      select: s,
      selected: o
    } = Hn(e, yp);
    return me(() => {
      const l = om.filterProps(e);
      return C(om, re({
        class: ["v-btn-toggle", e.class]
      }, l, {
        style: e.style
      }), {
        default: () => [i.default?.({
          isSelected: r,
          next: n,
          prev: t,
          select: s,
          selected: o
        })]
      });
    }), {
      next: n,
      prev: t,
      select: s
    };
  }
});
const pS = ["x-small", "small", "default", "large", "x-large"], Nr = ee({
  size: {
    type: [String, Number],
    default: "default"
  }
}, "size");
function Lr(e) {
  let a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ga();
  return vu(() => {
    const i = e.size;
    let r, n;
    return vs(pS, i) ? r = `${a}--size-${i}` : i && (n = {
      width: he(i),
      height: he(i)
    }), {
      sizeClasses: r,
      sizeStyles: n
    };
  });
}
const hS = ee({
  color: String,
  disabled: Boolean,
  start: Boolean,
  end: Boolean,
  icon: Pe,
  opacity: [String, Number],
  ...Se(),
  ...Nr(),
  ...Be({
    tag: "i"
  }),
  ...Qe()
}, "VIcon"), xe = de()({
  name: "VIcon",
  props: hS(),
  setup(e, a) {
    let {
      attrs: i,
      slots: r
    } = a;
    const n = fe(), {
      themeClasses: t
    } = qs(), {
      iconData: s
    } = Jw(() => n.value || e.icon), {
      sizeClasses: o
    } = Lr(e), {
      textColorClasses: l,
      textColorStyles: u
    } = kt(() => e.color);
    return me(() => {
      const c = r.default?.();
      c && (n.value = Fv(c).filter((f) => f.type === ly && f.children && typeof f.children == "string")[0]?.children);
      const d = !!(i.onClick || i.onClickOnce);
      return C(s.value.component, {
        tag: e.tag,
        icon: s.value.icon,
        class: ue(["v-icon", "notranslate", t.value, o.value, l.value, {
          "v-icon--clickable": d,
          "v-icon--disabled": e.disabled,
          "v-icon--start": e.start,
          "v-icon--end": e.end
        }, e.class]),
        style: be([{
          "--v-icon-opacity": e.opacity
        }, o.value ? void 0 : {
          fontSize: he(e.size),
          height: he(e.size),
          width: he(e.size)
        }, u.value, e.style]),
        role: d ? "button" : void 0,
        "aria-hidden": !d,
        tabindex: d ? e.disabled ? -1 : 0 : void 0
      }, {
        default: () => [c]
      });
    }), {};
  }
});
function gp(e, a) {
  const i = ie(), r = fe(!1);
  if (mu) {
    const n = new IntersectionObserver((t) => {
      r.value = !!t.find((s) => s.isIntersecting);
    }, a);
    st(() => {
      n.disconnect();
    }), ce(i, (t, s) => {
      s && (n.unobserve(s), r.value = !1), t && n.observe(t);
    }, {
      flush: "post"
    });
  }
  return {
    intersectionRef: i,
    isIntersecting: r
  };
}
const yS = ee({
  bgColor: String,
  color: String,
  indeterminate: [Boolean, String],
  rounded: Boolean,
  modelValue: {
    type: [Number, String],
    default: 0
  },
  rotate: {
    type: [Number, String],
    default: 0
  },
  width: {
    type: [Number, String],
    default: 4
  },
  ...Se(),
  ...Nr(),
  ...Be({
    tag: "div"
  }),
  ...Qe()
}, "VProgressCircular"), bp = de()({
  name: "VProgressCircular",
  props: yS(),
  setup(e, a) {
    let {
      slots: i
    } = a;
    const r = 20, n = 2 * Math.PI * r, t = ie(), {
      themeClasses: s
    } = ut(e), {
      sizeClasses: o,
      sizeStyles: l
    } = Lr(e), {
      textColorClasses: u,
      textColorStyles: c
    } = kt(() => e.color), {
      textColorClasses: d,
      textColorStyles: f
    } = kt(() => e.bgColor), {
      intersectionRef: v,
      isIntersecting: g
    } = gp(), {
      resizeRef: h,
      contentRect: y
    } = fn(), m = W(() => Xe(parseFloat(e.modelValue), 0, 100)), p = W(() => Number(e.width)), b = W(() => l.value ? Number(e.size) : y.value ? y.value.width : Math.max(p.value, 32)), w = W(() => r / (1 - p.value / b.value) * 2), k = W(() => p.value / b.value * w.value), S = W(() => {
      const P = (100 - m.value) / 100 * n;
      return e.rounded && m.value > 0 && m.value < 100 ? he(Math.min(n - 0.01, P + k.value)) : he(P);
    }), _ = I(() => {
      const P = Number(e.rotate);
      return e.rounded ? P + k.value / 2 / n * 360 : P;
    });
    return wt(() => {
      v.value = t.value, h.value = t.value;
    }), me(() => C(e.tag, {
      ref: t,
      class: ue(["v-progress-circular", {
        "v-progress-circular--indeterminate": !!e.indeterminate,
        "v-progress-circular--visible": g.value,
        "v-progress-circular--disable-shrink": e.indeterminate && (e.indeterminate === "disable-shrink" || cn())
      }, s.value, o.value, u.value, e.class]),
      style: be([l.value, c.value, e.style]),
      role: "progressbar",
      "aria-valuemin": "0",
      "aria-valuemax": "100",
      "aria-valuenow": e.indeterminate ? void 0 : m.value
    }, {
      default: () => [D("svg", {
        style: {
          transform: `rotate(calc(-90deg + ${_.value}deg))`
        },
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: `0 0 ${w.value} ${w.value}`
      }, [D("circle", {
        class: ue(["v-progress-circular__underlay", d.value]),
        style: be(f.value),
        fill: "transparent",
        cx: "50%",
        cy: "50%",
        r,
        "stroke-width": k.value,
        "stroke-dasharray": n,
        "stroke-dashoffset": 0
      }, null), D("circle", {
        class: "v-progress-circular__overlay",
        fill: "transparent",
        cx: "50%",
        cy: "50%",
        r,
        "stroke-width": k.value,
        "stroke-dasharray": n,
        "stroke-dashoffset": S.value,
        "stroke-linecap": e.rounded ? "round" : void 0
      }, null)]), i.default && D("div", {
        class: "v-progress-circular__content"
      }, [i.default({
        value: m.value
      })])]
    })), {};
  }
}), um = {
  center: "center",
  top: "bottom",
  bottom: "top",
  left: "right",
  right: "left"
}, Un = ee({
  location: String
}, "location");
function Wn(e) {
  let a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, i = arguments.length > 2 ? arguments[2] : void 0;
  const {
    isRtl: r
  } = St();
  return {
    locationStyles: I(() => {
      if (!e.location) return {};
      const {
        side: t,
        align: s
      } = So(e.location.split(" ").length > 1 ? e.location : `${e.location} center`, r.value);
      function o(u) {
        return i ? i(u) : 0;
      }
      const l = {};
      return t !== "center" && (a ? l[um[t]] = `calc(100% - ${o(t)}px)` : l[t] = 0), s !== "center" ? a ? l[um[s]] = `calc(100% - ${o(s)}px)` : l[s] = 0 : (t === "center" ? l.top = l.left = "50%" : l[{
        top: "left",
        bottom: "left",
        left: "top",
        right: "top"
      }[t]] = "50%", l.transform = {
        top: "translateX(-50%)",
        bottom: "translateX(-50%)",
        left: "translateY(-50%)",
        right: "translateY(-50%)",
        center: "translate(-50%, -50%)"
      }[t]), l;
    })
  };
}
const gS = ee({
  chunkCount: {
    type: [Number, String],
    default: null
  },
  chunkWidth: {
    type: [Number, String],
    default: null
  },
  chunkGap: {
    type: [Number, String],
    default: 4
  }
}, "chunks");
function bS(e, a) {
  const i = W(() => !!e.chunkCount || !!e.chunkWidth), r = I(() => {
    const o = ot(a);
    if (!o)
      return 0;
    if (!e.chunkCount)
      return Number(e.chunkWidth);
    const l = Number(e.chunkCount);
    return (o - Number(e.chunkGap) * (l - 1)) / l;
  }), n = W(() => Number(e.chunkGap)), t = I(() => {
    if (!i.value)
      return {};
    const o = he(n.value), l = he(r.value);
    return {
      maskRepeat: "repeat-x",
      maskImage: `linear-gradient(90deg, #000, #000 ${l}, transparent ${l}, transparent)`,
      maskSize: `calc(${l} + ${o}) 100%`
    };
  });
  function s(o) {
    const l = ot(a);
    if (!l)
      return o;
    const u = 100 * n.value / l, c = 100 * (r.value + n.value) / l, d = Math.floor((o + u) / c);
    return Xe(0, d * c - u / 2, 100);
  }
  return {
    hasChunks: i,
    chunksMaskStyles: t,
    snapValueToChunk: s
  };
}
const kS = ee({
  absolute: Boolean,
  active: {
    type: Boolean,
    default: !0
  },
  bgColor: String,
  bgOpacity: [Number, String],
  bufferValue: {
    type: [Number, String],
    default: 0
  },
  bufferColor: String,
  bufferOpacity: [Number, String],
  clickable: Boolean,
  color: String,
  height: {
    type: [Number, String],
    default: 4
  },
  indeterminate: Boolean,
  max: {
    type: [Number, String],
    default: 100
  },
  modelValue: {
    type: [Number, String],
    default: 0
  },
  opacity: [Number, String],
  reverse: Boolean,
  stream: Boolean,
  striped: Boolean,
  roundedBar: Boolean,
  ...gS(),
  ...Se(),
  ...Un({
    location: "top"
  }),
  ...$t(),
  ...Be(),
  ...Qe()
}, "VProgressLinear"), wS = de()({
  name: "VProgressLinear",
  props: kS(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, a) {
    let {
      slots: i
    } = a;
    const r = ie(), n = $e(e, "modelValue"), {
      isRtl: t,
      rtlClasses: s
    } = St(), {
      themeClasses: o
    } = ut(e), {
      locationStyles: l
    } = Wn(e), {
      textColorClasses: u,
      textColorStyles: c
    } = kt(() => e.color), {
      backgroundColorClasses: d,
      backgroundColorStyles: f
    } = at(() => e.bgColor || e.color), {
      backgroundColorClasses: v,
      backgroundColorStyles: g
    } = at(() => e.bufferColor || e.bgColor || e.color), {
      backgroundColorClasses: h,
      backgroundColorStyles: y
    } = at(() => e.color), {
      roundedClasses: m
    } = _t(e), {
      intersectionRef: p,
      isIntersecting: b
    } = gp(), w = I(() => parseFloat(e.max)), k = I(() => parseFloat(e.height)), S = I(() => Xe(parseFloat(e.bufferValue) / w.value * 100, 0, 100)), _ = I(() => Xe(parseFloat(n.value) / w.value * 100, 0, 100)), P = I(() => t.value !== e.reverse), M = I(() => e.indeterminate ? "fade-transition" : "slide-x-transition"), q = fe(0), {
      hasChunks: K,
      chunksMaskStyles: j,
      snapValueToChunk: H
    } = bS(e, q);
    Na(K, () => {
      const {
        resizeRef: U
      } = fn((Z) => q.value = Z[0].contentRect.width);
      wt(() => U.value = r.value);
    });
    const B = I(() => K.value ? H(S.value) : S.value), L = I(() => K.value ? H(_.value) : _.value);
    function O(U) {
      if (!p.value) return;
      const {
        left: Z,
        right: J,
        width: A
      } = p.value.getBoundingClientRect(), T = P.value ? A - U.clientX + (J - A) : U.clientX - Z;
      n.value = Math.round(T / A * w.value);
    }
    return wt(() => {
      p.value = r.value;
    }), me(() => C(e.tag, {
      ref: r,
      class: ue(["v-progress-linear", {
        "v-progress-linear--absolute": e.absolute,
        "v-progress-linear--active": e.active && b.value,
        "v-progress-linear--reverse": P.value,
        "v-progress-linear--rounded": e.rounded,
        "v-progress-linear--rounded-bar": e.roundedBar,
        "v-progress-linear--striped": e.striped,
        "v-progress-linear--clickable": e.clickable
      }, m.value, o.value, s.value, e.class]),
      style: be([{
        bottom: e.location === "bottom" ? 0 : void 0,
        top: e.location === "top" ? 0 : void 0,
        height: e.active ? he(k.value) : 0,
        "--v-progress-linear-height": he(k.value),
        ...e.absolute ? l.value : {}
      }, j.value, e.style]),
      role: "progressbar",
      "aria-hidden": e.active ? "false" : "true",
      "aria-valuemin": "0",
      "aria-valuemax": e.max,
      "aria-valuenow": e.indeterminate ? void 0 : Math.min(parseFloat(n.value), w.value),
      onClick: e.clickable && O
    }, {
      default: () => [e.stream && D("div", {
        key: "stream",
        class: ue(["v-progress-linear__stream", u.value]),
        style: {
          ...c.value,
          [P.value ? "left" : "right"]: he(-k.value),
          borderTop: `${he(k.value / 2)} dotted`,
          opacity: parseFloat(e.bufferOpacity),
          top: `calc(50% - ${he(k.value / 4)})`,
          width: he(100 - S.value, "%"),
          "--v-progress-linear-stream-to": he(k.value * (P.value ? 1 : -1))
        }
      }, null), D("div", {
        class: ue(["v-progress-linear__background", d.value]),
        style: be([f.value, {
          opacity: parseFloat(e.bgOpacity),
          width: e.stream ? 0 : void 0
        }])
      }, null), D("div", {
        class: ue(["v-progress-linear__buffer", v.value]),
        style: be([g.value, {
          opacity: parseFloat(e.bufferOpacity),
          width: he(B.value, "%")
        }])
      }, null), C(sn, {
        name: M.value
      }, {
        default: () => [e.indeterminate ? D("div", {
          class: "v-progress-linear__indeterminate"
        }, [["long", "short"].map((U) => D("div", {
          key: U,
          class: ue(["v-progress-linear__indeterminate", U, h.value]),
          style: be(y.value)
        }, null))]) : D("div", {
          class: ue(["v-progress-linear__determinate", h.value]),
          style: be([y.value, {
            width: he(L.value, "%")
          }])
        }, null)]
      }), i.default && D("div", {
        class: "v-progress-linear__content"
      }, [i.default({
        value: _.value,
        buffer: S.value
      })])]
    })), {};
  }
}), _u = ee({
  loading: [Boolean, String]
}, "loader");
function zs(e) {
  let a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ga();
  return {
    loaderClasses: W(() => ({
      [`${a}--loading`]: e.loading
    }))
  };
}
function Pu(e, a) {
  let {
    slots: i
  } = a;
  return D("div", {
    class: ue(`${e.name}__loader`)
  }, [i.default?.({
    color: e.color,
    isActive: e.active
  }) || C(wS, {
    absolute: e.absolute,
    active: e.active,
    color: e.color,
    height: "2",
    indeterminate: !0
  }, null)]);
}
const SS = ["static", "relative", "fixed", "absolute", "sticky"], Bs = ee({
  position: {
    type: String,
    validator: (
      /* istanbul ignore next */
      (e) => SS.includes(e)
    )
  }
}, "position");
function Fs(e) {
  let a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ga();
  return {
    positionClasses: W(() => e.position ? `${a}--${e.position}` : void 0)
  };
}
function $S() {
  const e = ft("useRoute");
  return I(() => e?.proxy?.$route);
}
function _S() {
  return ft("useRouter")?.proxy?.$router;
}
function Ks(e, a) {
  const i = Wo("RouterLink"), r = W(() => !!(e.href || e.to)), n = I(() => r?.value || Mf(a, "click") || Mf(e, "click"));
  if (typeof i == "string" || !("useLink" in i)) {
    const d = W(() => e.href);
    return {
      isLink: r,
      isRouterLink: W(() => !1),
      isClickable: n,
      href: d,
      linkProps: rn({
        href: d
      })
    };
  }
  const t = i.useLink({
    to: W(() => e.to || ""),
    replace: W(() => e.replace)
  }), s = I(() => e.to ? t : void 0), o = $S(), l = I(() => s.value ? e.exact ? o.value ? s.value.isExactActive?.value && bt(s.value.route.value.query, o.value.query) : s.value.isExactActive?.value ?? !1 : s.value.isActive?.value ?? !1 : !1), u = I(() => e.to ? s.value?.route.value.href : e.href), c = W(() => !!e.to);
  return {
    isLink: r,
    isRouterLink: c,
    isClickable: n,
    isActive: l,
    route: s.value?.route,
    navigate: s.value?.navigate,
    href: u,
    linkProps: rn({
      href: u,
      "aria-current": W(() => l.value ? "page" : void 0),
      "aria-disabled": W(() => e.disabled && r.value ? "true" : void 0),
      tabindex: W(() => e.disabled && r.value ? "-1" : void 0)
    })
  };
}
const Hs = ee({
  href: String,
  replace: Boolean,
  to: [String, Object],
  exact: Boolean
}, "router");
let Ul = !1;
function PS(e, a) {
  let i = !1, r, n;
  et && e?.beforeEach && (Ee(() => {
    window.addEventListener("popstate", t), r = e.beforeEach((s, o, l) => {
      Ul ? i ? a(l) : l() : setTimeout(() => i ? a(l) : l()), Ul = !0;
    }), n = e?.afterEach(() => {
      Ul = !1;
    });
  }), st(() => {
    window.removeEventListener("popstate", t), r?.(), n?.();
  }));
  function t(s) {
    s.state?.replaced || (i = !0, setTimeout(() => i = !1));
  }
}
function CS(e, a) {
  ce(() => e.isActive?.value, (i) => {
    e.isLink.value && i != null && a && Ee(() => {
      a(i);
    });
  }, {
    immediate: !0
  });
}
const Co = /* @__PURE__ */ Symbol("rippleStop"), xS = 80;
function cm(e, a) {
  e.style.transform = a, e.style.webkitTransform = a;
}
function xo(e) {
  return e.constructor.name === "TouchEvent";
}
function kp(e) {
  return e.constructor.name === "KeyboardEvent";
}
const VS = function(e, a) {
  let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, r = 0, n = 0;
  if (!kp(e)) {
    const d = a.getBoundingClientRect(), f = xo(e) ? e.touches[e.touches.length - 1] : e;
    r = f.clientX - d.left, n = f.clientY - d.top;
  }
  let t = 0, s = 0.3;
  a._ripple?.circle ? (s = 0.15, t = a.clientWidth / 2, t = i.center ? t : t + Math.sqrt((r - t) ** 2 + (n - t) ** 2) / 4) : t = Math.sqrt(a.clientWidth ** 2 + a.clientHeight ** 2) / 2;
  const o = `${(a.clientWidth - t * 2) / 2}px`, l = `${(a.clientHeight - t * 2) / 2}px`, u = i.center ? o : `${r - t}px`, c = i.center ? l : `${n - t}px`;
  return {
    radius: t,
    scale: s,
    x: u,
    y: c,
    centerX: o,
    centerY: l
  };
}, bs = {
  /* eslint-disable max-statements */
  show(e, a) {
    let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!a?._ripple?.enabled)
      return;
    const r = document.createElement("span"), n = document.createElement("span");
    r.appendChild(n), r.className = "v-ripple__container", i.class && (r.className += ` ${i.class}`);
    const {
      radius: t,
      scale: s,
      x: o,
      y: l,
      centerX: u,
      centerY: c
    } = VS(e, a, i), d = `${t * 2}px`;
    n.className = "v-ripple__animation", n.style.width = d, n.style.height = d, a.appendChild(r);
    const f = window.getComputedStyle(a);
    f && f.position === "static" && (a.style.position = "relative", a.dataset.previousPosition = "static"), n.classList.add("v-ripple__animation--enter"), n.classList.add("v-ripple__animation--visible"), cm(n, `translate(${o}, ${l}) scale3d(${s},${s},${s})`), n.dataset.activated = String(performance.now()), requestAnimationFrame(() => {
      requestAnimationFrame(() => {
        n.classList.remove("v-ripple__animation--enter"), n.classList.add("v-ripple__animation--in"), cm(n, `translate(${u}, ${c}) scale3d(1,1,1)`);
      });
    });
  },
  hide(e) {
    if (!e?._ripple?.enabled) return;
    const a = e.getElementsByClassName("v-ripple__animation");
    if (a.length === 0) return;
    const i = Array.from(a).findLast((t) => !t.dataset.isHiding);
    if (i) i.dataset.isHiding = "true";
    else return;
    const r = performance.now() - Number(i.dataset.activated), n = Math.max(250 - r, 0);
    setTimeout(() => {
      i.classList.remove("v-ripple__animation--in"), i.classList.add("v-ripple__animation--out"), setTimeout(() => {
        e.getElementsByClassName("v-ripple__animation").length === 1 && e.dataset.previousPosition && (e.style.position = e.dataset.previousPosition, delete e.dataset.previousPosition), i.parentNode?.parentNode === e && e.removeChild(i.parentNode);
      }, 300);
    }, n);
  }
};
function wp(e) {
  return typeof e > "u" || !!e;
}
function gr(e) {
  const a = {}, i = e.currentTarget;
  if (!(!i?._ripple || i._ripple.touched || e[Co])) {
    if (e[Co] = !0, xo(e))
      i._ripple.touched = !0, i._ripple.isTouch = !0;
    else if (i._ripple.isTouch) return;
    if (a.center = i._ripple.centered || kp(e), i._ripple.class && (a.class = i._ripple.class), xo(e)) {
      if (i._ripple.showTimerCommit) return;
      i._ripple.showTimerCommit = () => {
        bs.show(e, i, a);
      }, i._ripple.showTimer = window.setTimeout(() => {
        i?._ripple?.showTimerCommit && (i._ripple.showTimerCommit(), i._ripple.showTimerCommit = null);
      }, xS);
    } else
      bs.show(e, i, a);
  }
}
function ks(e) {
  e[Co] = !0;
}
function Bt(e) {
  const a = e.currentTarget;
  if (a?._ripple) {
    if (window.clearTimeout(a._ripple.showTimer), e.type === "touchend" && a._ripple.showTimerCommit) {
      a._ripple.showTimerCommit(), a._ripple.showTimerCommit = null, a._ripple.showTimer = window.setTimeout(() => {
        Bt(e);
      });
      return;
    }
    window.setTimeout(() => {
      a._ripple && (a._ripple.touched = !1);
    }), bs.hide(a);
  }
}
function Sp(e) {
  const a = e.currentTarget;
  a?._ripple && (a._ripple.showTimerCommit && (a._ripple.showTimerCommit = null), window.clearTimeout(a._ripple.showTimer));
}
let br = !1;
function IS(e, a) {
  !br && a.includes(e.key) && (br = !0, gr(e));
}
function $p(e) {
  br = !1, Bt(e);
}
function _p(e) {
  br && (br = !1, Bt(e));
}
function Pp(e, a, i) {
  const {
    value: r,
    modifiers: n
  } = a, t = wp(r);
  t || bs.hide(e), e._ripple = e._ripple ?? {}, e._ripple.enabled = t, e._ripple.centered = n.center, e._ripple.circle = n.circle;
  const s = ms(r) ? r : {};
  s.class && (e._ripple.class = s.class);
  const o = s.keys ?? ["Enter", "Space"];
  if (e._ripple.keyDownHandler = (l) => IS(l, o), t && !i) {
    if (n.stop) {
      e.addEventListener("touchstart", ks, {
        passive: !0
      }), e.addEventListener("mousedown", ks);
      return;
    }
    e.addEventListener("touchstart", gr, {
      passive: !0
    }), e.addEventListener("touchend", Bt, {
      passive: !0
    }), e.addEventListener("touchmove", Sp, {
      passive: !0
    }), e.addEventListener("touchcancel", Bt), e.addEventListener("mousedown", gr), e.addEventListener("mouseup", Bt), e.addEventListener("mouseleave", Bt), e.addEventListener("keydown", e._ripple.keyDownHandler), e.addEventListener("keyup", $p), e.addEventListener("blur", _p), e.addEventListener("dragstart", Bt, {
      passive: !0
    });
  } else !t && i && Cp(e);
}
function Cp(e) {
  e.removeEventListener("touchstart", ks), e.removeEventListener("mousedown", ks), e.removeEventListener("touchstart", gr), e.removeEventListener("touchend", Bt), e.removeEventListener("touchmove", Sp), e.removeEventListener("touchcancel", Bt), e.removeEventListener("mousedown", gr), e.removeEventListener("mouseup", Bt), e.removeEventListener("mouseleave", Bt), e._ripple?.keyDownHandler && e.removeEventListener("keydown", e._ripple.keyDownHandler), e.removeEventListener("keyup", $p), e.removeEventListener("blur", _p), e.removeEventListener("dragstart", Bt);
}
function OS(e, a) {
  Pp(e, a, !1);
}
function ES(e) {
  Cp(e), delete e._ripple;
}
function AS(e, a) {
  if (a.value === a.oldValue)
    return;
  const i = wp(a.oldValue);
  Pp(e, a, i);
}
const At = {
  mounted: OS,
  unmounted: ES,
  updated: AS
}, xp = ee({
  active: {
    type: Boolean,
    default: void 0
  },
  activeColor: String,
  baseColor: String,
  symbol: {
    type: null,
    default: yp
  },
  flat: Boolean,
  icon: [Boolean, String, Function, Object],
  prependIcon: Pe,
  appendIcon: Pe,
  block: Boolean,
  readonly: Boolean,
  slim: Boolean,
  stacked: Boolean,
  spaced: String,
  ripple: {
    type: [Boolean, Object],
    default: !0
  },
  text: {
    type: [String, Number, Boolean],
    default: void 0
  },
  ...Aa(),
  ...Se(),
  ...Kt(),
  ...Mt(),
  ...ea(),
  ...Rr(),
  ..._u(),
  ...Un(),
  ...Bs(),
  ...$t(),
  ...Hs(),
  ...Nr(),
  ...Be({
    tag: "button"
  }),
  ...Qe(),
  ...ja({
    variant: "elevated"
  })
}, "VBtn"), Te = de()({
  name: "VBtn",
  props: xp(),
  emits: {
    "group:selected": (e) => !0
  },
  setup(e, a) {
    let {
      attrs: i,
      slots: r
    } = a;
    const {
      themeClasses: n
    } = ut(e), {
      borderClasses: t
    } = Ta(e), {
      densityClasses: s
    } = Qt(e), {
      dimensionStyles: o
    } = Rt(e), {
      elevationClasses: l
    } = ta(e), {
      loaderClasses: u
    } = zs(e), {
      locationStyles: c
    } = Wn(e), {
      positionClasses: d
    } = Fs(e), {
      roundedClasses: f
    } = _t(e), {
      sizeClasses: v,
      sizeStyles: g
    } = Lr(e), h = jn(e, e.symbol, !1), y = Ks(e, i), m = I(() => e.active !== void 0 ? e.active : y.isRouterLink.value ? y.isActive?.value : h?.isSelected.value), p = W(() => m.value ? e.activeColor ?? e.color : e.color), b = I(() => ({
      color: h?.isSelected.value && (!y.isLink.value || y.isActive?.value) || !h || y.isActive?.value ? p.value ?? e.baseColor : e.baseColor,
      variant: e.variant
    })), {
      colorClasses: w,
      colorStyles: k,
      variantClasses: S
    } = Kn(b), _ = I(() => h?.disabled.value || e.disabled), P = W(() => e.variant === "elevated" && !(e.disabled || e.flat || e.border)), M = I(() => {
      if (!(e.value === void 0 || typeof e.value == "symbol"))
        return Object(e.value) === e.value ? JSON.stringify(e.value, null, 0) : e.value;
    });
    function q(K) {
      _.value || y.isLink.value && (K.metaKey || K.ctrlKey || K.shiftKey || K.button !== 0 || i.target === "_blank") || (y.isRouterLink.value ? y.navigate?.(K) : h?.toggle());
    }
    return CS(y, h?.select), me(() => {
      const K = y.isLink.value ? "a" : e.tag, j = !!(e.prependIcon || r.prepend), H = !!(e.appendIcon || r.append), B = !!(e.icon && e.icon !== !0);
      return Je(C(K, re(y.linkProps, {
        type: K === "a" ? void 0 : "button",
        class: ["v-btn", h?.selectedClass.value, {
          "v-btn--active": m.value,
          "v-btn--block": e.block,
          "v-btn--disabled": _.value,
          "v-btn--elevated": P.value,
          "v-btn--flat": e.flat,
          "v-btn--icon": !!e.icon,
          "v-btn--loading": e.loading,
          "v-btn--readonly": e.readonly,
          "v-btn--slim": e.slim,
          "v-btn--stacked": e.stacked
        }, e.spaced ? ["v-btn--spaced", `v-btn--spaced-${e.spaced}`] : [], n.value, t.value, w.value, s.value, l.value, u.value, d.value, f.value, v.value, S.value, e.class],
        style: [k.value, o.value, c.value, g.value, e.style],
        "aria-busy": e.loading ? !0 : void 0,
        disabled: _.value && K !== "a" || void 0,
        tabindex: e.loading || e.readonly ? -1 : void 0,
        onClick: q,
        value: M.value
      }), {
        default: () => [yn(!0, "v-btn"), !e.icon && j && D("span", {
          key: "prepend",
          class: "v-btn__prepend"
        }, [r.prepend ? C(je, {
          key: "prepend-defaults",
          disabled: !e.prependIcon,
          defaults: {
            VIcon: {
              icon: e.prependIcon
            }
          }
        }, r.prepend) : C(xe, {
          key: "prepend-icon",
          icon: e.prependIcon
        }, null)]), D("span", {
          class: "v-btn__content",
          "data-no-activator": ""
        }, [!r.default && B ? C(xe, {
          key: "content-icon",
          icon: e.icon
        }, null) : C(je, {
          key: "content-defaults",
          disabled: !B,
          defaults: {
            VIcon: {
              icon: e.icon
            }
          }
        }, {
          default: () => [r.default?.() ?? Ue(e.text)]
        })]), !e.icon && H && D("span", {
          key: "append",
          class: "v-btn__append"
        }, [r.append ? C(je, {
          key: "append-defaults",
          disabled: !e.appendIcon,
          defaults: {
            VIcon: {
              icon: e.appendIcon
            }
          }
        }, r.append) : C(xe, {
          key: "append-icon",
          icon: e.appendIcon
        }, null)]), !!e.loading && D("span", {
          key: "loader",
          class: "v-btn__loader"
        }, [r.loader?.() ?? C(bp, {
          color: typeof e.loading == "boolean" ? void 0 : e.loading,
          indeterminate: !0,
          width: "2"
        }, null)])]
      }), [[At, !_.value && e.ripple, "", {
        center: !!e.icon
      }]]);
    }), {
      group: h
    };
  }
}), TS = ee({
  iconSize: [Number, String],
  iconSizes: {
    type: Array,
    default: () => [["x-small", 10], ["small", 16], ["default", 24], ["large", 28], ["x-large", 32]]
  }
}, "iconSize");
function jS(e, a) {
  return {
    iconSize: I(() => {
      const r = new Map(e.iconSizes), n = e.iconSize ?? a() ?? "default";
      return r.has(n) ? r.get(n) : n;
    })
  };
}
const DS = ["success", "info", "warning", "error"], MS = ee({
  border: {
    type: [Boolean, String],
    validator: (e) => typeof e == "boolean" || ["top", "end", "bottom", "start"].includes(e)
  },
  borderColor: String,
  closable: Boolean,
  closeIcon: {
    type: Pe,
    default: "$close"
  },
  closeLabel: {
    type: String,
    default: "$vuetify.close"
  },
  icon: {
    type: [Boolean, String, Function, Object],
    default: null
  },
  modelValue: {
    type: Boolean,
    default: !0
  },
  prominent: Boolean,
  title: String,
  text: String,
  type: {
    type: String,
    validator: (e) => DS.includes(e)
  },
  ...Se(),
  ...Kt(),
  ...Mt(),
  ...ea(),
  ...TS(),
  ...Un(),
  ...Bs(),
  ...$t(),
  ...Be(),
  ...Qe(),
  ...ja({
    variant: "flat"
  })
}, "VAlert"), Vp = de()({
  name: "VAlert",
  props: MS(),
  emits: {
    "click:close": (e) => !0,
    "update:modelValue": (e) => !0
  },
  setup(e, a) {
    let {
      emit: i,
      slots: r
    } = a;
    const n = $e(e, "modelValue"), t = W(() => {
      if (e.icon !== !1)
        return e.type ? e.icon ?? `$${e.type}` : e.icon;
    }), {
      iconSize: s
    } = jS(e, () => e.prominent ? 44 : void 0), {
      themeClasses: o
    } = ut(e), {
      colorClasses: l,
      colorStyles: u,
      variantClasses: c
    } = Kn(() => ({
      color: e.color ?? e.type,
      variant: e.variant
    })), {
      densityClasses: d
    } = Qt(e), {
      dimensionStyles: f
    } = Rt(e), {
      elevationClasses: v
    } = ta(e), {
      locationStyles: g
    } = Wn(e), {
      positionClasses: h
    } = Fs(e), {
      roundedClasses: y
    } = _t(e), {
      textColorClasses: m,
      textColorStyles: p
    } = kt(() => e.borderColor), {
      t: b
    } = nt(), w = W(() => ({
      "aria-label": b(e.closeLabel),
      onClick(k) {
        n.value = !1, i("click:close", k);
      }
    }));
    return () => {
      const k = !!(r.prepend || t.value), S = !!(r.title || e.title), _ = !!(r.close || e.closable), P = {
        density: e.density,
        icon: t.value,
        size: e.iconSize || e.prominent ? s.value : void 0
      };
      return n.value && C(e.tag, {
        class: ue(["v-alert", e.border && {
          "v-alert--border": !!e.border,
          [`v-alert--border-${e.border === !0 ? "start" : e.border}`]: !0
        }, {
          "v-alert--prominent": e.prominent
        }, o.value, l.value, d.value, v.value, h.value, y.value, c.value, e.class]),
        style: be([u.value, f.value, g.value, e.style]),
        role: "alert"
      }, {
        default: () => [yn(!1, "v-alert"), e.border && D("div", {
          key: "border",
          class: ue(["v-alert__border", m.value]),
          style: be(p.value)
        }, null), k && D("div", {
          key: "prepend",
          class: "v-alert__prepend"
        }, [r.prepend ? C(je, {
          key: "prepend-defaults",
          disabled: !t.value,
          defaults: {
            VIcon: {
              ...P
            }
          }
        }, r.prepend) : C(xe, re({
          key: "prepend-icon"
        }, P), null)]), D("div", {
          class: "v-alert__content"
        }, [S && C(oS, {
          key: "title"
        }, {
          default: () => [r.title?.() ?? e.title]
        }), r.text?.() ?? e.text, r.default?.()]), r.append && D("div", {
          key: "append",
          class: "v-alert__append"
        }, [r.append()]), _ && D("div", {
          key: "close",
          class: "v-alert__close"
        }, [r.close ? C(je, {
          key: "close-defaults",
          defaults: {
            VBtn: {
              icon: e.closeIcon,
              size: "x-small",
              variant: "text"
            }
          }
        }, {
          default: () => [r.close?.({
            props: w.value
          })]
        }) : C(Te, re({
          key: "close-btn",
          icon: e.closeIcon,
          size: "x-small",
          variant: "text"
        }, w.value), null)])]
      });
    };
  }
}), RS = ee({
  disabled: Boolean,
  group: Boolean,
  hideOnLeave: Boolean,
  leaveAbsolute: Boolean,
  mode: String,
  origin: String
}, "transition");
function Ht(e, a, i) {
  return de()({
    name: e,
    props: RS({
      mode: i,
      origin: a
    }),
    setup(r, n) {
      let {
        slots: t
      } = n;
      const s = {
        onBeforeEnter(o) {
          r.origin && (o.style.transformOrigin = r.origin);
        },
        onLeave(o) {
          if (r.leaveAbsolute) {
            const {
              offsetTop: l,
              offsetLeft: u,
              offsetWidth: c,
              offsetHeight: d
            } = o;
            o._transitionInitialStyles = {
              position: o.style.position,
              top: o.style.top,
              left: o.style.left,
              width: o.style.width,
              height: o.style.height
            }, o.style.position = "absolute", o.style.top = `${l}px`, o.style.left = `${u}px`, o.style.width = `${c}px`, o.style.height = `${d}px`;
          }
          r.hideOnLeave && o.style.setProperty("display", "none", "important");
        },
        onAfterLeave(o) {
          if (r.leaveAbsolute && o?._transitionInitialStyles) {
            const {
              position: l,
              top: u,
              left: c,
              width: d,
              height: f
            } = o._transitionInitialStyles;
            delete o._transitionInitialStyles, o.style.position = l || "", o.style.top = u || "", o.style.left = c || "", o.style.width = d || "", o.style.height = f || "";
          }
        }
      };
      return () => {
        const o = r.group ? Go : sn;
        return Oe(o, {
          name: r.disabled ? "" : e,
          css: !r.disabled,
          ...r.group ? void 0 : {
            mode: r.mode
          },
          ...r.disabled ? {} : s
        }, t.default);
      };
    }
  });
}
function Ip(e, a) {
  let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "in-out";
  return de()({
    name: e,
    props: {
      mode: {
        type: String,
        default: i
      },
      disabled: {
        type: Boolean,
        default: cn()
      },
      group: Boolean
    },
    setup(r, n) {
      let {
        slots: t
      } = n;
      const s = r.group ? Go : sn;
      return () => Oe(s, {
        name: r.disabled ? "" : e,
        css: !r.disabled,
        // mode: props.mode, // TODO: vuejs/vue-next#3104
        ...r.disabled ? {} : a
      }, t.default);
    }
  });
}
function Op() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
  const i = (arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1) ? "width" : "height", r = Cs(`offset-${i}`);
  return {
    onBeforeEnter(s) {
      s._parent = s.parentNode, s._initialStyle = {
        transition: s.style.transition,
        overflow: s.style.overflow,
        [i]: s.style[i]
      };
    },
    onEnter(s) {
      const o = s._initialStyle;
      if (!o) return;
      s.style.setProperty("transition", "none", "important"), s.style.overflow = "hidden";
      const l = `${s[r]}px`;
      s.style[i] = "0", s.offsetHeight, s.style.transition = o.transition, e && s._parent && s._parent.classList.add(e), requestAnimationFrame(() => {
        s.style[i] = l;
      });
    },
    onAfterEnter: t,
    onEnterCancelled: t,
    onLeave(s) {
      s._initialStyle = {
        transition: "",
        overflow: s.style.overflow,
        [i]: s.style[i]
      }, s.style.overflow = "hidden", s.style[i] = `${s[r]}px`, s.offsetHeight, requestAnimationFrame(() => s.style[i] = "0");
    },
    onAfterLeave: n,
    onLeaveCancelled: n
  };
  function n(s) {
    e && s._parent && s._parent.classList.remove(e), t(s);
  }
  function t(s) {
    if (!s._initialStyle) return;
    const o = s._initialStyle[i];
    s.style.overflow = s._initialStyle.overflow, o != null && (s.style[i] = o), delete s._initialStyle;
  }
}
const NS = ee({
  target: [Object, Array]
}, "v-dialog-transition"), Wl = /* @__PURE__ */ new WeakMap(), Cu = de()({
  name: "VDialogTransition",
  props: NS(),
  setup(e, a) {
    let {
      slots: i
    } = a;
    const r = {
      onBeforeEnter(n) {
        n.style.pointerEvents = "none", n.style.visibility = "hidden";
      },
      async onEnter(n, t) {
        await new Promise((f) => requestAnimationFrame(f)), await new Promise((f) => requestAnimationFrame(f)), n.style.visibility = "";
        const s = fm(e.target, n), {
          x: o,
          y: l,
          sx: u,
          sy: c,
          speed: d
        } = s;
        if (Wl.set(n, s), cn())
          _a(n, [{
            opacity: 0
          }, {}], {
            duration: 125 * d,
            easing: Qf
          }).finished.then(() => t());
        else {
          const f = _a(n, [{
            transform: `translate(${o}px, ${l}px) scale(${u}, ${c})`,
            opacity: 0
          }, {}], {
            duration: 225 * d,
            easing: Qf
          });
          dm(n)?.forEach((v) => {
            _a(v, [{
              opacity: 0
            }, {
              opacity: 0,
              offset: 0.33
            }, {}], {
              duration: 450 * d,
              easing: hr
            });
          }), f.finished.then(() => t());
        }
      },
      onAfterEnter(n) {
        n.style.removeProperty("pointer-events");
      },
      onBeforeLeave(n) {
        n.style.pointerEvents = "none";
      },
      async onLeave(n, t) {
        await new Promise((f) => requestAnimationFrame(f));
        let s;
        !Wl.has(n) || Array.isArray(e.target) || e.target.offsetParent || e.target.getClientRects().length ? s = fm(e.target, n) : s = Wl.get(n);
        const {
          x: o,
          y: l,
          sx: u,
          sy: c,
          speed: d
        } = s;
        cn() ? _a(n, [{}, {
          opacity: 0
        }], {
          duration: 85 * d,
          easing: em
        }).finished.then(() => t()) : (_a(n, [{}, {
          transform: `translate(${o}px, ${l}px) scale(${u}, ${c})`,
          opacity: 0
        }], {
          duration: 125 * d,
          easing: em
        }).finished.then(() => t()), dm(n)?.forEach((v) => {
          _a(v, [{}, {
            opacity: 0,
            offset: 0.2
          }, {
            opacity: 0
          }], {
            duration: 250 * d,
            easing: hr
          });
        }));
      },
      onAfterLeave(n) {
        n.style.removeProperty("pointer-events");
      }
    };
    return () => e.target ? C(sn, re({
      name: "dialog-transition"
    }, r, {
      css: !1
    }), i) : C(sn, {
      name: "dialog-transition"
    }, i);
  }
});
function dm(e) {
  const a = e.querySelector(":scope > .v-card, :scope > .v-sheet, :scope > .v-list")?.children;
  return a && [...a];
}
function fm(e, a) {
  const i = Gv(e), r = pu(a), [n, t] = getComputedStyle(a).transformOrigin.split(" ").map((m) => parseFloat(m)), [s, o] = getComputedStyle(a).getPropertyValue("--v-overlay-anchor-origin").split(" ");
  let l = i.left + i.width / 2;
  s === "left" || o === "left" ? l -= i.width / 2 : (s === "right" || o === "right") && (l += i.width / 2);
  let u = i.top + i.height / 2;
  s === "top" || o === "top" ? u -= i.height / 2 : (s === "bottom" || o === "bottom") && (u += i.height / 2);
  const c = i.width / r.width, d = i.height / r.height, f = Math.max(1, c, d), v = c / f || 0, g = d / f || 0, h = r.width * r.height / (window.innerWidth * window.innerHeight), y = h > 0.12 ? Math.min(1.5, (h - 0.12) * 10 + 1) : 1;
  return {
    x: l - (n + r.left),
    y: u - (t + r.top),
    sx: v,
    sy: g,
    speed: y
  };
}
Ht("fab-transition", "center center", "out-in");
Ht("dialog-bottom-transition");
Ht("dialog-top-transition");
const Vo = Ht("fade-transition"), Ep = Ht("scale-transition");
Ht("scroll-x-transition");
Ht("scroll-x-reverse-transition");
Ht("scroll-y-transition");
Ht("scroll-y-reverse-transition");
Ht("slide-x-transition");
Ht("slide-x-reverse-transition");
const Ap = Ht("slide-y-transition");
Ht("slide-y-reverse-transition");
const xu = Ip("expand-transition", Op()), Tp = Ip("expand-x-transition", Op("", !0));
function Gl(e, a) {
  return {
    x: e.x + a.x,
    y: e.y + a.y
  };
}
function LS(e, a) {
  return {
    x: e.x - a.x,
    y: e.y - a.y
  };
}
function mm(e, a) {
  if (e.side === "top" || e.side === "bottom") {
    const {
      side: i,
      align: r
    } = e, n = r === "left" ? 0 : r === "center" ? a.width / 2 : r === "right" ? a.width : r, t = i === "top" ? 0 : i === "bottom" ? a.height : i;
    return Gl({
      x: n,
      y: t
    }, a);
  } else if (e.side === "left" || e.side === "right") {
    const {
      side: i,
      align: r
    } = e, n = i === "left" ? 0 : i === "right" ? a.width : i, t = r === "top" ? 0 : r === "center" ? a.height / 2 : r === "bottom" ? a.height : r;
    return Gl({
      x: n,
      y: t
    }, a);
  }
  return Gl({
    x: a.width / 2,
    y: a.height / 2
  }, a);
}
const jp = {
  static: BS,
  // specific viewport position, usually centered
  connected: KS
  // connected to a certain element
}, qS = ee({
  locationStrategy: {
    type: [String, Function],
    default: "static",
    validator: (e) => typeof e == "function" || e in jp
  },
  location: {
    type: String,
    default: "bottom"
  },
  origin: {
    type: String,
    default: "auto"
  },
  offset: [Number, String, Array],
  stickToTarget: Boolean,
  viewportMargin: {
    type: [Number, String],
    default: 12
  }
}, "VOverlay-location-strategies");
function zS(e, a) {
  const i = ie({}), r = ie();
  et && Na(() => !!(a.isActive.value && e.locationStrategy), (o) => {
    ce(() => e.locationStrategy, o), st(() => {
      window.removeEventListener("resize", n), visualViewport?.removeEventListener("resize", t), visualViewport?.removeEventListener("scroll", s), r.value = void 0;
    }), window.addEventListener("resize", n, {
      passive: !0
    }), visualViewport?.addEventListener("resize", t, {
      passive: !0
    }), visualViewport?.addEventListener("scroll", s, {
      passive: !0
    }), typeof e.locationStrategy == "function" ? r.value = e.locationStrategy(a, e, i)?.updateLocation : r.value = jp[e.locationStrategy](a, e, i)?.updateLocation;
  });
  function n(o) {
    r.value?.(o);
  }
  function t(o) {
    r.value?.(o);
  }
  function s(o) {
    r.value?.(o);
  }
  return {
    contentStyles: i,
    updateLocation: r
  };
}
function BS() {
}
function FS(e, a) {
  const i = pu(e);
  return a ? i.x += parseFloat(e.style.right || 0) : i.x -= parseFloat(e.style.left || 0), i.y -= parseFloat(e.style.top || 0), i;
}
function KS(e, a, i) {
  (Array.isArray(e.target.value) || Tw(e.target.value)) && Object.assign(i.value, {
    position: "fixed",
    top: 0,
    [e.isRtl.value ? "right" : "left"]: 0
  });
  const {
    preferredAnchor: n,
    preferredOrigin: t
  } = vu(() => {
    const m = So(a.location, e.isRtl.value), p = a.origin === "overlap" ? m : a.origin === "auto" ? zl(m) : So(a.origin, e.isRtl.value);
    return m.side === p.side && m.align === Bl(p).align ? {
      preferredAnchor: Lf(m),
      preferredOrigin: Lf(p)
    } : {
      preferredAnchor: m,
      preferredOrigin: p
    };
  }), [s, o, l, u] = ["minWidth", "minHeight", "maxWidth", "maxHeight"].map((m) => I(() => {
    const p = parseFloat(a[m]);
    return isNaN(p) ? 1 / 0 : p;
  })), c = I(() => {
    if (Array.isArray(a.offset))
      return a.offset;
    if (typeof a.offset == "string") {
      const m = a.offset.split(" ").map(parseFloat);
      return m.length < 2 && m.push(0), m;
    }
    return typeof a.offset == "number" ? [a.offset, 0] : [0, 0];
  });
  let d = !1, f = -1;
  const v = new Q0(4), g = new ResizeObserver(() => {
    if (!d) return;
    if (requestAnimationFrame((p) => {
      p !== f && v.clear(), requestAnimationFrame((b) => {
        f = b;
      });
    }), v.isFull) {
      const p = v.values();
      if (bt(p.at(-1), p.at(-3)) && !bt(p.at(-1), p.at(-2)))
        return;
    }
    const m = y();
    m && v.push(m.flipped);
  });
  let h = new Ut({
    x: 0,
    y: 0,
    width: 0,
    height: 0
  });
  ce(e.target, (m, p) => {
    p && !Array.isArray(p) && g.unobserve(p), Array.isArray(m) ? bt(m, p) || y() : m && g.observe(m);
  }, {
    immediate: !0
  }), ce(e.contentEl, (m, p) => {
    p && g.unobserve(p), m && g.observe(m);
  }, {
    immediate: !0
  }), st(() => {
    g.disconnect();
  });
  function y() {
    if (d = !1, requestAnimationFrame(() => d = !0), !e.target.value || !e.contentEl.value) return;
    (Array.isArray(e.target.value) || e.target.value.offsetParent || e.target.value.getClientRects().length) && (h = Gv(e.target.value));
    const m = FS(e.contentEl.value, e.isRtl.value), p = gs(e.contentEl.value), b = Number(a.viewportMargin);
    p.length || (p.push(document.documentElement), e.contentEl.value.style.top && e.contentEl.value.style.left || (m.x -= parseFloat(document.documentElement.style.getPropertyValue("--v-body-scroll-x") || 0), m.y -= parseFloat(document.documentElement.style.getPropertyValue("--v-body-scroll-y") || 0)));
    const w = p.reduce((H, B) => {
      const L = lw(B);
      return H ? new Ut({
        x: Math.max(H.left, L.left),
        y: Math.max(H.top, L.top),
        width: Math.min(H.right, L.right) - Math.max(H.left, L.left),
        height: Math.min(H.bottom, L.bottom) - Math.max(H.top, L.top)
      }) : L;
    }, void 0);
    a.stickToTarget ? (w.x += Math.min(b, h.x), w.y += Math.min(b, h.y), w.width = Math.max(w.width - b * 2, h.x + h.width - b), w.height = Math.max(w.height - b * 2, h.y + h.height - b)) : (w.x += b, w.y += b, w.width -= b * 2, w.height -= b * 2);
    let k = {
      anchor: n.value,
      origin: t.value
    };
    function S(H) {
      const B = new Ut(m), L = mm(H.anchor, h), O = mm(H.origin, B);
      let {
        x: U,
        y: Z
      } = LS(L, O);
      switch (H.anchor.side) {
        case "top":
          Z -= c.value[0];
          break;
        case "bottom":
          Z += c.value[0];
          break;
        case "left":
          U -= c.value[0];
          break;
        case "right":
          U += c.value[0];
          break;
      }
      switch (H.anchor.align) {
        case "top":
          Z -= c.value[1];
          break;
        case "bottom":
          Z += c.value[1];
          break;
        case "left":
          U -= c.value[1];
          break;
        case "right":
          U += c.value[1];
          break;
      }
      return B.x += U, B.y += Z, B.width = Math.min(B.width, l.value), B.height = Math.min(B.height, u.value), {
        overflows: zf(B, w),
        x: U,
        y: Z
      };
    }
    let _ = 0, P = 0;
    const M = {
      x: 0,
      y: 0
    }, q = {
      x: !1,
      y: !1
    };
    let K = -1;
    for (; ; ) {
      if (K++ > 10) {
        fu("Infinite loop detected in connectedLocationStrategy");
        break;
      }
      const {
        x: H,
        y: B,
        overflows: L
      } = S(k);
      _ += H, P += B, m.x += H, m.y += B;
      {
        const O = qf(k.anchor), U = L.x.before || L.x.after, Z = L.y.before || L.y.after;
        let J = !1;
        if (["x", "y"].forEach((A) => {
          if (A === "x" && U && !q.x || A === "y" && Z && !q.y) {
            const T = {
              anchor: {
                ...k.anchor
              },
              origin: {
                ...k.origin
              }
            }, E = A === "x" ? O === "y" ? Bl : zl : O === "y" ? zl : Bl;
            T.anchor = E(T.anchor), T.origin = E(T.origin);
            const {
              overflows: x
            } = S(T);
            (x[A].before <= L[A].before && x[A].after <= L[A].after || x[A].before + x[A].after < (L[A].before + L[A].after) / 2) && (k = T, J = q[A] = !0);
          }
        }), J) continue;
      }
      L.x.before && (_ += L.x.before, m.x += L.x.before), L.x.after && (_ -= L.x.after, m.x -= L.x.after), L.y.before && (P += L.y.before, m.y += L.y.before), L.y.after && (P -= L.y.after, m.y -= L.y.after);
      {
        const O = zf(m, w);
        M.x = w.width - O.x.before - O.x.after, M.y = w.height - O.y.before - O.y.after, _ += O.x.before, m.x += O.x.before, P += O.y.before, m.y += O.y.before;
      }
      break;
    }
    const j = qf(k.anchor);
    return Object.assign(i.value, {
      "--v-overlay-anchor-origin": `${k.anchor.side} ${k.anchor.align}`,
      transformOrigin: `${k.origin.side} ${k.origin.align}`,
      // transform: `translate(${pixelRound(x)}px, ${pixelRound(y)}px)`,
      top: he(Yl(P)),
      left: e.isRtl.value ? void 0 : he(Yl(_)),
      right: e.isRtl.value ? he(Yl(-_)) : void 0,
      minWidth: he(j === "y" ? Math.min(s.value, h.width) : s.value),
      maxWidth: he(vm(Xe(M.x, s.value === 1 / 0 ? 0 : s.value, l.value))),
      maxHeight: he(vm(Xe(M.y, o.value === 1 / 0 ? 0 : o.value, u.value)))
    }), {
      available: M,
      contentBox: m,
      flipped: q
    };
  }
  return ce(() => [n.value, t.value, a.offset, a.minWidth, a.minHeight, a.maxWidth, a.maxHeight], () => y()), Ee(() => {
    const m = y();
    if (!m) return;
    const {
      available: p,
      contentBox: b
    } = m;
    b.height > p.y && requestAnimationFrame(() => {
      y(), requestAnimationFrame(() => {
        y();
      });
    });
  }), {
    updateLocation: y
  };
}
function Yl(e) {
  return Math.round(e * devicePixelRatio) / devicePixelRatio;
}
function vm(e) {
  return Math.ceil(e * devicePixelRatio) / devicePixelRatio;
}
let Io = !0;
const ws = [];
function HS(e) {
  !Io || ws.length ? (ws.push(e), Oo()) : (Io = !1, e(), Oo());
}
let pm = -1;
function Oo() {
  cancelAnimationFrame(pm), pm = requestAnimationFrame(() => {
    const e = ws.shift();
    e && e(), ws.length ? Oo() : Io = !0;
  });
}
const Dp = {
  none: null,
  close: GS,
  block: YS,
  reposition: XS
}, US = ee({
  scrollStrategy: {
    type: [String, Function],
    default: "block",
    validator: (e) => typeof e == "function" || e in Dp
  }
}, "VOverlay-scroll-strategies");
function WS(e, a) {
  if (!et) return;
  let i;
  wt(async () => {
    i?.stop(), a.isActive.value && e.scrollStrategy && (i = Ho(), await new Promise((r) => setTimeout(r)), i.active && i.run(() => {
      typeof e.scrollStrategy == "function" ? e.scrollStrategy(a, e, i) : Dp[e.scrollStrategy]?.(a, e, i);
    }));
  }), st(() => {
    i?.stop();
  });
}
function GS(e) {
  function a(i) {
    e.isActive.value = !1;
  }
  Mp(Vu(e.target.value, e.contentEl.value), a);
}
function YS(e, a) {
  const i = e.root.value?.offsetParent, r = Vu(e.target.value, e.contentEl.value), n = [.../* @__PURE__ */ new Set([...gs(r, a.contained ? i : void 0), ...gs(e.contentEl.value, a.contained ? i : void 0)])].filter((o) => !o.classList.contains("v-overlay-scroll-blocked")), t = window.innerWidth - document.documentElement.offsetWidth, s = ((o) => bu(o) && o)(i || document.documentElement);
  s && e.root.value.classList.add("v-overlay--scroll-blocked"), n.forEach((o, l) => {
    o.style.setProperty("--v-body-scroll-x", he(-o.scrollLeft)), o.style.setProperty("--v-body-scroll-y", he(-o.scrollTop)), o !== document.documentElement && o.style.setProperty("--v-scrollbar-offset", he(t)), o.classList.add("v-overlay-scroll-blocked");
  }), st(() => {
    n.forEach((o, l) => {
      const u = parseFloat(o.style.getPropertyValue("--v-body-scroll-x")), c = parseFloat(o.style.getPropertyValue("--v-body-scroll-y")), d = o.style.scrollBehavior;
      o.style.scrollBehavior = "auto", o.style.removeProperty("--v-body-scroll-x"), o.style.removeProperty("--v-body-scroll-y"), o.style.removeProperty("--v-scrollbar-offset"), o.classList.remove("v-overlay-scroll-blocked"), o.scrollLeft = -u, o.scrollTop = -c, o.style.scrollBehavior = d;
    }), s && e.root.value.classList.remove("v-overlay--scroll-blocked");
  });
}
function XS(e, a, i) {
  let r = !1, n = -1, t = -1;
  function s(o) {
    HS(() => {
      const l = performance.now();
      e.updateLocation.value?.(o), r = (performance.now() - l) / (1e3 / 60) > 2;
    });
  }
  t = (typeof requestIdleCallback > "u" ? (o) => o() : requestIdleCallback)(() => {
    i.run(() => {
      Mp(Vu(e.target.value, e.contentEl.value), (o) => {
        r ? (cancelAnimationFrame(n), n = requestAnimationFrame(() => {
          n = requestAnimationFrame(() => {
            s(o);
          });
        })) : s(o);
      });
    });
  }), st(() => {
    typeof cancelIdleCallback < "u" && cancelIdleCallback(t), cancelAnimationFrame(n);
  });
}
function Vu(e, a) {
  return Array.isArray(e) ? document.elementsFromPoint(...e).find((i) => !a?.contains(i)) : e ?? a;
}
function Mp(e, a) {
  const i = [document, ...gs(e)];
  i.forEach((r) => {
    r.addEventListener("scroll", a, {
      passive: !0
    });
  }), st(() => {
    i.forEach((r) => {
      r.removeEventListener("scroll", a);
    });
  });
}
const Eo = /* @__PURE__ */ Symbol.for("vuetify:v-menu"), ZS = ee({
  closeDelay: [Number, String],
  openDelay: [Number, String]
}, "delay");
function JS(e, a) {
  let i = () => {
  };
  function r(s, o) {
    i?.();
    const l = s ? e.openDelay : e.closeDelay, u = Math.max(o?.minDelay ?? 0, Number(l ?? 0));
    return new Promise((c) => {
      i = tw(u, () => {
        a?.(s), c(s);
      });
    });
  }
  function n() {
    return r(!0);
  }
  function t(s) {
    return r(!1, s);
  }
  return {
    clearDelay: i,
    runOpenDelay: n,
    runCloseDelay: t
  };
}
const QS = ee({
  target: [String, Object],
  activator: [String, Object],
  activatorProps: {
    type: Object,
    default: () => ({})
  },
  openOnClick: {
    type: Boolean,
    default: void 0
  },
  openOnHover: Boolean,
  openOnFocus: {
    type: Boolean,
    default: void 0
  },
  closeOnContentClick: Boolean,
  ...ZS()
}, "VOverlay-activator");
function e$(e, a) {
  let {
    isActive: i,
    isTop: r,
    contentEl: n
  } = a;
  const t = ft("useActivator"), s = ie();
  let o = !1, l = !1, u = !0;
  const c = I(() => e.openOnFocus || e.openOnFocus == null && e.openOnHover), d = I(() => e.openOnClick || e.openOnClick == null && !e.openOnHover && !c.value), {
    runOpenDelay: f,
    runCloseDelay: v
  } = JS(e, (P) => {
    P === (e.openOnHover && o || c.value && l) && !(e.openOnHover && i.value && !r.value) && (i.value !== P && (u = !0), i.value = P);
  }), g = ie(), h = {
    onClick: (P) => {
      P.stopPropagation(), s.value = P.currentTarget || P.target, i.value || (g.value = [P.clientX, P.clientY]), i.value = !i.value;
    },
    onMouseenter: (P) => {
      o = !0, s.value = P.currentTarget || P.target, f();
    },
    onMouseleave: (P) => {
      o = !1, v();
    },
    onFocus: (P) => {
      An(P.target, ":focus-visible") !== !1 && (l = !0, P.stopPropagation(), s.value = P.currentTarget || P.target, f());
    },
    onBlur: (P) => {
      l = !1, P.stopPropagation(), v({
        minDelay: 1
      });
    }
  }, y = I(() => {
    const P = {};
    return d.value && (P.onClick = h.onClick), e.openOnHover && (P.onMouseenter = h.onMouseenter, P.onMouseleave = h.onMouseleave), c.value && (P.onFocus = h.onFocus, P.onBlur = h.onBlur), P;
  }), m = I(() => {
    const P = {};
    if (e.openOnHover && (P.onMouseenter = () => {
      o = !0, f();
    }, P.onMouseleave = () => {
      o = !1, v();
    }), c.value && (P.onFocusin = (M) => {
      M.target.matches(":focus-visible") && (l = !0, f());
    }, P.onFocusout = () => {
      l = !1, v({
        minDelay: 1
      });
    }), e.closeOnContentClick) {
      const M = qe(Eo, null);
      P.onClick = () => {
        i.value = !1, M?.closeParents();
      };
    }
    return P;
  }), p = I(() => {
    const P = {};
    return e.openOnHover && (P.onMouseenter = () => {
      u && (o = !0, u = !1, f());
    }, P.onMouseleave = () => {
      o = !1, v();
    }), P;
  });
  ce(r, (P) => {
    P && (e.openOnHover && !o && (!c.value || !l) || c.value && !l && (!e.openOnHover || !o)) && !n.value?.contains(document.activeElement) && (i.value = !1);
  }), ce(i, (P) => {
    P || setTimeout(() => {
      g.value = void 0;
    });
  }, {
    flush: "post"
  });
  const b = ps();
  wt(() => {
    b.value && Ee(() => {
      s.value = b.el;
    });
  });
  const w = ps(), k = I(() => e.target === "cursor" && g.value ? g.value : w.value ? w.el : Rp(e.target, t) || s.value), S = I(() => Array.isArray(k.value) ? void 0 : k.value);
  let _;
  return ce(() => !!e.activator, (P) => {
    P && et ? (_ = Ho(), _.run(() => {
      t$(e, t, {
        activatorEl: s,
        activatorEvents: y
      });
    })) : _ && _.stop();
  }, {
    flush: "post",
    immediate: !0
  }), st(() => {
    _?.stop();
  }), {
    activatorEl: s,
    activatorRef: b,
    target: k,
    targetEl: S,
    targetRef: w,
    activatorEvents: y,
    contentEvents: m,
    scrimEvents: p
  };
}
function t$(e, a, i) {
  let {
    activatorEl: r,
    activatorEvents: n
  } = i;
  ce(() => e.activator, (l, u) => {
    if (u && l !== u) {
      const c = o(u);
      c && s(c);
    }
    l && Ee(() => t());
  }, {
    immediate: !0
  }), ce(() => e.activatorProps, () => {
    t();
  }), st(() => {
    s();
  });
  function t() {
    let l = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : o(), u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : e.activatorProps;
    l && ow(l, re(n.value, u));
  }
  function s() {
    let l = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : o(), u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : e.activatorProps;
    l && uw(l, re(n.value, u));
  }
  function o() {
    let l = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : e.activator;
    const u = Rp(l, a);
    return r.value = u?.nodeType === Node.ELEMENT_NODE ? u : void 0, r.value;
  }
}
function Rp(e, a) {
  if (!e) return;
  let i;
  if (e === "parent") {
    let r = a?.proxy?.$el?.parentNode;
    for (; r?.hasAttribute("data-no-activator"); )
      r = r.parentNode;
    i = r;
  } else typeof e == "string" ? i = document.querySelector(e) : "$el" in e ? i = e.$el : i = e;
  return i;
}
const a$ = ee({
  retainFocus: Boolean,
  captureFocus: Boolean,
  /** @deprecated */
  disableInitialFocus: Boolean
}, "focusTrap"), ts = /* @__PURE__ */ new Map();
let hm = 0;
function ym(e) {
  const a = document.activeElement;
  if (e.key !== "Tab" || !a) return;
  const i = Array.from(ts.values()).filter((u) => {
    let {
      isActive: c,
      contentEl: d
    } = u;
    return c.value && d.value?.contains(a);
  }).map((u) => u.contentEl.value);
  let r, n = a.parentElement;
  for (; n; ) {
    if (i.includes(n)) {
      r = n;
      break;
    }
    n = n.parentElement;
  }
  if (!r) return;
  const t = an(r).filter((u) => u.tabIndex >= 0);
  if (!t.length) return;
  const s = document.activeElement;
  if (t.length === 1 && t[0].classList.contains("v-list") && t[0].contains(s)) {
    e.preventDefault();
    return;
  }
  const o = t[0], l = t[t.length - 1];
  e.shiftKey && (s === o || o.classList.contains("v-list") && o.contains(s)) && (e.preventDefault(), l.focus()), !e.shiftKey && (s === l || l.classList.contains("v-list") && l.contains(s)) && (e.preventDefault(), o.focus());
}
function n$(e, a) {
  let {
    isActive: i,
    localTop: r,
    contentEl: n
  } = a;
  const t = /* @__PURE__ */ Symbol("trap");
  let s = !1, o = -1;
  async function l() {
    s = !0, o = window.setTimeout(() => {
      s = !1;
    }, 100);
  }
  async function u(f) {
    const v = f.relatedTarget, g = f.target;
    document.removeEventListener("pointerdown", l), document.removeEventListener("keydown", c), await Ee(), i.value && !s && v !== g && n.value && // We're the menu without open submenus or overlays
    ot(r) && // It isn't the document or the container body
    ![document, n.value].includes(g) && // It isn't inside the container body
    !n.value.contains(g) && an(n.value)[0]?.focus();
  }
  function c(f) {
    if (f.key === "Tab" && (document.removeEventListener("keydown", c), i.value && n.value && f.target && !n.value.contains(f.target))) {
      const v = an(document.documentElement);
      if (f.shiftKey && f.target === v.at(0) || !f.shiftKey && f.target === v.at(-1)) {
        const g = an(n.value);
        g.length > 0 && (f.preventDefault(), g[0].focus());
      }
    }
  }
  const d = W(() => i.value && e.captureFocus && !e.disableInitialFocus);
  et && (ce(() => e.retainFocus, (f) => {
    f ? ts.set(t, {
      isActive: i,
      contentEl: n
    }) : ts.delete(t);
  }, {
    immediate: !0
  }), ce(d, (f) => {
    f ? (document.addEventListener("pointerdown", l), document.addEventListener("focusin", u, {
      once: !0
    }), document.addEventListener("keydown", c)) : (document.removeEventListener("pointerdown", l), document.removeEventListener("focusin", u), document.removeEventListener("keydown", c));
  }, {
    immediate: !0
  }), hm++ < 1 && document.addEventListener("keydown", ym)), st(() => {
    ts.delete(t), clearTimeout(o), document.removeEventListener("pointerdown", l), document.removeEventListener("focusin", u), document.removeEventListener("keydown", c), --hm < 1 && document.removeEventListener("keydown", ym);
  });
}
function r$() {
  if (!et) return fe(!1);
  const {
    ssr: e
  } = Dr();
  if (e) {
    const a = fe(!1);
    return ua(() => {
      a.value = !0;
    }), a;
  } else
    return fe(!0);
}
const Iu = ee({
  eager: Boolean
}, "lazy");
function Ou(e, a) {
  const i = fe(!1), r = W(() => i.value || e.eager || a.value);
  ce(a, () => i.value = !0);
  function n() {
    e.eager || (i.value = !1);
  }
  return {
    isBooted: i,
    hasContent: r,
    onAfterLeave: n
  };
}
function Us() {
  const a = ft("useScopeId").vnode.scopeId;
  return {
    scopeId: a ? {
      [a]: ""
    } : void 0
  };
}
const gm = /* @__PURE__ */ Symbol.for("vuetify:stack"), nr = rn([]);
function i$(e, a, i) {
  const r = ft("useStack"), n = !i, t = qe(gm, void 0), s = rn({
    activeChildren: /* @__PURE__ */ new Set()
  });
  ht(gm, s);
  const o = fe(Number(ot(a)));
  Na(e, () => {
    const c = nr.at(-1)?.[1];
    o.value = c ? c + 10 : Number(ot(a)), n && nr.push([r.uid, o.value]), t?.activeChildren.add(r.uid), st(() => {
      if (n) {
        const d = Ye(nr).findIndex((f) => f[0] === r.uid);
        nr.splice(d, 1);
      }
      t?.activeChildren.delete(r.uid);
    });
  });
  const l = fe(!0);
  n && wt(() => {
    const c = nr.at(-1)?.[0] === r.uid;
    setTimeout(() => l.value = c);
  });
  const u = W(() => !s.activeChildren.size);
  return {
    globalTop: Uo(l),
    localTop: u,
    stackStyles: W(() => ({
      zIndex: o.value
    }))
  };
}
function s$(e) {
  return {
    teleportTarget: I(() => {
      const i = e();
      if (i === !0 || !et) return;
      const r = i === !1 ? document.body : typeof i == "string" ? document.querySelector(i) : i;
      if (r == null) {
        Ps(`Unable to locate target ${i}`);
        return;
      }
      let n = [...r.children].find((t) => t.matches(".v-overlay-container"));
      return n || (n = document.createElement("div"), n.className = "v-overlay-container", r.appendChild(n)), n;
    })
  };
}
const Gn = ee({
  transition: {
    type: null,
    default: "fade-transition",
    validator: (e) => e !== !0
  }
}, "transition"), Wt = (e, a) => {
  let {
    slots: i
  } = a;
  const {
    transition: r,
    disabled: n,
    group: t,
    ...s
  } = e, {
    component: o = t ? Go : sn,
    ...l
  } = ms(r) ? r : {};
  let u;
  return ms(r) ? u = re(l, iw({
    disabled: n,
    group: t
  }), s) : u = re({
    name: n || !r ? "" : r
  }, s), Oe(o, u, i);
};
function l$() {
  return !0;
}
function Np(e, a, i) {
  if (!e || Lp(e, i) === !1) return !1;
  const r = ep(a);
  if (typeof ShadowRoot < "u" && r instanceof ShadowRoot && r.host === e.target) return !1;
  const n = (typeof i.value == "object" && i.value.include || (() => []))();
  return n.push(a), !n.some((t) => t?.contains(e.target));
}
function Lp(e, a) {
  return (typeof a.value == "object" && a.value.closeConditional || l$)(e);
}
function o$(e, a, i) {
  const r = typeof i.value == "function" ? i.value : i.value.handler;
  e.shadowTarget = e.target, a._clickOutside.lastMousedownWasOutside && Np(e, a, i) && setTimeout(() => {
    Lp(e, i) && r && r(e);
  }, 0);
}
function bm(e, a) {
  const i = ep(e);
  a(document), typeof ShadowRoot < "u" && i instanceof ShadowRoot && a(i);
}
const km = {
  // [data-app] may not be found
  // if using bind, inserted makes
  // sure that the root element is
  // available, iOS does not support
  // clicks on body
  mounted(e, a) {
    const i = (n) => o$(n, e, a), r = (n) => {
      e._clickOutside.lastMousedownWasOutside = Np(n, e, a);
    };
    bm(e, (n) => {
      n.addEventListener("click", i, !0), n.addEventListener("mousedown", r, !0);
    }), e._clickOutside || (e._clickOutside = {
      lastMousedownWasOutside: !1
    }), e._clickOutside[a.instance.$.uid] = {
      onClick: i,
      onMousedown: r
    };
  },
  beforeUnmount(e, a) {
    e._clickOutside && (bm(e, (i) => {
      if (!i || !e._clickOutside?.[a.instance.$.uid]) return;
      const {
        onClick: r,
        onMousedown: n
      } = e._clickOutside[a.instance.$.uid];
      i.removeEventListener("click", r, !0), i.removeEventListener("mousedown", n, !0);
    }), delete e._clickOutside[a.instance.$.uid]);
  }
};
function u$(e) {
  const {
    modelValue: a,
    color: i,
    ...r
  } = e;
  return C(sn, {
    name: "fade-transition",
    appear: !0
  }, {
    default: () => [e.modelValue && D("div", re({
      class: ["v-overlay__scrim", e.color.backgroundColorClasses.value],
      style: e.color.backgroundColorStyles.value
    }, r), null)]
  });
}
const Eu = ee({
  absolute: Boolean,
  attach: [Boolean, String, Object],
  closeOnBack: {
    type: Boolean,
    default: !0
  },
  contained: Boolean,
  contentClass: null,
  contentProps: null,
  disabled: Boolean,
  opacity: [Number, String],
  noClickAnimation: Boolean,
  modelValue: Boolean,
  persistent: Boolean,
  scrim: {
    type: [Boolean, String],
    default: !0
  },
  zIndex: {
    type: [Number, String],
    default: 2e3
  },
  ...QS(),
  ...Se(),
  ...Mt(),
  ...Iu(),
  ...qS(),
  ...US(),
  ...a$(),
  ...Qe(),
  ...Gn()
}, "VOverlay"), Ss = de()({
  name: "VOverlay",
  directives: {
    vClickOutside: km
  },
  inheritAttrs: !1,
  props: {
    _disableGlobalStack: Boolean,
    ...Le(Eu(), ["disableInitialFocus"])
  },
  emits: {
    "click:outside": (e) => !0,
    "update:modelValue": (e) => !0,
    keydown: (e) => !0,
    afterEnter: () => !0,
    afterLeave: () => !0
  },
  setup(e, a) {
    let {
      slots: i,
      attrs: r,
      emit: n
    } = a;
    const t = ft("VOverlay"), s = ie(), o = ie(), l = ie(), u = $e(e, "modelValue"), c = I({
      get: () => u.value,
      set: (z) => {
        z && e.disabled || (u.value = z);
      }
    }), {
      themeClasses: d
    } = ut(e), {
      rtlClasses: f,
      isRtl: v
    } = St(), {
      hasContent: g,
      onAfterLeave: h
    } = Ou(e, c), y = at(() => typeof e.scrim == "string" ? e.scrim : null), {
      globalTop: m,
      localTop: p,
      stackStyles: b
    } = i$(c, () => e.zIndex, e._disableGlobalStack), {
      activatorEl: w,
      activatorRef: k,
      target: S,
      targetEl: _,
      targetRef: P,
      activatorEvents: M,
      contentEvents: q,
      scrimEvents: K
    } = e$(e, {
      isActive: c,
      isTop: p,
      contentEl: l
    }), {
      teleportTarget: j
    } = s$(() => {
      const z = e.attach || e.contained;
      if (z) return z;
      const X = w?.value?.getRootNode() || t.proxy?.$el?.getRootNode();
      return X instanceof ShadowRoot ? X : !1;
    }), {
      dimensionStyles: H
    } = Rt(e), B = r$(), {
      scopeId: L
    } = Us();
    ce(() => e.disabled, (z) => {
      z && (c.value = !1);
    });
    const {
      contentStyles: O,
      updateLocation: U
    } = zS(e, {
      isRtl: v,
      contentEl: l,
      target: S,
      isActive: c
    });
    WS(e, {
      root: s,
      contentEl: l,
      targetEl: _,
      target: S,
      isActive: c,
      updateLocation: U
    });
    function Z(z) {
      n("click:outside", z), e.persistent ? $() : c.value = !1;
    }
    function J(z) {
      return c.value && p.value && // If using scrim, only close if clicking on it rather than anything opened on top
      (!e.scrim || z.target === o.value || z instanceof MouseEvent && z.shadowTarget === o.value);
    }
    n$(e, {
      isActive: c,
      localTop: p,
      contentEl: l
    }), et && ce(c, (z) => {
      z ? window.addEventListener("keydown", A) : window.removeEventListener("keydown", A);
    }, {
      immediate: !0
    }), ha(() => {
      et && window.removeEventListener("keydown", A);
    });
    function A(z) {
      z.key === "Escape" && m.value && (l.value?.contains(document.activeElement) || n("keydown", z), e.persistent ? $() : (c.value = !1, l.value?.contains(document.activeElement) && w.value?.focus()));
    }
    function T(z) {
      z.key === "Escape" && !m.value || n("keydown", z);
    }
    const E = _S();
    Na(() => e.closeOnBack, () => {
      PS(E, (z) => {
        m.value && c.value ? (z(!1), e.persistent ? $() : c.value = !1) : z();
      });
    });
    const x = ie();
    ce(() => c.value && (e.absolute || e.contained) && j.value == null, (z) => {
      if (z) {
        const X = gu(s.value);
        X && X !== document.scrollingElement && (x.value = X.scrollTop);
      }
    });
    function $() {
      e.noClickAnimation || l.value && _a(l.value, [{
        transformOrigin: "center"
      }, {
        transform: "scale(1.03)"
      }, {
        transformOrigin: "center"
      }], {
        duration: 150,
        easing: hr
      });
    }
    function V() {
      n("afterEnter");
    }
    function F() {
      h(), n("afterLeave");
    }
    return me(() => D(pe, null, [i.activator?.({
      isActive: c.value,
      targetRef: P,
      props: re({
        ref: k
      }, M.value, e.activatorProps)
    }), B.value && g.value && C(oy, {
      disabled: !j.value,
      to: j.value
    }, {
      default: () => [D("div", re({
        class: ["v-overlay", {
          "v-overlay--absolute": e.absolute || e.contained,
          "v-overlay--active": c.value,
          "v-overlay--contained": e.contained
        }, d.value, f.value, e.class],
        style: [b.value, {
          "--v-overlay-opacity": e.opacity,
          top: he(x.value)
        }, e.style],
        ref: s,
        onKeydown: T
      }, L, r), [C(u$, re({
        color: y,
        modelValue: c.value && !!e.scrim,
        ref: o
      }, K.value), null), C(Wt, {
        appear: !0,
        persisted: !0,
        transition: e.transition,
        target: S.value,
        onAfterEnter: V,
        onAfterLeave: F
      }, {
        default: () => [Je(D("div", re({
          ref: l,
          class: ["v-overlay__content", e.contentClass],
          style: [H.value, O.value]
        }, q.value, e.contentProps), [i.default?.({
          isActive: c
        })]), [[ya, c.value], [km, {
          handler: Z,
          closeConditional: J,
          include: () => [w.value]
        }]])]
      })])]
    })])), {
      activatorEl: w,
      scrimEl: o,
      target: S,
      animateClick: $,
      contentEl: l,
      rootEl: s,
      globalTop: m,
      localTop: p,
      updateLocation: U
    };
  }
}), Xl = /* @__PURE__ */ Symbol("Forwarded refs");
function Zl(e, a) {
  let i = e;
  for (; i; ) {
    const r = Reflect.getOwnPropertyDescriptor(i, a);
    if (r) return r;
    i = Object.getPrototypeOf(i);
  }
}
function Pt(e) {
  for (var a = arguments.length, i = new Array(a > 1 ? a - 1 : 0), r = 1; r < a; r++)
    i[r - 1] = arguments[r];
  return e[Xl] = i, new Proxy(e, {
    get(n, t) {
      if (Reflect.has(n, t))
        return Reflect.get(n, t);
      if (!(typeof t == "symbol" || t.startsWith("$") || t.startsWith("__"))) {
        for (const s of i)
          if (s.value && Reflect.has(s.value, t)) {
            const o = Reflect.get(s.value, t);
            return typeof o == "function" ? o.bind(s.value) : o;
          }
      }
    },
    has(n, t) {
      if (Reflect.has(n, t))
        return !0;
      if (typeof t == "symbol" || t.startsWith("$") || t.startsWith("__")) return !1;
      for (const s of i)
        if (s.value && Reflect.has(s.value, t))
          return !0;
      return !1;
    },
    set(n, t, s) {
      if (Reflect.has(n, t))
        return Reflect.set(n, t, s);
      if (typeof t == "symbol" || t.startsWith("$") || t.startsWith("__")) return !1;
      for (const o of i)
        if (o.value && Reflect.has(o.value, t))
          return Reflect.set(o.value, t, s);
      return !1;
    },
    getOwnPropertyDescriptor(n, t) {
      const s = Reflect.getOwnPropertyDescriptor(n, t);
      if (s) return s;
      if (!(typeof t == "symbol" || t.startsWith("$") || t.startsWith("__"))) {
        for (const o of i) {
          if (!o.value) continue;
          const l = Zl(o.value, t) ?? ("_" in o.value ? Zl(o.value._?.setupState, t) : void 0);
          if (l) return l;
        }
        for (const o of i) {
          const l = o.value && o.value[Xl];
          if (!l) continue;
          const u = l.slice();
          for (; u.length; ) {
            const c = u.shift(), d = Zl(c.value, t);
            if (d) return d;
            const f = c.value && c.value[Xl];
            f && u.push(...f);
          }
        }
      }
    }
  });
}
const c$ = ee({
  // TODO
  // disableKeys: Boolean,
  id: String,
  submenu: Boolean,
  ...Le(Eu({
    captureFocus: !0,
    closeDelay: 250,
    closeOnContentClick: !0,
    locationStrategy: "connected",
    location: void 0,
    openDelay: 300,
    scrim: !1,
    scrollStrategy: "reposition",
    transition: {
      component: Cu
    }
  }), ["absolute"])
}, "VMenu"), La = de()({
  name: "VMenu",
  props: c$(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, a) {
    let {
      slots: i
    } = a;
    const r = $e(e, "modelValue"), {
      scopeId: n
    } = Us(), {
      isRtl: t
    } = St(), s = Xt(), o = W(() => e.id || `v-menu-${s}`), l = ie(), u = qe(Eo, null), c = fe(/* @__PURE__ */ new Set());
    ht(Eo, {
      register() {
        c.value.add(s);
      },
      unregister() {
        c.value.delete(s);
      },
      closeParents(h) {
        setTimeout(() => {
          !c.value.size && !e.persistent && (h == null || l.value?.contentEl && !aw(h, l.value.contentEl)) && (r.value = !1, u?.closeParents());
        }, 40);
      }
    }), ha(() => u?.unregister()), uy(() => r.value = !1), ce(r, (h) => {
      h ? u?.register() : u?.unregister();
    }, {
      immediate: !0
    });
    function d(h) {
      u?.closeParents(h);
    }
    function f(h) {
      if (!e.disabled)
        if (h.key === "Tab" || h.key === "Enter" && !e.closeOnContentClick) {
          if (h.key === "Enter" && (h.target instanceof HTMLTextAreaElement || h.target instanceof HTMLInputElement && h.target.closest("form"))) return;
          h.key === "Enter" && h.preventDefault(), !Hv(an(l.value?.contentEl, !1), h.shiftKey ? "prev" : "next", (m) => m.tabIndex >= 0) && !e.retainFocus && (r.value = !1, l.value?.activatorEl?.focus());
        } else e.submenu && h.key === (t.value ? "ArrowRight" : "ArrowLeft") && (r.value = !1, l.value?.activatorEl?.focus());
    }
    function v(h) {
      if (e.disabled) return;
      const y = l.value?.contentEl;
      y && r.value ? h.key === "ArrowDown" ? (h.preventDefault(), h.stopImmediatePropagation(), cr(y, "next")) : h.key === "ArrowUp" ? (h.preventDefault(), h.stopImmediatePropagation(), cr(y, "prev")) : e.submenu && (h.key === (t.value ? "ArrowRight" : "ArrowLeft") ? r.value = !1 : h.key === (t.value ? "ArrowLeft" : "ArrowRight") && (h.preventDefault(), cr(y, "first"))) : (e.submenu ? h.key === (t.value ? "ArrowLeft" : "ArrowRight") : ["ArrowDown", "ArrowUp"].includes(h.key)) && (r.value = !0, h.preventDefault(), setTimeout(() => setTimeout(() => v(h))));
    }
    const g = I(() => re({
      "aria-haspopup": "menu",
      "aria-expanded": String(r.value),
      "aria-controls": o.value,
      "aria-owns": o.value,
      onKeydown: v
    }, e.activatorProps));
    return me(() => {
      const h = Ss.filterProps(e);
      return C(Ss, re({
        ref: l,
        id: o.value,
        class: ["v-menu", e.class],
        style: e.style
      }, h, {
        modelValue: r.value,
        "onUpdate:modelValue": (y) => r.value = y,
        absolute: !0,
        activatorProps: g.value,
        location: e.location ?? (e.submenu ? "end" : "bottom"),
        "onClick:outside": d,
        onKeydown: f
      }, n), {
        activator: i.activator,
        default: function() {
          for (var y = arguments.length, m = new Array(y), p = 0; p < y; p++)
            m[p] = arguments[p];
          return C(je, {
            root: "VMenu"
          }, {
            default: () => [i.default?.(...m)]
          });
        }
      });
    }), Pt({
      id: o,
      ΨopenChildren: c
    }, l);
  }
}), wm = /* @__PURE__ */ Symbol.for("vjsf:z-index-stack"), gn = (e) => {
  const a = qe(wm, { zIndex: 3e3, fullKey: e, initial: !0 }), i = a.zIndex + 10;
  return (a.initial || e.length > a.fullKey.length) && ht(wm, { zIndex: i, fullKey: e }), i;
}, d$ = ["innerHTML"], f$ = ["innerHTML"], m$ = {
  __name: "help-message",
  props: {
    node: {
      /** @type import('vue').PropType<import('../../types.js').VjsfNode> */
      type: Object,
      required: !0
    }
  },
  setup(e) {
    const i = gn(e.node.fullKey), r = ie(!1);
    return (n, t) => (oe(), De("div", {
      class: ue(`vjsf-help-message vjsf-help-message-${e.node.options.density}`)
    }, [
      C(Y(La), {
        modelValue: r.value,
        "onUpdate:modelValue": t[0] || (t[0] = (s) => r.value = s),
        class: ue(`vjsf-help-message-tooltip vjsf-help-message-tooltip-${e.node.options.density}`),
        location: "top end",
        offset: "4",
        "z-index": Y(i),
        "close-on-content-click": !1
      }, {
        activator: le(({ props: s }) => [
          C(Y(Te), re({
            color: e.node.layout.warning ? "warning" : "info",
            class: "vjsf-help-message-toggle",
            icon: e.node.layout.warning ? e.node.options.icons.alert : e.node.options.icons.infoSymbol,
            density: "compact",
            variant: e.node.layout.warning ? "text" : "flat",
            size: e.node.options.density === "default" ? 28 : 24,
            title: r.value ? "" : e.node.messages.showHelp
          }, s), null, 16, ["color", "icon", "variant", "size", "title"])
        ]),
        default: le(() => [
          C(Y(Vp), {
            color: e.node.layout.warning ? "warning" : "info",
            density: e.node.options.density
          }, {
            default: le(() => [
              e.node.layout.warning ? (oe(), De("p", {
                key: 0,
                class: "mb-2",
                innerHTML: e.node.layout.warning
              }, null, 8, d$)) : Ve("", !0),
              e.node.layout.help ? (oe(), De("div", {
                key: 1,
                innerHTML: e.node.layout.help
              }, null, 8, f$)) : Ve("", !0)
            ]),
            _: 1
          }, 8, ["color", "density"])
        ]),
        _: 1
      }, 8, ["modelValue", "class", "z-index"])
    ], 2));
  }
}, la = {
  __name: "node",
  props: {
    modelValue: {
      /** @type import('vue').PropType<import('../types.js').VjsfNode> */
      type: Object,
      required: !0
    },
    statefulLayout: {
      /** @type import('vue').PropType<import('../types.js').VjsfStatefulLayout> */
      type: Object,
      required: !0
    }
  },
  setup(e) {
    const a = Jt("vjsf:render");
    Ge({}, "VjsfNode");
    const i = e, r = {
      compact: "my-1",
      comfortable: "my-2",
      default: "my-3"
    }, n = qs();
    a.enabled && (a("setup node", i.modelValue.fullKey, i.modelValue.layout.comp), cy(() => {
      a("render node", i.modelValue.fullKey, i.modelValue.layout.comp);
    }));
    const t = I(() => i.modelValue.parentFullKey === null || !i.modelValue.options.indent || i.modelValue.layout.comp !== "section" || !i.modelValue.layout.title ? 0 : typeof i.modelValue.options.indent == "number" ? i.modelValue.options.indent : i.modelValue.options.density === "compact" ? 2 : i.modelValue.options.density === "comfortable" ? 4 : 6), s = I(() => (i.modelValue.layout.help || i.modelValue.layout.warning) && !i.modelValue.options.summary), o = I(() => {
      let l = `vjsf-node vjsf-node-${i.modelValue.layout.comp} vjsf-density-${i.modelValue.options.density}`;
      return i.modelValue.options.readOnly && (l += " vjsf-readonly"), i.modelValue.options.summary && (l += " vjsf-summary"), n.current.value.dark && (l += " vjsf-dark"), t.value && (l += " ml-" + t.value), s.value && (l += " vjsf-has-help"), l;
    });
    return i.modelValue.layout.comp !== "none" && !i.modelValue.slots?.component && !i.modelValue.slots?.compositeComponent && !i.statefulLayout.options.nodeComponents[i.modelValue.layout.comp] && console.error(`vjsf: missing component to render vjsf node "${i.modelValue.layout.comp}", maybe you forgot to register a component from a plugin ?`), (l, u) => (oe(), ye(Y(je), {
      defaults: { global: { density: i.modelValue.options.density } }
    }, {
      default: le(() => [
        e.modelValue.layout.comp !== "none" ? (oe(), ye(Y(sp), {
          key: 0,
          cols: e.modelValue.cols,
          class: ue(o.value)
        }, {
          default: le(() => [
            e.modelValue.slots?.before ? (oe(), ye(sr, {
              key: "before",
              "layout-slot": e.modelValue.slots?.before,
              node: e.modelValue,
              "stateful-layout": e.statefulLayout,
              class: ue(r[e.modelValue.options.density])
            }, null, 8, ["layout-slot", "node", "stateful-layout", "class"])) : Ve("", !0),
            s.value ? (oe(), ye(m$, {
              key: 1,
              node: e.modelValue
            }, null, 8, ["node"])) : Ve("", !0),
            e.modelValue.slots?.component ? (oe(), ye(sr, {
              key: "component",
              "layout-slot": e.modelValue.slots?.component,
              node: e.modelValue,
              "stateful-layout": e.statefulLayout
            }, null, 8, ["layout-slot", "node", "stateful-layout"])) : e.modelValue.slots?.compositeComponent ? (oe(), ye(sr, {
              key: "compositeComponent",
              "layout-slot": e.modelValue.slots?.compositeComponent,
              node: e.modelValue,
              "stateful-layout": e.statefulLayout
            }, null, 8, ["layout-slot", "node", "stateful-layout"])) : (oe(), ye(Wo(i.statefulLayout.options.nodeComponents[e.modelValue.layout.comp]), {
              key: 4,
              "model-value": e.modelValue,
              "stateful-layout": e.statefulLayout
            }, null, 8, ["model-value", "stateful-layout"])),
            e.modelValue.slots?.after ? (oe(), ye(sr, {
              key: "after",
              "layout-slot": e.modelValue.slots?.after,
              node: e.modelValue,
              "stateful-layout": e.statefulLayout,
              class: ue(r[e.modelValue.options.density])
            }, null, 8, ["layout-slot", "node", "stateful-layout", "class"])) : Ve("", !0)
          ]),
          _: 1
        }, 8, ["cols", "class"])) : Ve("", !0)
      ]),
      _: 1
    }, 8, ["defaults"]));
  }
}, v$ = {
  __name: "tree",
  props: {
    modelValue: {
      /** @type import('vue').PropType<import('@json-layout/core').StateTree> */
      type: Object,
      required: !0
    },
    statefulLayout: {
      /** @type import('vue').PropType<import('../types.js').VjsfStatefulLayout> */
      type: Object,
      required: !0
    }
  },
  setup(e) {
    return (a, i) => (oe(), ye(Y(sa), { class: "vjsf-tree" }, {
      default: le(() => [
        C(la, {
          "stateful-layout": e.statefulLayout,
          "model-value": (
            /** @type import('../types.js').VjsfNode */
            e.modelValue.root
          )
        }, null, 8, ["stateful-layout", "model-value"])
      ]),
      _: 1
    }));
  }
}, Gi = ["xs", "sm", "md", "lg", "xl", "xxl"], ct = {
  xs: 0,
  sm: 600,
  md: 960,
  lg: 1280,
  xl: 1920,
  xxl: 2560
};
class $s {
  /**
   * @readonly
   * @type {number}
   */
  width;
  /**
   * @param {number} width
   */
  constructor(a) {
    this.width = a;
  }
  /** @returns {BreakPointName} */
  get name() {
    for (let a = 0; a < Gi.length; a++)
      if (Gi[a + 1] && this.width < ct[Gi[a + 1]]) return Gi[a];
    return "xxl";
  }
  /** @returns {boolean} */
  get xs() {
    return this.width < ct.sm;
  }
  /** @returns {boolean} */
  get sm() {
    return this.width >= ct.sm && this.width < ct.md;
  }
  /** @returns {boolean} */
  get smAndDown() {
    return this.width < ct.md;
  }
  /** @returns {boolean} */
  get smAndUp() {
    return this.width >= ct.sm;
  }
  /** @returns {boolean} */
  get md() {
    return this.width >= ct.md && this.width < ct.lg;
  }
  /** @returns {boolean} */
  get mdAndDown() {
    return this.width < ct.lg;
  }
  /** @returns {boolean} */
  get mobile() {
    return this.mdAndDown;
  }
  /** @returns {boolean} */
  get mdAndUp() {
    return this.width >= ct.md;
  }
  /** @returns {boolean} */
  get lg() {
    return this.width >= ct.lg && this.width < ct.xl;
  }
  /** @returns {boolean} */
  get lgAndDown() {
    return this.width < ct.xl;
  }
  /** @returns {boolean} */
  get lgAndUp() {
    return this.width >= ct.lg;
  }
  /** @returns {boolean} */
  get xl() {
    return this.width >= ct.xl && this.width < ct.xxl;
  }
  /** @returns {boolean} */
  get xlAndDown() {
    return this.width < ct.xxl;
  }
  /** @returns {boolean} */
  get xlAndUp() {
    return this.width >= ct.xl;
  }
  /** @returns {boolean} */
  get xxl() {
    return this.width >= ct.xxl;
  }
}
function p$(e, a) {
  if (!a) return [e, 12];
  let i = a.xs;
  return e.smAndUp && a.sm !== void 0 && (i = a.sm), e.mdAndUp && a.md !== void 0 && (i = a.md), e.lgAndUp && a.lg !== void 0 && (i = a.lg), e.xlAndUp && a.xl !== void 0 && (i = a.xl), e.xxl && a.xxl !== void 0 && (i = a.xxl), [i === 12 ? e : new $s(Math.round(e.width * (i / 12))), i];
}
const Jl = {};
function Au(e) {
  return Jl[e] = Jl[e] ?? new RegExp(e), Jl[e];
}
const Sm = typeof window > "u" ? "http://test.com" : window.location.origin, h$ = (e, a) => e.startsWith("http://") || e.startsWith("https://") ? new URL(e) : e.startsWith("/") ? new URL(Sm + e) : new URL(Sm + a + e), Yi = Jt("jl:state-node"), y$ = Jt("jl:validation"), Ql = Jt("jl:get-items"), as = (e) => !!(e === "" || e === void 0 || Array.isArray(e) && !e.length || typeof e == "object" && !Array.isArray(e) && e && Object.values(e).findIndex((a) => a !== void 0) === -1), qp = (e, a, i) => !!(i.defaultOn === "missing" && e === void 0 || i.defaultOn === "empty" && as(e)), g$ = gt((e, a, i, r, n, t, s, o, l, u, c, d, f, v, g, h, y, m, p, b) => {
  if (e.messages = o.messages ? b$(e.messages || {}, o.messages, v) : v.messages, e.key = a, e.fullKey = i, e.parentFullKey = r, e.dataPath = n, e.parentDataPath = t, e.skeleton = s, e.layout = o, e.width = l, e.options = v, e.cols = u, h || e.loading && e.data === c ? e.loading = !0 : delete e.loading, e.data = c, e.error = d, e.itemsCacheKey = p, e.childError = b && b.findIndex((w) => w.error || w.childError) !== -1, e.validated = f, g)
    e.autofocus = !0, delete e.autofocusChild;
  else {
    delete e.autofocus;
    const w = b?.find((k) => k.autofocus);
    w ? e.autofocusChild = w.key : delete e.autofocusChild;
  }
  e.props = y, e.slots = m, e.children = b;
}), b$ = gt((e, a, i) => {
  Object.assign(e, i.messages, a);
}), k$ = gt((e, a) => {
  for (const i of a) {
    const r = (
      /** @type {number} */
      i.key
    );
    i.data === void 0 ? delete e[r] : e[r] = i.data;
  }
  for (; e.length && e[e.length - 1] === void 0; )
    e.pop();
}), w$ = gt((e, a, i, r, n) => {
  for (let t = 0; t < e.length; t++)
    typeof e[t] == "object" && e[t] !== null && !(e[t] instanceof File) && (e[t] = Ao(e[t], a + "/" + t, i, r, n));
}), Ao = gt((e, a, i, r, n) => {
  if (r)
    for (const t of Object.keys(e))
      r.includes(t) || delete e[t];
  if (n)
    for (const t of n)
      delete e[t];
  if (i?.length)
    for (const t of i)
      t.instancePath === a && (t.keyword === "additionalProperties" && delete e[t.params.additionalProperty], t.keyword === "unevaluatedProperties" && delete e[t.params.unevaluatedProperty]);
  for (const t of Object.keys(e))
    e[t] === void 0 && delete e[t];
}), $m = gt((e, a, i, r) => {
  if (i.dataPath === a) {
    if (i.data === void 0 || i.data === null) return;
    if (r && r.length > 1)
      for (const n of Object.keys(i.data))
        i.skeleton.propertyKeys.includes(n) && (!i.skeleton.propertyKeys.includes(n) && r.some((t) => t !== i.skeleton && t.propertyKeys.includes(n)) || (e[n] = /** @type {any} */
        i.data[n]));
    else
      Object.assign(e, i.data);
    for (const n of i.skeleton.propertyKeys)
      /** @type {any} */
      i.data[n] === void 0 && delete e[n];
  } else
    i.data === void 0 ? delete e[i.key] : e[i.key] = i.data;
}), S$ = gt((e, a, i, r) => {
  for (const n of Object.keys(a))
    i.includes(n) || r.some((t) => !!n.match(Au(t))) && (e[n] = a[n]);
  for (const n of Object.keys(e))
    n in a || delete e[n];
}), $$ = gt((e, a, i = {}) => {
  for (const r in a)
    e[r] = i[r] ?? a[r];
  for (const r in i)
    e[r] = i[r];
  for (const r in e)
    !(r in a) && !(r in i) && delete e[r];
}), _m = gt((e) => {
  e.readOnly = !0, e.summary = !0;
}), _$ = gt((e, a) => {
  a.title && e.titleDepth < 6 && (e.titleDepth += 1);
}), Pm = (e, a, i, r) => {
  const n = e.params?.errors?.[0] ?? e;
  return r === n.instancePath && n.params?.missingProperty === a.key || n.instancePath === i && (n.schemaPath === a.pointer || n.schemaPath === a.refPointer) && !n.params?.missingProperty;
}, xn = (e, a, i, r, n) => {
  const t = a.params?.errors?.[0] ?? a;
  if (!t.instancePath.startsWith(r)) return !1;
  if (t.schemaPath === i.pointer || t.schemaPath.startsWith(i.pointer + "/") || t.schemaPath === i.refPointer || t.schemaPath.startsWith(i.refPointer + "/")) return !0;
  if (i.children)
    for (const s of i.children) {
      const o = e.skeletonNodes[s];
      if (o && dr(a, o.pointer, o.refPointer, r))
        return !0;
    }
  if (i.childrenTrees)
    for (const s of i.childrenTrees) {
      const o = e.skeletonTrees[s];
      if (o && dr(a, o.root, o.refPointer, r))
        return !0;
    }
  return !1;
}, Cm = (e, a) => (e.params?.errors?.[0] ?? e).instancePath.startsWith(a), dr = (e, a, i, r, n) => {
  const t = e.params?.errors?.[0] ?? e;
  return t.instancePath.startsWith(r) ? !!(t.schemaPath === a || t.schemaPath.startsWith(a + "/") || t.schemaPath === i || t.schemaPath.startsWith(i + "/")) : !1;
};
function qt(e, a, i, r, n, t, s, o, l) {
  if (a.ref === void 0) throw new Error("expression was not compiled : " + JSON.stringify(a));
  const u = e[a.ref];
  try {
    return a.pure ? u(i, i, r, r.context, n, t, r.readOnly, r.summary, s) : u(i, i, r, r.context, n, t, r.readOnly, r.summary, s, o, l);
  } catch (c) {
    const d = { expression: a, data: i, context: r.context, display: n };
    throw d[a.dataAlias] = i, a.pure || (d.rootData = o, d.parent = l), console.warn("json-layout: failed to evaluate expression", c, d), new Error("json-layout: failed to evaluate expression");
  }
}
const eo = { comp: "none" }, P$ = (e, a, i, r, n, t, s, o) => {
  if (Ja(e)) {
    for (const l of e.switch)
      if (!l.if || qt(r.expressions, l.if, t, i, n, l, r.validates, s, o))
        return l;
  } else
    return a?.if && !qt(r.expressions, a.if, t, i, n, e, r.validates, s, o) || e.if && !qt(r.expressions, e.if, t, i, n, e, r.validates, s, o) ? eo : e;
  return eo;
};
function Vn(e, a, i, r, n, t, s, o, l, u, c, d, f, v, g) {
  Yi("createStateNode", n);
  let h = null;
  if (l.pure && !g?.error && !g?.childError && !a.noStateCache) {
    const O = v.validatedForm || v.validatedChildren.includes(n);
    if (h = [
      g,
      a,
      i,
      n,
      e.currentInput !== null && e.currentInput.startsWith(n),
      l,
      u,
      c.width,
      O,
      e.activatedItems,
      e.initial,
      e.rehydrateErrors?.length ?? 0,
      d
    ], g && e.cacheKeys[n] && jv(e.cacheKeys[n], h))
      return Yi("createStateNode cache hit", n), e._debugCache && (e._debugCache[n] = (e._debugCache[n] ?? []).concat(["hit"])), g.layout.comp === "list" && g.layout.getItems && Ql(n, "list component node is fully reused from cache, no fetch will be triggered"), g;
    Yi("createStateNode cache miss", n), e._debugCache && (e._debugCache[n] = (e._debugCache[n] ?? []).concat(["miss"]));
  } else
    Yi("createStateNode cache skip", n), e._debugCache && (e._debugCache[n] = (e._debugCache[n] ?? []).concat(["skip"]));
  const y = u && (Xm(u) || tg(u)) ? u : i.normalizedLayouts[l.pointer], m = P$(y, u, a, i, c, d, e.rootData, f), [p, b] = p$(c, u?.cols ?? m.cols), w = u?.slots ?? m.slots, k = m.getOptions ? $$(
    g?.options ?? /** @type {import('./types.js').StateNodeOptions} */
    {},
    a,
    qt(i.expressions, m.getOptions, d, a, p, m, i.validates, e.rootData, f)
  ) : a;
  e.initial && a.autofocus && m.autofocus && m.comp !== "none" && (e.autofocusTarget = n);
  let S = d;
  S === null && !m.nullable && (S = void 0);
  const _ = m.getDefaultData && qp(S, m, k) && e.currentInput !== n;
  if (m.getConstData)
    e.rehydrate || (S = qt(i.expressions, m.getConstData, S, k, p, m, i.validates, e.rootData, f));
  else if (_ && m.getDefaultData && !e.rehydrate) {
    const O = qt(i.expressions, m.getDefaultData, S, k, p, m, i.validates, e.rootData, f);
    (S === void 0 || !as(O)) && (S = O);
  }
  let P;
  if (lr(m, i.components)) {
    const O = _$(k, m);
    let U = l.propertyKeys;
    const Z = k.readOnlyPropertiesMode === "remove" ? l.roPropertyKeys : [];
    P = [];
    let J = e.autofocusTarget === n;
    for (let T = 0; T < m.children.length; T++) {
      const E = (
        /** @type {Record<string, unknown>} */
        S ?? {}
      ), x = m.children[T];
      if (["remove", "hide"].includes(k.readOnlyPropertiesMode) && l.roPropertyKeys?.includes(
        /** @type {string} */
        x.key
      )) continue;
      let $ = l;
      const V = l.children?.find((N) => i.skeletonNodes[N].key === x.key);
      if (V !== void 0 && ($ = i.skeletonNodes[V]), $.condition && !qt(i.expressions, $.condition, E, a, p, m, i.validates, e.rootData, f)) {
        if (x.key === "$then" || x.key === "$else") {
          const N = l.children?.find((G) => i.skeletonNodes[G].key === (x.key === "$then" ? "$else" : "$then")), R = N !== void 0 && i.skeletonNodes[N];
          if (R)
            for (const G of $.propertyKeys)
              R.propertyKeys.includes(G) || Z.push(G);
        }
        continue;
      }
      const F = typeof x.key == "string" && x.key.startsWith("$"), z = `${n}/${x.key}`;
      J && (e.autofocusTarget = z);
      const X = F ? E : E[x.key];
      let Q = X;
      if (x.key === "$patternProperties") {
        const N = (
          /** @type {import('@json-layout/vocabulary').List} */
          i.normalizedLayouts[$.pointer]
        );
        Q = S$(
          /** @type {Record<string, unknown>} */
          g?.children?.find((R) => R.key === "$patternProperties")?.data ?? {},
          /** @type {Record<string, unknown>} */
          E,
          l.propertyKeys,
          N.indexed ?? []
        ), U = U.concat(Object.keys(
          /** @type {any} */
          Q
        ));
      }
      const te = Vn(
        e,
        O,
        i,
        x.key,
        z,
        n,
        F ? s : `${s}/${x.key}`,
        s,
        $,
        x,
        p,
        Q,
        { parent: f, data: E },
        v,
        g?.children?.find((N) => N.fullKey === z)
      );
      (te.autofocus || te.autofocusChild !== void 0) && (J = !1), te.data !== X && (S = $m(
        S ?? (typeof te.key == "number" && r !== "$oneOf" ? [] : {}),
        s,
        te,
        l.children?.map((N) => i.skeletonNodes[N])
      )), P.push(te);
    }
    const A = [!0, "unknown"].includes(k.removeAdditional) || P?.some((T) => T.key === "$patternProperties");
    S = Ao(
      /** @type {Record<string, unknown>} */
      S ?? {},
      s,
      e.additionalPropertiesErrors,
      A ? U : void 0,
      Z
    );
  }
  if (l.nullable && e.errors && (e.errors = e.errors.filter((O) => Cm(O, s) ? !(O.keyword === "anyOf" || O.keyword === "type" && O.params?.type === "null") : !0)), r === "$oneOf" && l.childrenTrees) {
    let O = (
      /** @type {number} */
      e.activatedItems[n]
    );
    const U = l.childrenTrees?.findIndex((Z) => i.validates[i.skeletonTrees[Z].refPointer](d));
    if (O === void 0 && (l.discriminator !== void 0 && U === -1 ? O = l.childrenTrees?.findIndex((Z) => l.discriminator !== void 0 && d?.[l.discriminator] !== void 0 && d[l.discriminator] === i.skeletonTrees[Z].discriminatorValue) : O = U), O !== -1) {
      const Z = i.skeletonTrees[l.childrenTrees[O]], J = i.skeletonNodes[Z.root];
      n in e.activatedItems || (e.autoActivatedItems[n] = O), e.errors = e.errors?.filter((E) => !(Pm(E, l, s, o) || xn(i, E, l, s) && !dr(E, J.pointer, J.refPointer, s))), e.additionalPropertiesErrors?.length && (e.additionalPropertiesErrors = e.additionalPropertiesErrors?.filter((E) => !Cm(E, s) || dr(E, J.pointer, J.refPointer, s) ? !0 : !(xn(i, E, l, s) && !dr(E, J.pointer, J.refPointer, s) || U === -1)));
      const A = `${n}/${O}`;
      e.autofocusTarget === n && (e.autofocusTarget = A);
      const T = Vn(
        e,
        k,
        i,
        O,
        A,
        n,
        s,
        s,
        J,
        null,
        p,
        S,
        { parent: f, data: S },
        v,
        g?.children?.[0]
      );
      T.data !== S && (S = T.data), P = [T];
    }
  }
  if (Zm(m))
    if (m.indexed) {
      const O = (
        /** @type {Record<string, unknown>} */
        S ?? []
      ), U = m.listEditMode === "inline" ? k : _m(k);
      P = [];
      let Z = e.autofocusTarget === n;
      const J = Object.keys(O);
      for (const A of J) {
        let T = (
          /** @type {import('../index.js').SkeletonNode | null} */
          null
        );
        if (l?.childrenTrees?.length === 1)
          T = i.skeletonNodes[i.skeletonTrees[l?.childrenTrees[0]]?.root];
        else
          for (let E = 0; E < m.indexed.length; E++) {
            const x = m.indexed[E], $ = l?.childrenTrees?.[E];
            if (!$) throw new Error(`missing skeleton tree for pattern ${x}`);
            A.match(Au(x)) && (T = i.skeletonNodes[i.skeletonTrees[$]?.root]);
          }
        if (T) {
          const E = `${n}/${A}`;
          Z && (e.autofocusTarget = E);
          const x = O[A], $ = Vn(
            e,
            m.listEditMode === "inline-single" && e.activatedItems[n] === A ? k : U,
            i,
            A,
            E,
            n,
            `${s}/${A}`,
            s,
            T,
            null,
            p,
            x,
            { parent: f, data: O },
            v,
            g?.children?.find((V) => V.key === A)
          );
          ($.autofocus || $.autofocusChild !== void 0) && (Z = !1), P.push($), $.data !== x && (S = $m(
            S ?? {},
            s,
            $,
            l.children?.map((V) => i.skeletonNodes[V])
          ));
        }
      }
    } else {
      const O = (
        /** @type {unknown[]} */
        S ?? []
      ), U = (
        /** @type {import('../index.js').SkeletonNode} */
        l?.childrenTrees?.[0] && i.skeletonNodes[i.skeletonTrees[l?.childrenTrees?.[0]]?.root]
      ), Z = m.listEditMode === "inline" ? k : _m(k);
      P = [];
      let J = e.autofocusTarget === n;
      for (let A = 0; A < O.length; A++) {
        const T = O[A], E = `${n}/${A}`;
        J && (e.autofocusTarget = E);
        const x = Vn(
          e,
          m.listEditMode === "inline-single" && e.activatedItems[n] === A ? k : Z,
          i,
          A,
          E,
          n,
          `${s}/${A}`,
          s,
          U,
          null,
          p,
          T,
          { parent: f, data: O },
          v,
          g?.children?.[A]
        );
        (x.autofocus || x.autofocusChild !== void 0) && (J = !1), P.push(x);
      }
      if (e.activatedItems[n] !== void 0 && (m.listEditMode === "menu" || m.listEditMode === "dialog")) {
        const A = (
          /** @type {number} */
          e.activatedItems[n]
        ), T = Vn(
          e,
          k,
          i,
          A,
          `${n}/${A}`,
          n,
          `${s}/${A}`,
          s,
          U,
          null,
          new $s(m.listEditMode === "menu" ? k.listMenuWidth : k.listDialogWidth),
          O[A],
          { parent: f, data: O },
          v,
          g?.children?.[A]
        );
        P.push(T);
      }
    }
  let M = e.errors?.find((O) => Pm(O, l, s, o));
  if (!M && !lr(m, i.components) && m.comp !== "slot" && (M = e.errors?.findLast((O) => xn(i, O, l, s))), !M && e.rehydrate && e.rehydrateErrors && (M = e.rehydrateErrors?.findLast((O) => xn(i, O, l, s))), m.comp !== "none" && M && (y$(`${n} capture validation error on node`, M), e.errors = e.errors?.filter((O) => M !== O), !lr(m, i.components) && m.comp !== "slot" && (e.errors = e.errors?.filter((O) => !xn(i, O, l, s))), e.rehydrate && e.rehydrateErrors && (e.rehydrateErrors = e.rehydrateErrors?.filter((O) => !xn(i, O, l, s)))), !m.getConstData) {
    if (typeof P?.[0]?.key == "number" && m.comp !== "one-of-select" && !m.indexed)
      S = k$(
        /** @type {unknown[]} */
        S ?? [],
        P
      );
    else if (Array.isArray(S) && or(m, i.components)) {
      const O = l.childrenTrees?.[0] && i.skeletonTrees[l.childrenTrees?.[0]], U = O && i.skeletonNodes[O.root] || null;
      S = w$(
        /** @type {Record<string, unknown>[]} */
        S ?? [],
        s,
        e.additionalPropertiesErrors,
        U?.propertyKeys.length ? U?.propertyKeys : void 0,
        k.readOnlyPropertiesMode === "remove" ? U?.roPropertyKeys : void 0
      );
    } else typeof S == "object" && !(S instanceof File) && or(m, i.components) && (S = Ao(
      /** @type {Record<string, unknown>} */
      S ?? {},
      s,
      e.additionalPropertiesErrors,
      l?.propertyKeys.length ? l?.propertyKeys : void 0,
      k.readOnlyPropertiesMode === "remove" ? l?.roPropertyKeys : void 0
    ));
    S !== d && (Array.isArray(d) && Array.isArray(S) ? S = fs(d, S) : typeof d == "object" && typeof S == "object" && (S = q0(d, S))), !_ && as(S) && (m.nullable ? (k.defaultOn !== "missing" || S !== void 0) && (S = null) : k.defaultOn !== "missing" && (S = void 0));
  }
  const q = v.validatedForm || v.validatedChildren.includes(n) || v.initialized === !1 && k.initialValidation === "always" || v.initialized === !1 && k.initialValidation === "withData" && !as(S);
  let K;
  m.getProps && (K = qt(i.expressions, m.getProps, S, k, p, m, i.validates, e.rootData, f));
  let j;
  if (or(m, i.components)) {
    if (m.items) j = m.items;
    else if (m.getItems?.immutable && g?.itemsCacheKey) j = g.itemsCacheKey;
    else if (m.getItems && Xo(m.getItems))
      if (m.getItems.immutable && g?.itemsCacheKey)
        j = g.itemsCacheKey;
      else
        try {
          j = qt(i.expressions, m.getItems, S, k, p, m, i.validates, e.rootData, f);
        } catch {
          j = null;
        }
    else if (m.getItems && Zo(m.getItems))
      try {
        const O = qt(i.expressions, m.getItems.url, null, k, p, m, i.validates, e.rootData, f), U = h$(O, k.fetchBaseURL);
        if (m.getItems.searchParams)
          for (const [Z, J] of Object.entries(m.getItems.searchParams)) {
            let A;
            try {
              A = qt(i.expressions, J, null, k, p, m, i.validates, e.rootData, f), A && U.searchParams.set(Z, A);
            } catch {
            }
          }
        if (m.getItems.headers)
          for (const [Z, J] of Object.entries(m.getItems.headers)) {
            let A;
            try {
              A = qt(i.expressions, J, null, k, p, m, i.validates, e.rootData, f), A && U.searchParams.set("__jl__header__" + Z, A);
            } catch {
            }
          }
        j = U.href;
      } catch (O) {
        console.warn("failed to process URL for getItems", O), j = null;
      }
  }
  const H = ag(m, i.components) && !k.readOnly && !k.summary && e.autofocusTarget === n, B = m.comp === "list" && !m.indexed && j && g?.itemsCacheKey !== j;
  B ? Ql(n, "list component with getItems expression registered for fetch", j) : m.comp === "list" && j && Ql(n, "list component with unchanged getItems cache key, no fetch will be triggered", j);
  const L = g$(
    g ?? /** @type {import('./types.js').StateNode} */
    {},
    r,
    n,
    t,
    s,
    o,
    l,
    m,
    p.width,
    b,
    S,
    M?.message,
    q,
    k,
    H,
    B,
    K,
    w,
    j,
    P && fs(g?.children, P)
  );
  return h && (h[0] = L, e.cacheKeys[n] = h), B && e.getItemsDataRequests.push(L), L;
}
const C$ = gt((e, a, i) => {
  if (a.dataPath === a.parentDataPath) {
    if (Object.assign(e, i), a.data && typeof i == "object" && i !== null)
      for (const r of Object.keys(a.data))
        r in i || delete e[r];
  } else
    e[a.key] = i;
}), x$ = (e, a, i) => {
  const r = [];
  for (const n of i) {
    const t = a.find((s) => s.key === n.key);
    t ? r.push(e[a.indexOf(t)]) : r.push(n.value);
  }
  return fs(e, r);
}, xm = Jt("jl:validation"), V$ = Jt("jl:state-tree"), I$ = gt(
  (e, a, i) => {
    e.root = a, e.valid = i;
  }
);
function* zp(e) {
  if (yield e, e.children)
    for (const a of e.children)
      yield* zp(a);
}
function O$(e, a, i, r, n, t, s, o) {
  V$("createStateTree", r.root);
  const l = i.validates[r.refPointer], u = l(t);
  if (l.errors) {
    xm(`${r.root} new state tree initial validation errors`, l.errors, s);
    for (const d of l.errors)
      d.keyword !== "errorMessage" && i.localizeErrors([d]);
    if (e.errors = e.allErrors = l.errors, e.errors.length)
      for (const d of e.errors) {
        const f = d.params?.errors?.[0] ?? d;
        f?.parentSchema.__pointer && (f.schemaPath = f?.parentSchema.__pointer, f.keyword === "oneOf" && (f.schemaPath += "/oneOf"));
      }
    [!0, "error"].includes(a.removeAdditional) && (e.additionalPropertiesErrors = l.errors.filter((d) => d.keyword === "additionalProperties" || d.keyword === "unevaluatedProperties"));
  }
  e.rehydrateErrors && (e.rehydrateErrors = e.rehydrateErrors.filter((d) => e.errors?.some((f) => f.instancePath === d.instancePath && f.schemaPath === d.schemaPath && f.keyword === d.keyword))), e.rehydrate && e.rehydrateErrors?.length && xm(`${r.root} some validation errors were not captured by a leaf property, try to capture on a parent on rehydrate`, e.rehydrateErrors);
  const c = Vn(
    e,
    a,
    i,
    "",
    "",
    null,
    "",
    null,
    i.skeletonNodes[r.root],
    null,
    n,
    t,
    null,
    s,
    o?.root
  );
  e.nodes = [], e.files = [];
  for (const d of zp(c))
    e.nodes.push(d), d.data instanceof File && e.files.push({ dataPath: d.dataPath, file: d.data });
  return I$(o ?? /** @type {import('./types.js').StateTree} */
  {}, c, u);
}
function E$(e, a) {
  const i = { ...a.messages };
  return e.messages && Object.assign(i, e.messages), {
    context: {},
    width: 1e3,
    listDialogWidth: 500,
    listMenuWidth: 500,
    readOnly: !1,
    summary: !1,
    density: "default",
    indent: !1,
    titleDepth: 2,
    validateOn: "input",
    initialValidation: "withData",
    updateOn: "input",
    debounceInputMs: 300,
    defaultOn: "empty",
    removeAdditional: "error",
    autofocus: !1,
    readOnlyPropertiesMode: "show",
    fetchBaseURL: "/",
    fetchOptions: {},
    fetch: async (r, n) => (await fetch(r, n)).json(),
    onAutofocus: () => {
    },
    onUpdate: () => {
    },
    onData: () => {
    },
    noStateCache: !1,
    ...e,
    messages: i
  };
}
const Ea = (e) => !!e && e.layout.comp === "section", A$ = (e, a) => !!e && or(e.layout, a), Lt = Jt("jl:data-binding"), T$ = Jt("jl:select-items"), Ra = Jt("jl:get-items"), Ya = Jt("jl:activated-items");
class j$ {
  /**
   * @private
   * @readonly
   * @type {import('../index.js').CompiledLayout}
   */
  _compiledLayout;
  get compiledLayout() {
    return this._compiledLayout;
  }
  /**
   * @private
   * @type {StateTree}
   */
  // @ts-ignore
  _stateTree;
  get stateTree() {
    return this._stateTree;
  }
  /**
   * @readonly
   * @type {import('../index.js').SkeletonTree}
   */
  skeletonTree;
  /**
   * @private
   * @type {Display}
   */
  // @ts-ignore
  _display;
  get display() {
    return this._display;
  }
  /**
   * @private
   * @type {import('./types.js').ValidationState}
   */
  // @ts-ignore
  _validationState;
  /**
   * @returns {import('./types.js').ValidationState}
   */
  get validationState() {
    return this._validationState;
  }
  /**
   * @private
   * @param {Partial<import('./types.js').ValidationState>} validationState
   */
  set validationState(a) {
    Lt("set validationState", a), this._validationState = {
      initialized: a.initialized ?? this._validationState.initialized ?? !1,
      validatedForm: a.validatedForm ?? this._validationState.validatedForm ?? !1,
      validatedChildren: a.validatedChildren ?? this._validationState.validatedChildren ?? []
    };
  }
  /**
   * @private
   * @type {StatefulLayoutOptions}
   */
  // @ts-ignore
  _options;
  /**
   * @returns {StatefulLayoutOptions}
   */
  get options() {
    return this._options;
  }
  /**
   * @param {Partial<StatefulLayoutOptions>} options
   */
  set options(a) {
    Lt("apply main options setter", a), this.prepareOptions(a), this.updateState();
  }
  /**
   * @private
   * @type {unknown}
   */
  _data;
  get data() {
    return this._data;
  }
  set data(a) {
    Lt("apply main data setter", a), this._data = a, this.updateState();
  }
  /**
   * @private
   * @type {unknown}
   */
  _previousData;
  /**
   * @private
   * @type {boolean}
   */
  _dataWaitingForBlur = !1;
  /**
   * @private
   * @type {string | null}
   */
  _currentInput = null;
  /**
   * @private
   * @type {CreateStateTreeContext}
   */
  // @ts-ignore
  _lastCreateStateTreeContext;
  /**
   * @private
   * @type {string | null}
   */
  _autofocusTarget;
  /**
   * @private
   * @type {string | null}
   */
  _previousAutofocusTarget;
  /**
   * @type {FileRef[]}
   */
  files = [];
  /**
   * @param {import("../index.js").CompiledLayout} compiledLayout
   * @param {import("../index.js").SkeletonTree} skeletonTree
   * @param {Partial<StatefulLayoutOptions>} options
   * @param {unknown} [data]
   */
  constructor(a, i, r, n) {
    Lt("create stateful layout", a, i, r, n), this._compiledLayout = a, this.skeletonTree = i, this.prepareOptions(r), this._autofocusTarget = this.options.autofocus ? "" : null, this._previousAutofocusTarget = null, this._data = n, this._previousData = n, this.initValidationState(), this.activatedItems = {}, this.updateState(), this.handleAutofocus();
  }
  /**
   * @private
   * @param {Partial<StatefulLayoutOptions>} options
   */
  prepareOptions(a) {
    this._options = E$(a, this.compiledLayout), this._display = this._display && this._display.width === this._options.width ? this._display : new $s(this._options.width);
  }
  /**
   * @private
   */
  initValidationState() {
    const a = this.options.initialValidation === "always";
    this._validationState = {
      initialized: a,
      validatedForm: a,
      validatedChildren: []
    };
  }
  /**
   * @private
   */
  updateState() {
    this.createStateTree();
    let a = 0;
    for (; this._data !== (this._stateTree.root.data ?? null) || this._autofocusTarget !== this._lastCreateStateTreeContext.autofocusTarget || a === 0 && this._lastCreateStateTreeContext.errors?.length; ) {
      if (a += 1, a > 100)
        throw console.error("too many iterations in updateState, the data is probably not stable", this._data, this._stateTree.root.data), new Error("too many iterations in updateState, the data is probably not stable");
      Lt("hydrating state tree changed the data, do it again", this._data, this._stateTree.root.data), this._data = this._stateTree.root.data ?? null, this._autofocusTarget = this._lastCreateStateTreeContext.autofocusTarget, this.createStateTree(!0);
    }
    !this._stateTree.valid && !this._stateTree.root.error && !this._stateTree.root.childError && console.error("JSON layout failed to assign validation error to a node", this._lastCreateStateTreeContext.errors), Lt("emit update event", this._data, this._stateTree), this.options.onUpdate(this), this.emitData();
  }
  /**
   * @private
   */
  emitData() {
    !this._dataWaitingForBlur && this._data !== this._previousData && (Lt("emit data event", this._data), this.options.onData(this._data), this._previousData = this._data);
  }
  /**
   * @private
   * @param {boolean} rehydrate
   */
  createStateTree(a = !1) {
    const i = {
      activatedItems: this.activatedItems,
      autoActivatedItems: {},
      autofocusTarget: this._autofocusTarget,
      currentInput: this._currentInput,
      initial: !this._lastCreateStateTreeContext,
      rehydrate: a,
      cacheKeys: this._lastCreateStateTreeContext?.cacheKeys ?? {},
      rootData: this._data,
      files: [],
      nodes: [],
      getItemsDataRequests: [],
      rehydrateErrors: a ? this._lastCreateStateTreeContext?.errors : void 0
    };
    this._options._debugCache && (i._debugCache = this._lastCreateStateTreeContext?._debugCache ?? {}), this._stateTree = O$(
      i,
      this._options,
      this._compiledLayout,
      this.skeletonTree,
      this._display,
      this._data,
      this._validationState,
      this._stateTree
    ), this._lastCreateStateTreeContext = i, this.validationState.initialized || (this.validationState = {
      initialized: !0,
      validatedChildren: i.nodes.filter((r) => r.validated).map((r) => r.fullKey)
    }), this.files = fs(this.files, i.files);
    for (const r in i.autoActivatedItems)
      Ya("auto-activated item", r, i.autoActivatedItems[r]), this.activatedItems = gt(this.activatedItems, (n) => {
        n[r] = i.autoActivatedItems[r];
      });
    for (const r of i.getItemsDataRequests)
      Ra(r.fullKey, "automatic get items triggered"), this.getItems(r).then((n) => {
        Ra(r.fullKey, "automatic get items, fetched results", n);
        const t = (
          /** @type {any[]} */
          r.data ?? []
        ), s = t.map((l) => this.prepareSelectItem(r, l)), o = x$(t, s, n);
        Ra(r.fullKey, "automatic get items, input produced data", o), this.input(r, o);
      }, (n) => console.error("error fetching items", r.fullKey, n));
  }
  validate() {
    this.validationState.validatedForm || (this.validationState = { validatedForm: !0 }, this.updateState());
  }
  resetValidation() {
    Lt("resetValidation"), this.initValidationState(), this.updateState();
  }
  /**
   * @returns {boolean}
   */
  get valid() {
    return this.stateTree.valid;
  }
  /**
   * @returns {string[]}
   */
  get errors() {
    return this._lastCreateStateTreeContext.nodes.filter((a) => !!a.error).map((a) => (
      /** @type {string} */
      a.error
    ));
  }
  /**
   * @returns {boolean}
   */
  get hasHiddenError() {
    return this._lastCreateStateTreeContext.nodes.findIndex((a) => a.error && !a.validated) !== -1;
  }
  /**
   * @private
   * @param {StateNode} node
   * @returns {import('../compile/types.js').ParentContextExpression | null}
   */
  getParentContextExpression(a) {
    const i = this._lastCreateStateTreeContext.nodes.find((r) => r.fullKey === a.parentFullKey);
    return i ? {
      parent: this.getParentContextExpression(i),
      data: i.data
    } : null;
  }
  /**
   * @param {StateNode} node
   * @param {import('@json-layout/vocabulary').Expression} expression
   * @param {any} data
   * @returns {any}
   */
  evalNodeExpression(a, i, r) {
    return qt(this.compiledLayout.expressions, i, r, a.options, new $s(a.width), a.layout, this.compiledLayout.validates, this._data, this.getParentContextExpression(a));
  }
  /**
   * @private
   * @param {StateNode} node
   * @param {unknown} data
   * @param {boolean} [validated]
   * @param {number} [activateKey]
   */
  applyInput(a, i, r, n) {
    Lt("apply input event from node", a, i);
    const t = a.layout.transformData && this.evalNodeExpression(a, a.layout.transformData, i);
    if (this.compiledLayout.components[a.layout.comp]?.isFileInput) {
      if (t)
        i.toJSON = () => t;
      else if (i instanceof File) {
        const l = { name: i.name, size: i.size, type: i.type };
        i.toJSON = () => l;
      } else if (Array.isArray(i))
        for (const l of i) {
          const u = { name: l.name, size: l.size, type: l.type };
          l.toJSON = () => u;
        }
    } else t && (i = t);
    if (r && !this.validationState.validatedChildren.includes(a.fullKey) && (this.validationState = { validatedChildren: this.validationState.validatedChildren.concat([a.fullKey]) }), n !== void 0 && (Ya(a.fullKey, "activated item on input", n), this.activatedItems = gt(this.activatedItems, (l) => {
      l[a.fullKey] = n;
    }), this._autofocusTarget = a.fullKey + "/" + n), a.parentFullKey === null) {
      Lt("update root state after input"), this._data = i, this.updateState();
      return;
    }
    const s = this._lastCreateStateTreeContext.nodes.find((l) => l.fullKey === a.parentFullKey);
    if (!s) throw new Error(`parent with key "${a.parentFullKey}" not found`);
    const o = C$(
      // WARN: this manner of creating empty object or array based on the type of the child key does not seem very safe
      // can we find a better way to discriminate ? maybe store an extra info on the the skeleton, like "emptyData" ?
      s.data ?? (typeof a.key == "number" && s.key !== "$oneOf" ? [] : {}),
      a,
      i ?? (a.skeleton.nullable ? null : void 0)
    );
    this.applyInput(s, o, r), n !== void 0 && this.handleAutofocus();
  }
  /**
   * @private
   * @type {null | [StateNode, unknown, boolean, number | undefined, ReturnType<typeof setTimeout>]}
   */
  debouncedInput = null;
  applyDebouncedInput() {
    this.debouncedInput && (clearTimeout(this.debouncedInput[4]), this.applyInput(this.debouncedInput[0], this.debouncedInput[1], this.debouncedInput[2], this.debouncedInput[3]), this.debouncedInput = null);
  }
  /**
   * @param {StateNode} node
   * @param {unknown} data
   * @param {number} [activateKey]
   */
  input(a, i, r) {
    Lt("received input event from node", a, i, r), a.layout.comp === "list" && this.deactivateItem(a, !0), this.debouncedInput && (this.debouncedInput[0] === a ? clearTimeout(this.debouncedInput[4]) : this.applyDebouncedInput());
    const n = this.compiledLayout.components[a.layout.comp]?.emitsBlur;
    n && (this._currentInput = a.fullKey), a.options.updateOn === "blur" && n && (this._dataWaitingForBlur = !0);
    const t = a.options.validateOn === "input" || a.options.validateOn === "blur" && !n;
    this.compiledLayout.components[a.layout.comp]?.shouldDebounce && a.options.debounceInputMs ? this.debouncedInput = [a, i, t, r, setTimeout(() => this.applyDebouncedInput(), a.options.debounceInputMs)] : this.applyInput(a, i, t, r);
  }
  /**
   * @param {StateNode} node
   */
  blur(a) {
    this._currentInput === a.fullKey && (this._currentInput = null), this.debouncedInput ? this.applyDebouncedInput() : a.layout.getDefaultData && qp(a.data, a.layout, a.options) && this.applyInput(a, a.data, !0), Lt("received blur event from node", a), (a.options.validateOn === "input" || a.options.validateOn === "blur") && !this.validationState.validatedChildren.includes(a.fullKey) && (this.validationState = { validatedChildren: this.validationState.validatedChildren.concat([a.fullKey]) }, this.updateState()), this._dataWaitingForBlur && (this._dataWaitingForBlur = !1, this.emitData());
  }
  /**
   * @param {StateNode} node
   */
  validateNodeRecurse(a) {
    if (this.validationState = { validatedChildren: this.validationState.validatedChildren.concat([a.fullKey]) }, a.children)
      for (const i of a.children)
        this.validateNodeRecurse(i);
    this.updateState();
  }
  /**
   * @private
   * @type {Record<string, {key: any, appliedQ: boolean, items: import('@json-layout/vocabulary').SelectItems}>}
   */
  _itemsCache = {};
  /**
   * @private
   * @param {StateNode} node
   * @param {string} q
   * @returns {Promise<{appliedQ: boolean, items: import('@json-layout/vocabulary').SelectItems}>}
   */
  async getItemsWithoutCache(a, i = "") {
    if (!A$(a, this._compiledLayout.components))
      throw new Error("node is not a component with an items list");
    if (a.itemsCacheKey === null) return { appliedQ: !1, items: [] };
    let r = !1, n;
    if ((a.layout.items || a.layout.getItems && Xo(a.layout.getItems)) && (n = a.itemsCacheKey, Ra(a.fullKey, "raw items from context or schema or getItems expression", n)), a.layout.getItems && Zo(a.layout.getItems)) {
      Ra(a.fullKey, "will fetch raw items from URL", a.itemsCacheKey);
      const s = new URL(a.itemsCacheKey);
      let o = null;
      for (const [c, d] of [...s.searchParams.entries()])
        c.startsWith("__jl__header__") && (o = o ?? {}, o[c.replace("__jl__header__", "")] = d, s.searchParams.delete(c));
      let l = a.layout.getItems.qSearchParam;
      if (!l)
        for (const c of s.searchParams.entries())
          c[1].includes("{q}") && (l = c[0]);
      l && (Ra(a.fullKey, "apply search params", l), r = !0, i ? s.searchParams.set(l, s.searchParams.get(l)?.replace("{q}", i) ?? i) : s.searchParams.delete(l));
      let u = typeof a.options.fetchOptions == "function" ? a.options.fetchOptions(s) : a.options.fetchOptions;
      o && (u = { ...u, headers: o }), n = await a.options.fetch(s.href, u), Ra(a.fullKey, "raw items fetched from URL", n);
    }
    if (!n)
      throw new Error(`node ${a.fullKey} is missing items or getItems parameters`);
    if (a.layout.getItems?.itemsResults && (n = this.evalNodeExpression(a, a.layout.getItems.itemsResults, n), Ra(a.fullKey, "items passed through the getItems.itemsResults expression", n)), !Array.isArray(n)) throw new Error(`getItems didn't return an array for node ${a.fullKey}, you can define itemsResults to extract the array`);
    const t = n.map((s) => this.prepareSelectItem(a, s));
    return { appliedQ: r, items: t };
  }
  /**
   * @param {StateNode} node
   * @param {string} q
   * @returns {Promise<import('@json-layout/vocabulary').SelectItems>}
   */
  async getItems(a, i = "") {
    let r;
    return this._itemsCache[a.fullKey] && this._itemsCache[a.fullKey].key === a.itemsCacheKey && (!i || !this._itemsCache[a.fullKey].appliedQ) ? r = this._itemsCache[a.fullKey] : (r = await this.getItemsWithoutCache(a, i), (!i || !r.appliedQ) && (this._itemsCache[a.fullKey] = { key: a.itemsCacheKey, ...r })), i && !r.appliedQ ? r.items.filter((n) => n.title.toLowerCase().includes(i.toLowerCase())) : r.items;
  }
  /**
   * @param {StateNode} node
   * @param {any} rawItem
   * @returns {import('@json-layout/vocabulary').SelectItem}
   */
  prepareSelectItem(a, i) {
    const r = {}, n = a.layout;
    return typeof i == "object" ? (r.header = n.getItems?.itemHeader ? this.evalNodeExpression(a, n.getItems.itemHeader, i) : i.header, r.header === !0 ? r.title = n.getItems?.itemTitle ? this.evalNodeExpression(a, n.getItems.itemTitle, i) : i.title : (delete r.header, r.value = n.getItems?.itemValue ? this.evalNodeExpression(a, n.getItems.itemValue, i) : n.getItems?.returnObjects ? i : i.value, r.key = n.getItems?.itemKey ? this.evalNodeExpression(a, n.getItems.itemKey, i) : i.key, r.title = n.getItems?.itemTitle ? this.evalNodeExpression(a, n.getItems.itemTitle, i) : i.title, r.value = r.value ?? r.key, r.key = r.key ?? r.value + "", r.title = r.title ?? r.key), !r.icon && i.icon && (r.icon = i.icon)) : (r.value = n.getItems?.itemValue ? this.evalNodeExpression(a, n.getItems.itemValue, i) : i, r.key = n.getItems?.itemKey ? this.evalNodeExpression(a, n.getItems.itemKey, i) : r.value, r.title = n.getItems?.itemTitle ? this.evalNodeExpression(a, n.getItems.itemTitle, i) : r.value), n.getItems?.itemIcon && (r.icon = this.evalNodeExpression(a, n.getItems?.itemIcon, i)), T$("select item after applying itemValue/itemKey/itemTitle/itemIcon expressions", a.fullKey, r), /** @type {import('@json-layout/vocabulary').SelectItem} */
    r;
  }
  /**
   * @type {Record<string, number | string>}
   */
  activatedItems;
  /**
   * @param {StateNode} node
   * @param {number | string} key
   */
  activateItem(a, i) {
    if (Ya(a.fullKey, "activate item explicitly", i), this.activatedItems = gt(this.activatedItems, (r) => {
      r[a.fullKey] = i;
    }), this._autofocusTarget = a.fullKey + "/" + i, a.key === "$oneOf")
      if (a.layout.emptyData && a.data && typeof a.data == "object" && a.children?.[0]) {
        const r = this._lastCreateStateTreeContext.nodes.find((t) => t.fullKey === a.parentFullKey);
        if (!r) throw new Error(`parent with key "${a.parentFullKey}" not found`);
        if (!r.data || typeof r.data != "object") throw new Error(`parent with key "${a.parentFullKey}" is missing data object`);
        const n = { ...r.data };
        Ya(a.fullKey, "remove properties of previous oneOf activated item", a.children?.[0].fullKey);
        for (const t of a.children?.[0].skeleton.propertyKeys)
          delete n[t];
        this.input(r, n);
      } else
        this.input(a, void 0);
    else
      this.updateState();
    this.handleAutofocus();
  }
  /**
   * @param {string} fullKey
   */
  focusNode(a) {
    Ya(a, "focus node explicitly"), this._autofocusTarget = a, this.updateState(), this.handleAutofocus();
  }
  /**
   * @param {StateNode} node
   * @param {boolean} skipUpdateState
   */
  deactivateItem(a, i = !1) {
    Ya(a.fullKey, "deactivate item explicitly"), this.activatedItems = gt(this.activatedItems, (r) => {
      for (const n in r)
        n.startsWith(a.fullKey) && (Ya(a.fullKey, "item deactivation deletes a key", n), delete r[n]);
    }), i || this.updateState();
  }
  handleAutofocus() {
    const a = this._autofocusTarget;
    a !== null && this._autofocusTarget !== this._previousAutofocusTarget && (this._previousAutofocusTarget = a, setTimeout(() => {
      Lt("emit autofocus event", a), this.options.onAutofocus(a);
    }));
  }
}
function D$(e) {
  return dy() ? (st(e), !0) : !1;
}
const M$ = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
function R$(e) {
  return xs();
}
function N$(e) {
  return Array.isArray(e) ? e : [e];
}
function L$(e, a = !0, i) {
  R$() ? ua(e, i) : a ? e() : Ee(e);
}
const Bp = M$ ? window : void 0;
function In(e) {
  var a;
  const i = ot(e);
  return (a = i?.$el) != null ? a : i;
}
function q$() {
  const e = fe(!1), a = xs();
  return a && ua(() => {
    e.value = !0;
  }, a), e;
}
function z$(e) {
  const a = q$();
  return I(() => (a.value, !!e()));
}
function B$(e, a, i = {}) {
  const { window: r = Bp, ...n } = i;
  let t;
  const s = z$(() => r && "ResizeObserver" in r), o = () => {
    t && (t.disconnect(), t = void 0);
  }, l = I(() => {
    const d = ot(e);
    return Array.isArray(d) ? d.map((f) => In(f)) : [In(d)];
  }), u = ce(
    l,
    (d) => {
      if (o(), s.value && r) {
        t = new ResizeObserver(a);
        for (const f of d)
          f && t.observe(f, n);
      }
    },
    { immediate: !0, flush: "post" }
  ), c = () => {
    o(), u();
  };
  return D$(c), {
    isSupported: s,
    stop: c
  };
}
function F$(e, a = { width: 0, height: 0 }, i = {}) {
  const { window: r = Bp, box: n = "content-box" } = i, t = I(() => {
    var d, f;
    return (f = (d = In(e)) == null ? void 0 : d.namespaceURI) == null ? void 0 : f.includes("svg");
  }), s = fe(a.width), o = fe(a.height), { stop: l } = B$(
    e,
    ([d]) => {
      const f = n === "border-box" ? d.borderBoxSize : n === "content-box" ? d.contentBoxSize : d.devicePixelContentBoxSize;
      if (r && t.value) {
        const v = In(e);
        if (v) {
          const g = v.getBoundingClientRect();
          s.value = g.width, o.value = g.height;
        }
      } else if (f) {
        const v = N$(f);
        s.value = v.reduce((g, { inlineSize: h }) => g + h, 0), o.value = v.reduce((g, { blockSize: h }) => g + h, 0);
      } else
        s.value = d.contentRect.width, o.value = d.contentRect.height;
    },
    i
  );
  L$(() => {
    const d = In(e);
    d && (s.value = "offsetWidth" in d ? d.offsetWidth : a.width, o.value = "offsetHeight" in d ? d.offsetHeight : a.height);
  });
  const u = ce(
    () => In(e),
    (d) => {
      s.value = d ? a.width : 0, o.value = d ? a.height : 0;
    }
  );
  function c() {
    l(), u();
  }
  return {
    width: s,
    height: o,
    stop: c
  };
}
const K$ = {
  // as much as possible with use standard vuetify aliases https://vuetifyjs.com/en/features/icon-fonts/#built-in-aliases
  add: "$plus",
  calendar: "$calendar",
  close: "$close",
  edit: "$edit",
  sortDown: "$sortDesc",
  sortUp: "$sortAsc",
  // codes are copied from here https://raw.githubusercontent.com/Templarian/MaterialDesign-JS/refs/heads/master/mdi.js
  copy: "svg:M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z",
  paste: "svg:M19,20H5V4H7V7H17V4H19M12,2A1,1 0 0,1 13,3A1,1 0 0,1 12,4A1,1 0 0,1 11,3A1,1 0 0,1 12,2M19,2H14.82C14.4,0.84 13.3,0 12,0C10.7,0 9.6,0.84 9.18,2H5A2,2 0 0,0 3,4V20A2,2 0 0,0 5,22H19A2,2 0 0,0 21,20V4A2,2 0 0,0 19,2Z",
  alert: "svg:M13 14H11V9H13M13 18H11V16H13M1 21H23L12 2L1 21Z",
  clock: "svg:M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M16.2,16.2L11,13V7H12.5V12.2L17,14.9L16.2,16.2Z",
  delete: "svg:M19,4H15.5L14.5,3H9.5L8.5,4H5V6H19M6,19A2,2 0 0,0 8,21H16A2,2 0 0,0 18,19V7H6V19Z",
  duplicate: "svg:M11,17H4A2,2 0 0,1 2,15V3A2,2 0 0,1 4,1H16V3H4V15H11V13L15,16L11,19V17M19,21V7H8V13H6V7A2,2 0 0,1 8,5H19A2,2 0 0,1 21,7V21A2,2 0 0,1 19,23H8A2,2 0 0,1 6,21V19H8V21H19Z",
  infoSymbol: "svg:M11 9H13V7H11V9M11 17H13V11H11V17Z",
  menu: "svg:M12,16A2,2 0 0,1 14,18A2,2 0 0,1 12,20A2,2 0 0,1 10,18A2,2 0 0,1 12,16M12,10A2,2 0 0,1 14,12A2,2 0 0,1 12,14A2,2 0 0,1 10,12A2,2 0 0,1 12,10M12,4A2,2 0 0,1 14,6A2,2 0 0,1 12,8A2,2 0 0,1 10,6A2,2 0 0,1 12,4Z",
  sort: "svg:M17.45,17.55L12,23L6.55,17.55L7.96,16.14L11,19.17V4.83L7.96,7.86L6.55,6.45L12,1L17.45,6.45L16.04,7.86L13,4.83V19.17L16.04,16.14L17.45,17.55Z"
}, H$ = {
  nodeComponents: {},
  plugins: [],
  pluginsOptions: {},
  confirmDeleteItem: !0
}, U$ = (e, a, i, r, n, t, s, o, l, u) => {
  const c = { ...e?.components }, d = { ...s, ...e?.nodeComponents };
  if (e?.plugins)
    for (const g of e.plugins)
      c[g.info.name] = g.info, d[g.info.name] = g.nodeComponent;
  const f = { ...K$, ...e?.icons };
  return {
    ...H$,
    readOnly: !!(a && (a.isDisabled.value || a.isReadonly.value)),
    density: (
      /** @type {import("./types.js").VjsfOptions['density']} */
      n?.density
    ),
    locale: r,
    ...e,
    onData: o,
    onUpdate: l,
    onAutofocus: u,
    context: e?.context ? JSON.parse(JSON.stringify(e.context)) : {},
    width: Math.round(i ?? 0),
    vjsfSlots: { ...t },
    components: c,
    nodeComponents: d,
    icons: f
  };
}, To = /* @__PURE__ */ Symbol.for("vjsf:clipboard"), W$ = () => {
  if (qe(To, null)) return;
  ht(To, {});
};
function G$(e) {
  const a = qe(To);
  if (!a) throw new Error("useClipboard called without prior createClipboard");
  return I({
    get() {
      const i = e();
      return a[i] = a[i] ?? ie(null), a[i].value;
    },
    set(i) {
      const r = e();
      a[r] = a[r] ?? ie(null), a[r].value = i;
    }
  });
}
const Vt = Jt("vjsf:use-vjsf");
D0(!1);
const Y$ = {
  /**
   * @arg {any} data
  */
  "update:modelValue": (e) => !0,
  /**
   * @arg {import('../types.js').VjsfStatefulLayout} state
  */
  "update:state": (e) => !0
}, X$ = (e, a, i, r, n, t, s, o) => {
  const l = ie(null);
  W$(), Ge({}, "Vjsf");
  const u = qe(/* @__PURE__ */ Symbol.for("vuetify:defaults"))?.value;
  Vt("provided defaults", u);
  const { width: c } = F$(l), d = fe(null), f = fe(null), v = qe(/* @__PURE__ */ Symbol.for("vuetify:form"), null), g = `vjsf-${Math.random().toString(36).substring(2, 9)}`;
  v ? v.register({
    id: g,
    validate: () => (d.value?.validate(), d.value?.errors || []),
    reset: () => d.value?.resetValidation(),
    // TODO: also empty the data ?
    resetValidation: () => d.value?.resetValidation(),
    vm: xs()
  }) : console.warn("Vjsf should be wrapped in VForm");
  const h = fy(), y = (M) => {
    Vt("onStatefulLayoutUpdate", M), M && (f.value = M.stateTree, Vt("  -> emit update:state"), n("update:state", M), v && (M.valid ? v.update(g, !0, []) : M.hasHiddenError ? v.update(g, null, []) : v.update(g, !1, [])));
  };
  let m;
  const p = async (M) => {
    Vt("onDataUpdate", M), m = M, await Ee(), m !== M ? Vt("onDataUpdate data changed while waiting for nextTick, do not emit") : (Vt("  -> emit update:modelValue", M), n("update:modelValue", M));
  }, b = () => {
    if (!l.value) return;
    const M = l.value.querySelector(".vjsf-input--autofocus");
    if (Vt("onAutofocus", M), M) {
      const q = M.querySelector("input") ?? M.querySelector('textarea:not([style*="display: none"]');
      q && q.focus();
    }
  }, w = nt(), k = I(() => U$(i.value, v, c.value, w.current.value, u?.global, h, { ...r }, p, y, b)), S = ie({});
  ce(k, (M) => {
    if (o?.value) return;
    if (!s) throw new Error("produceCompileOptions function is not available");
    const q = s(S.value, M);
    q !== S.value && (Vt("new compileOptions", q), S.value = q);
  }, { immediate: !0 });
  const _ = I(() => {
    if (o?.value) return o?.value;
    if (!t) throw new Error("compile function is not available");
    return t(e.value, S.value);
  }), P = () => {
    c.value && (d.value = /** @type {import('../types.js').VjsfStatefulLayout} */
    new j$(
      Ye(_.value),
      Ye(_.value.skeletonTrees[_.value.mainTree]),
      Ye(k.value),
      Ye(a.value)
    ));
  };
  return ce(k, (M) => {
    Vt("watch fullOptions", k), d.value ? (Vt("  -> update statefulLayout options"), d.value.options = Ye(M)) : (Vt("  -> init statefulLayout"), P());
  }), ce(a, (M) => {
    const q = Ye(M);
    d.value && d.value.data !== q && (Vt("modelValue changed from outside", q), Vt("  -> update statefulLayout data"), d.value.data = Ye(q));
  }), ce(_, (M) => {
    Vt("watch compiledLayout", M), Vt("  -> init statefulLayout"), P();
  }), { el: l, statefulLayout: d, stateTree: f };
}, Z$ = ["innerHTML"], Yn = {
  __name: "section-header",
  props: {
    node: {
      /** @type import('vue').PropType<import('../../types.js').VjsfNode> */
      type: Object,
      required: !0
    },
    hideTitle: {
      type: Boolean,
      default: !1
    }
  },
  setup(e) {
    const a = e, i = I(() => a.node.options.density === "compact" ? 6 : a.node.options.density === "comfortable" ? 7 : 8), r = ["text-h1", "text-h2", "text-h3", "text-h4", "text-h5", "text-h6", "text-subtitle-1", "text-subtitle-2"], n = I(() => {
      const t = a.node.options.titleDepth;
      return a.node.options.density === "compact" ? r[t + 2] : a.node.options.density === "comfortable" ? r[t + 1] : r[t];
    });
    return (t, s) => e.node.layout.title && !e.hideTitle || e.node.layout.subtitle || e.node.error && e.node.validated ? (oe(), De("div", {
      key: 0,
      class: ue(`mb-${i.value - e.node.options.titleDepth} mt-${e.hideTitle ? 0 : i.value - e.node.options.titleDepth}`)
    }, [
      e.node.layout.title && !e.hideTitle ? (oe(), ye(Wo(`h${e.node.options.titleDepth}`), {
        key: 0,
        class: ue(`${n.value}`)
      }, {
        default: le(() => [
          Fe(Ue(e.node.layout.title), 1)
        ]),
        _: 1
      }, 8, ["class"])) : Ve("", !0),
      e.node.layout.subtitle ? (oe(), De("p", {
        key: 1,
        class: ue(`text-subtitle mt-${e.hideTitle ? 0 : i.value - e.node.options.titleDepth}`),
        innerHTML: e.node.layout.subtitle
      }, null, 10, Z$)) : Ve("", !0),
      e.node.error && e.node.validated ? (oe(), ye(Y(Vp), {
        key: 2,
        type: "error",
        class: ue(`mt-${i.value - e.node.options.titleDepth}`)
      }, {
        default: le(() => [
          Fe(Ue(e.node.error), 1)
        ]),
        _: 1
      }, 8, ["class"])) : Ve("", !0)
    ], 2)) : Ve("", !0);
  }
}, J$ = {
  __name: "section",
  props: {
    modelValue: {
      /** @type import('vue').PropType<import('../../types.js').VjsfSectionNode> */
      type: Object,
      required: !0
    },
    statefulLayout: {
      /** @type import('vue').PropType<import('../../types.js').VjsfStatefulLayout> */
      type: Object,
      required: !0
    }
  },
  setup(e) {
    return Ge({}, "VjsfSection"), (a, i) => (oe(), De(pe, null, [
      C(Yn, { node: e.modelValue }, null, 8, ["node"]),
      C(Y(sa), {
        dense: e.modelValue.options?.density === "compact" || e.modelValue.options?.density === "comfortable"
      }, {
        default: le(() => [
          (oe(!0), De(pe, null, pt(e.modelValue.children, (r) => (oe(), ye(la, {
            key: r.fullKey,
            "model-value": (
              /** @type import('../../types.js').VjsfNode */
              r
            ),
            "stateful-layout": e.statefulLayout
          }, null, 8, ["model-value", "stateful-layout"]))), 128))
        ]),
        _: 1
      }, 8, ["dense"])
    ], 64));
  }
}, Q$ = ee({
  active: Boolean,
  disabled: Boolean,
  max: [Number, String],
  value: {
    type: [Number, String],
    default: 0
  },
  ...Se(),
  ...Gn({
    transition: {
      component: Ap
    }
  })
}, "VCounter"), Tu = de()({
  name: "VCounter",
  functional: !0,
  props: Q$(),
  setup(e, a) {
    let {
      slots: i
    } = a;
    const r = W(() => e.max ? `${e.value} / ${e.max}` : String(e.value));
    return me(() => C(Wt, {
      transition: e.transition
    }, {
      default: () => [Je(D("div", {
        class: ue(["v-counter", {
          "text-error": e.max && !e.disabled && parseFloat(e.value) > parseFloat(e.max)
        }, e.class]),
        style: be(e.style)
      }, [i.default ? i.default({
        counter: r.value,
        max: e.max,
        value: e.value
      }) : r.value]), [[ya, e.active]])]
    })), {};
  }
}), e1 = ee({
  text: String,
  onClick: Et(),
  ...Se(),
  ...Qe()
}, "VLabel"), qr = de()({
  name: "VLabel",
  props: e1(),
  setup(e, a) {
    let {
      slots: i
    } = a;
    return me(() => D("label", {
      class: ue(["v-label", {
        "v-label--clickable": !!e.onClick
      }, e.class]),
      style: be(e.style),
      onClick: e.onClick
    }, [e.text, i.default?.()])), {};
  }
}), t1 = ee({
  floating: Boolean,
  ...Se()
}, "VFieldLabel"), Xi = de()({
  name: "VFieldLabel",
  props: t1(),
  setup(e, a) {
    let {
      slots: i
    } = a;
    return me(() => C(qr, {
      class: ue(["v-field-label", {
        "v-field-label--floating": e.floating
      }, e.class]),
      style: be(e.style)
    }, i)), {};
  }
});
function zr(e) {
  const {
    t: a
  } = nt();
  function i(r) {
    let {
      name: n,
      color: t,
      ...s
    } = r;
    const o = {
      prepend: "prependAction",
      prependInner: "prependAction",
      append: "appendAction",
      appendInner: "appendAction",
      clear: "clear"
    }[n], l = e[`onClick:${n}`];
    function u(d) {
      d.key !== "Enter" && d.key !== " " || (d.preventDefault(), d.stopPropagation(), Ms(l, new PointerEvent("click", d)));
    }
    const c = l && o ? a(`$vuetify.input.${o}`, e.label ?? "") : void 0;
    return C(xe, re({
      icon: e[`${n}Icon`],
      "aria-label": c,
      onClick: l,
      onKeydown: u,
      color: t
    }, s), null);
  }
  return {
    InputIcon: i
  };
}
const Ws = ee({
  focused: Boolean,
  "onUpdate:focused": Et()
}, "focus");
function bn(e) {
  let a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ga();
  const i = $e(e, "focused"), r = W(() => ({
    [`${a}--focused`]: i.value
  }));
  function n() {
    i.value = !0;
  }
  function t() {
    i.value = !1;
  }
  return {
    focusClasses: r,
    isFocused: i,
    focus: n,
    blur: t
  };
}
const a1 = ["underlined", "outlined", "filled", "solo", "solo-inverted", "solo-filled", "plain"], Gs = ee({
  appendInnerIcon: Pe,
  bgColor: String,
  clearable: Boolean,
  clearIcon: {
    type: Pe,
    default: "$clear"
  },
  active: Boolean,
  centerAffix: {
    type: Boolean,
    default: void 0
  },
  color: String,
  baseColor: String,
  dirty: Boolean,
  disabled: {
    type: Boolean,
    default: null
  },
  glow: Boolean,
  error: Boolean,
  flat: Boolean,
  iconColor: [Boolean, String],
  label: String,
  persistentClear: Boolean,
  prependInnerIcon: Pe,
  reverse: Boolean,
  singleLine: Boolean,
  variant: {
    type: String,
    default: "filled",
    validator: (e) => a1.includes(e)
  },
  "onClick:clear": Et(),
  "onClick:appendInner": Et(),
  "onClick:prependInner": Et(),
  ...Se(),
  ..._u(),
  ...$t(),
  ...Qe()
}, "VField"), Dn = de()({
  name: "VField",
  inheritAttrs: !1,
  props: {
    id: String,
    details: Boolean,
    labelId: String,
    ...Ws(),
    ...Gs()
  },
  emits: {
    "update:focused": (e) => !0,
    "update:modelValue": (e) => !0
  },
  setup(e, a) {
    let {
      attrs: i,
      emit: r,
      slots: n
    } = a;
    const {
      themeClasses: t
    } = ut(e), {
      loaderClasses: s
    } = zs(e), {
      focusClasses: o,
      isFocused: l,
      focus: u,
      blur: c
    } = bn(e), {
      InputIcon: d
    } = zr(e), {
      roundedClasses: f
    } = _t(e), {
      rtlClasses: v
    } = St(), g = W(() => e.dirty || e.active), h = W(() => !!(e.label || n.label)), y = W(() => !e.singleLine && h.value), m = Xt(), p = I(() => e.id || `input-${m}`), b = W(() => e.details ? `${p.value}-messages` : void 0), w = ie(), k = ie(), S = ie(), _ = I(() => ["plain", "underlined"].includes(e.variant)), P = I(() => e.error || e.disabled ? void 0 : g.value && l.value ? e.color : e.baseColor), M = I(() => {
      if (!(!e.iconColor || e.glow && !l.value))
        return e.iconColor === !0 ? P.value : e.iconColor;
    }), {
      backgroundColorClasses: q,
      backgroundColorStyles: K
    } = at(() => e.bgColor), {
      textColorClasses: j,
      textColorStyles: H
    } = kt(P);
    ce(g, (O) => {
      if (y.value && !cn()) {
        const U = w.value.$el, Z = k.value.$el;
        requestAnimationFrame(() => {
          const J = pu(U), A = Z.getBoundingClientRect(), T = A.x - J.x, E = A.y - J.y - (J.height / 2 - A.height / 2), x = A.width / 0.75, $ = Math.abs(x - J.width) > 1 ? {
            maxWidth: he(x)
          } : void 0, V = getComputedStyle(U), F = getComputedStyle(Z), z = parseFloat(V.transitionDuration) * 1e3 || 150, X = parseFloat(F.getPropertyValue("--v-field-label-scale")), Q = F.getPropertyValue("color");
          U.style.visibility = "visible", Z.style.visibility = "hidden", _a(U, {
            transform: `translate(${T}px, ${E}px) scale(${X})`,
            color: Q,
            ...$
          }, {
            duration: z,
            easing: hr,
            direction: O ? "normal" : "reverse"
          }).finished.then(() => {
            U.style.removeProperty("visibility"), Z.style.removeProperty("visibility");
          });
        });
      }
    }, {
      flush: "post"
    });
    const B = I(() => ({
      isActive: g,
      isFocused: l,
      controlRef: S,
      iconColor: M,
      blur: c,
      focus: u
    }));
    function L(O) {
      O.target !== document.activeElement && O.preventDefault();
    }
    return me(() => {
      const O = e.variant === "outlined", U = !!(n["prepend-inner"] || e.prependInnerIcon), Z = !!(e.clearable || n.clear) && !e.disabled, J = !!(n["append-inner"] || e.appendInnerIcon || Z), A = () => n.label ? n.label({
        ...B.value,
        label: e.label,
        props: {
          for: p.value
        }
      }) : e.label;
      return D("div", re({
        class: ["v-field", {
          "v-field--active": g.value,
          "v-field--appended": J,
          "v-field--center-affix": e.centerAffix ?? !_.value,
          "v-field--disabled": e.disabled,
          "v-field--dirty": e.dirty,
          "v-field--error": e.error,
          "v-field--glow": e.glow,
          "v-field--flat": e.flat,
          "v-field--has-background": !!e.bgColor,
          "v-field--persistent-clear": e.persistentClear,
          "v-field--prepended": U,
          "v-field--reverse": e.reverse,
          "v-field--single-line": e.singleLine,
          "v-field--no-label": !A(),
          [`v-field--variant-${e.variant}`]: !0
        }, t.value, q.value, o.value, s.value, f.value, v.value, e.class],
        style: [K.value, e.style],
        onClick: L
      }, i), [D("div", {
        class: "v-field__overlay"
      }, null), C(Pu, {
        name: "v-field",
        active: !!e.loading,
        color: e.error ? "error" : typeof e.loading == "string" ? e.loading : e.color
      }, {
        default: n.loader
      }), U && D("div", {
        key: "prepend",
        class: "v-field__prepend-inner"
      }, [n["prepend-inner"] ? n["prepend-inner"](B.value) : e.prependInnerIcon && C(d, {
        key: "prepend-icon",
        name: "prependInner",
        color: M.value
      }, null)]), D("div", {
        class: "v-field__field",
        "data-no-activator": ""
      }, [["filled", "solo", "solo-inverted", "solo-filled"].includes(e.variant) && y.value && C(Xi, {
        key: "floating-label",
        ref: k,
        class: ue([j.value]),
        floating: !0,
        for: p.value,
        "aria-hidden": !g.value,
        style: be(H.value)
      }, {
        default: () => [A()]
      }), h.value && C(Xi, {
        key: "label",
        ref: w,
        id: e.labelId,
        for: p.value,
        "aria-hidden": y.value && g.value
      }, {
        default: () => [A()]
      }), n.default?.({
        ...B.value,
        props: {
          id: p.value,
          class: "v-field__input",
          "aria-describedby": b.value
        },
        focus: u,
        blur: c
      }) ?? D("div", {
        id: p.value,
        class: "v-field__input",
        "aria-describedby": b.value
      }, null)]), Z && C(Tp, {
        key: "clear"
      }, {
        default: () => [Je(D("div", {
          class: "v-field__clearable",
          onMousedown: (T) => {
            T.preventDefault(), T.stopPropagation();
          }
        }, [C(je, {
          defaults: {
            VIcon: {
              icon: e.clearIcon
            }
          }
        }, {
          default: () => [n.clear ? n.clear({
            ...B.value,
            props: {
              onFocus: u,
              onBlur: c,
              onClick: e["onClick:clear"],
              tabindex: -1
            }
          }) : C(d, {
            name: "clear",
            onFocus: u,
            onBlur: c,
            tabindex: -1
          }, null)]
        })]), [[ya, e.dirty]])]
      }), J && D("div", {
        key: "append",
        class: "v-field__append-inner"
      }, [n["append-inner"] ? n["append-inner"](B.value) : e.appendInnerIcon && C(d, {
        key: "append-icon",
        name: "appendInner",
        color: M.value
      }, null)]), D("div", {
        class: ue(["v-field__outline", j.value]),
        style: be(H.value)
      }, [O && D(pe, null, [D("div", {
        class: "v-field__outline__start"
      }, null), y.value && D("div", {
        class: "v-field__outline__notch"
      }, [C(Xi, {
        ref: k,
        floating: !0,
        for: p.value,
        "aria-hidden": !g.value
      }, {
        default: () => [A()]
      })]), D("div", {
        class: "v-field__outline__end"
      }, null)]), _.value && y.value && C(Xi, {
        ref: k,
        floating: !0,
        for: p.value,
        "aria-hidden": !g.value
      }, {
        default: () => [A()]
      })])]);
    }), {
      controlRef: S,
      fieldIconColor: M
    };
  }
}), n1 = ee({
  active: Boolean,
  color: String,
  messages: {
    type: [Array, String],
    default: () => []
  },
  ...Se(),
  ...Gn({
    transition: {
      component: Ap,
      leaveAbsolute: !0,
      group: !0
    }
  })
}, "VMessages"), r1 = de()({
  name: "VMessages",
  props: n1(),
  setup(e, a) {
    let {
      slots: i
    } = a;
    const r = I(() => Ze(e.messages)), {
      textColorClasses: n,
      textColorStyles: t
    } = kt(() => e.color);
    return me(() => C(Wt, {
      transition: e.transition,
      tag: "div",
      class: ue(["v-messages", n.value, e.class]),
      style: be([t.value, e.style])
    }, {
      default: () => [e.active && r.value.map((s, o) => D("div", {
        class: "v-messages__message",
        key: `${o}-${r.value}`
      }, [i.message ? i.message({
        message: s
      }) : s]))]
    })), {};
  }
}), Fp = /* @__PURE__ */ Symbol.for("vuetify:form"), i1 = ee({
  disabled: Boolean,
  fastFail: Boolean,
  readonly: Boolean,
  modelValue: {
    type: Boolean,
    default: null
  },
  validateOn: {
    type: String,
    default: "input"
  }
}, "form");
function s1(e) {
  const a = $e(e, "modelValue"), i = W(() => e.disabled), r = W(() => e.readonly), n = fe(!1), t = ie([]), s = ie([]);
  async function o() {
    const c = [];
    let d = !0;
    s.value = [], n.value = !0;
    for (const f of t.value) {
      const v = await f.validate();
      if (v.length > 0 && (d = !1, c.push({
        id: f.id,
        errorMessages: v
      })), !d && e.fastFail) break;
    }
    return s.value = c, n.value = !1, {
      valid: d,
      errors: s.value
    };
  }
  function l() {
    t.value.forEach((c) => c.reset());
  }
  function u() {
    t.value.forEach((c) => c.resetValidation());
  }
  return ce(t, () => {
    let c = 0, d = 0;
    const f = [];
    for (const v of t.value)
      v.isValid === !1 ? (d++, f.push({
        id: v.id,
        errorMessages: v.errorMessages
      })) : v.isValid === !0 && c++;
    s.value = f, a.value = d > 0 ? !1 : c === t.value.length ? !0 : null;
  }, {
    deep: !0,
    flush: "post"
  }), ht(Fp, {
    register: (c) => {
      let {
        id: d,
        vm: f,
        validate: v,
        reset: g,
        resetValidation: h
      } = c;
      t.value.some((y) => y.id === d) && Oa(`Duplicate input name "${d}"`), t.value.push({
        id: d,
        validate: v,
        reset: g,
        resetValidation: h,
        vm: my(f),
        isValid: null,
        errorMessages: []
      });
    },
    unregister: (c) => {
      t.value = t.value.filter((d) => d.id !== c);
    },
    update: (c, d, f) => {
      const v = t.value.find((g) => g.id === c);
      v && (v.isValid = d, v.errorMessages = f);
    },
    isDisabled: i,
    isReadonly: r,
    isValidating: n,
    isValid: a,
    items: t,
    validateOn: W(() => e.validateOn)
  }), {
    errors: s,
    isDisabled: i,
    isReadonly: r,
    isValidating: n,
    isValid: a,
    items: t,
    validate: o,
    reset: l,
    resetValidation: u
  };
}
function Xn(e) {
  const a = qe(Fp, null);
  return {
    ...a,
    isReadonly: I(() => !!(e?.readonly ?? a?.isReadonly.value)),
    isDisabled: I(() => !!(e?.disabled ?? a?.isDisabled.value))
  };
}
const l1 = /* @__PURE__ */ Symbol.for("vuetify:rules");
function o1(e) {
  const a = qe(l1, null);
  if (!e) {
    if (!a)
      throw new Error("Could not find Vuetify rules injection");
    return a.aliases;
  }
  return a?.resolve(e) ?? W(e);
}
const u1 = ee({
  disabled: {
    type: Boolean,
    default: null
  },
  error: Boolean,
  errorMessages: {
    type: [Array, String],
    default: () => []
  },
  maxErrors: {
    type: [Number, String],
    default: 1
  },
  name: String,
  label: String,
  readonly: {
    type: Boolean,
    default: null
  },
  rules: {
    type: Array,
    default: () => []
  },
  modelValue: null,
  validateOn: String,
  validationValue: null,
  ...Ws()
}, "validation");
function c1(e) {
  let a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ga(), i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Xt();
  const r = $e(e, "modelValue"), n = I(() => e.validationValue === void 0 ? r.value : e.validationValue), t = Xn(e), s = o1(() => e.rules), o = ie([]), l = fe(!0), u = I(() => !!(Ze(r.value === "" ? null : r.value).length || Ze(n.value === "" ? null : n.value).length)), c = I(() => e.errorMessages?.length ? Ze(e.errorMessages).concat(o.value).slice(0, Math.max(0, Number(e.maxErrors))) : o.value), d = I(() => {
    let w = (e.validateOn ?? t.validateOn?.value) || "input";
    w === "lazy" && (w = "input lazy"), w === "eager" && (w = "input eager");
    const k = new Set(w?.split(" ") ?? []);
    return {
      input: k.has("input"),
      blur: k.has("blur") || k.has("input") || k.has("invalid-input"),
      invalidInput: k.has("invalid-input"),
      lazy: k.has("lazy"),
      eager: k.has("eager")
    };
  }), f = I(() => e.error || e.errorMessages?.length ? !1 : e.rules.length ? l.value ? o.value.length || d.value.lazy ? null : !0 : !o.value.length : !0), v = fe(!1), g = I(() => ({
    [`${a}--error`]: f.value === !1,
    [`${a}--dirty`]: u.value,
    [`${a}--disabled`]: t.isDisabled.value,
    [`${a}--readonly`]: t.isReadonly.value
  })), h = ft("validation"), y = I(() => e.name ?? Y(i));
  Cr(() => {
    t.register?.({
      id: y.value,
      vm: h,
      validate: b,
      reset: m,
      resetValidation: p
    });
  }), ha(() => {
    t.unregister?.(y.value);
  }), ua(async () => {
    d.value.lazy || await b(!d.value.eager), t.update?.(y.value, f.value, c.value);
  }), Na(() => d.value.input || d.value.invalidInput && f.value === !1, () => {
    ce(n, () => {
      if (n.value != null)
        b();
      else if (e.focused) {
        const w = ce(() => e.focused, (k) => {
          k || b(), w();
        });
      }
    });
  }), Na(() => d.value.blur, () => {
    ce(() => e.focused, (w) => {
      w || b();
    });
  }), ce([f, c], () => {
    t.update?.(y.value, f.value, c.value);
  });
  async function m() {
    r.value = null, await Ee(), await p();
  }
  async function p() {
    l.value = !0, d.value.lazy ? o.value = [] : await b(!d.value.eager);
  }
  async function b() {
    let w = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1;
    const k = [];
    v.value = !0;
    for (const S of s.value) {
      if (k.length >= Number(e.maxErrors ?? 1))
        break;
      const P = await (typeof S == "function" ? S : () => S)(n.value);
      if (P !== !0) {
        if (P !== !1 && typeof P != "string") {
          console.warn(`${P} is not a valid value. Rule functions must return boolean true or a string.`);
          continue;
        }
        k.push(P || "");
      }
    }
    return o.value = k, v.value = !1, l.value = w, o.value;
  }
  return {
    errorMessages: c,
    isDirty: u,
    isDisabled: t.isDisabled,
    isReadonly: t.isReadonly,
    isPristine: l,
    isValid: f,
    isValidating: v,
    reset: m,
    resetValidation: p,
    validate: b,
    validationClasses: g
  };
}
const Ka = ee({
  id: String,
  appendIcon: Pe,
  baseColor: String,
  centerAffix: {
    type: Boolean,
    default: !0
  },
  color: String,
  glow: Boolean,
  iconColor: [Boolean, String],
  prependIcon: Pe,
  hideDetails: [Boolean, String],
  hideSpinButtons: Boolean,
  hint: String,
  persistentHint: Boolean,
  messages: {
    type: [Array, String],
    default: () => []
  },
  direction: {
    type: String,
    default: "horizontal",
    validator: (e) => ["horizontal", "vertical"].includes(e)
  },
  "onClick:prepend": Et(),
  "onClick:append": Et(),
  ...Se(),
  ...Kt(),
  ...za(Mt(), ["maxWidth", "minWidth", "width"]),
  ...Qe(),
  ...u1()
}, "VInput"), Tt = de()({
  name: "VInput",
  props: {
    ...Ka()
  },
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, a) {
    let {
      attrs: i,
      slots: r,
      emit: n
    } = a;
    const {
      densityClasses: t
    } = Qt(e), {
      dimensionStyles: s
    } = Rt(e), {
      themeClasses: o
    } = ut(e), {
      rtlClasses: l
    } = St(), {
      InputIcon: u
    } = zr(e), c = Xt(), d = I(() => e.id || `input-${c}`), {
      errorMessages: f,
      isDirty: v,
      isDisabled: g,
      isReadonly: h,
      isPristine: y,
      isValid: m,
      isValidating: p,
      reset: b,
      resetValidation: w,
      validate: k,
      validationClasses: S
    } = c1(e, "v-input", d), _ = I(() => e.errorMessages?.length || !y.value && f.value.length ? f.value : e.hint && (e.persistentHint || e.focused) ? e.hint : e.messages), P = W(() => _.value.length > 0), M = W(() => !e.hideDetails || e.hideDetails === "auto" && (P.value || !!r.details)), q = I(() => M.value ? `${d.value}-messages` : void 0), K = I(() => ({
      id: d,
      messagesId: q,
      isDirty: v,
      isDisabled: g,
      isReadonly: h,
      isPristine: y,
      isValid: m,
      isValidating: p,
      hasDetails: M,
      reset: b,
      resetValidation: w,
      validate: k
    })), j = W(() => e.error || e.disabled ? void 0 : e.focused ? e.color : e.baseColor), H = W(() => {
      if (e.iconColor)
        return e.iconColor === !0 ? j.value : e.iconColor;
    });
    return me(() => {
      const B = !!(r.prepend || e.prependIcon), L = !!(r.append || e.appendIcon);
      return D("div", {
        class: ue(["v-input", `v-input--${e.direction}`, {
          "v-input--center-affix": e.centerAffix,
          "v-input--focused": e.focused,
          "v-input--glow": e.glow,
          "v-input--hide-spin-buttons": e.hideSpinButtons
        }, t.value, o.value, l.value, S.value, e.class]),
        style: be([s.value, e.style])
      }, [B && D("div", {
        key: "prepend",
        class: "v-input__prepend"
      }, [r.prepend ? r.prepend(K.value) : e.prependIcon && C(u, {
        key: "prepend-icon",
        name: "prepend",
        color: H.value
      }, null)]), r.default && D("div", {
        class: "v-input__control"
      }, [r.default?.(K.value)]), L && D("div", {
        key: "append",
        class: "v-input__append"
      }, [r.append ? r.append(K.value) : e.appendIcon && C(u, {
        key: "append-icon",
        name: "append",
        color: H.value
      }, null)]), M.value && D("div", {
        id: q.value,
        class: "v-input__details",
        role: "alert",
        "aria-live": "polite"
      }, [C(r1, {
        active: P.value,
        messages: _.value
      }, {
        message: r.message
      }), r.details?.(K.value)])]);
    }), {
      reset: b,
      resetValidation: w,
      validate: k,
      isValid: m,
      errorMessages: f
    };
  }
}), Kp = ee({
  autocomplete: String
}, "autocomplete");
function ju(e) {
  const a = Xt(), i = fe(0), r = W(() => e.autocomplete === "suppress"), n = W(() => {
    if (e.name)
      return r.value ? `${e.name}-${a}-${i.value}` : e.name;
  }), t = W(() => r.value ? "off" : e.autocomplete);
  return {
    isSuppressing: r,
    fieldAutocomplete: t,
    fieldName: n,
    update: () => i.value = (/* @__PURE__ */ new Date()).getTime()
  };
}
function Hp(e) {
  function a(i, r) {
    if (!e.autofocus || !i) return;
    const n = r[0].target;
    (n.matches("input,textarea") ? n : n.querySelector("input,textarea"))?.focus();
  }
  return {
    onIntersect: a
  };
}
function d1(e, a) {
  if (!mu) return;
  const i = a.modifiers || {}, r = a.value, {
    handler: n,
    options: t
  } = typeof r == "object" ? r : {
    handler: r,
    options: {}
  }, s = new IntersectionObserver(function() {
    let o = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], l = arguments.length > 1 ? arguments[1] : void 0;
    const u = e._observe?.[a.instance.$.uid];
    if (!u) return;
    const c = o.some((d) => d.isIntersecting);
    n && (!i.quiet || u.init) && (!i.once || c || u.init) && n(c, o, l), c && i.once ? Up(e, a) : u.init = !0;
  }, t);
  e._observe = Object(e._observe), e._observe[a.instance.$.uid] = {
    init: !1,
    observer: s
  }, s.observe(e);
}
function Up(e, a) {
  const i = e._observe?.[a.instance.$.uid];
  i && (i.observer.unobserve(e), delete e._observe[a.instance.$.uid]);
}
const qa = {
  mounted: d1,
  unmounted: Up
}, f1 = ["color", "file", "time", "date", "datetime-local", "week", "month"], Zn = ee({
  autofocus: Boolean,
  counter: [Boolean, Number, String],
  counterValue: [Number, Function],
  prefix: String,
  placeholder: String,
  persistentPlaceholder: Boolean,
  persistentCounter: Boolean,
  suffix: String,
  role: String,
  type: {
    type: String,
    default: "text"
  },
  modelModifiers: Object,
  ...Kp(),
  ...Le(Ka(), ["direction"]),
  ...Gs()
}, "VTextField"), Dt = de()({
  name: "VTextField",
  directives: {
    vIntersect: qa
  },
  inheritAttrs: !1,
  props: Zn(),
  emits: {
    "click:control": (e) => !0,
    "mousedown:control": (e) => !0,
    "update:focused": (e) => !0,
    "update:modelValue": (e) => !0
  },
  setup(e, a) {
    let {
      attrs: i,
      emit: r,
      slots: n
    } = a;
    const t = $e(e, "modelValue"), {
      isFocused: s,
      focus: o,
      blur: l
    } = bn(e), {
      onIntersect: u
    } = Hp(e), c = I(() => typeof e.counterValue == "function" ? e.counterValue(t.value) : typeof e.counterValue == "number" ? e.counterValue : (t.value ?? "").toString().length), d = I(() => {
      if (i.maxlength) return i.maxlength;
      if (!(!e.counter || typeof e.counter != "number" && typeof e.counter != "string"))
        return e.counter;
    }), f = I(() => ["plain", "underlined"].includes(e.variant)), v = ie(), g = ie(), h = ie(), y = ju(e), m = I(() => f1.includes(e.type) || e.persistentPlaceholder || s.value || e.active);
    function p() {
      y.isSuppressing.value && y.update(), s.value || o(), Ee(() => {
        h.value !== document.activeElement && h.value?.focus();
      });
    }
    function b(_) {
      r("mousedown:control", _), _.target !== h.value && (p(), _.preventDefault());
    }
    function w(_) {
      r("click:control", _);
    }
    function k(_, P) {
      _.stopPropagation(), p(), Ee(() => {
        P(), Ms(e["onClick:clear"], _);
      });
    }
    function S(_) {
      const P = _.target;
      if (!(e.modelModifiers?.trim && ["text", "search", "password", "tel", "url"].includes(e.type))) {
        t.value = P.value;
        return;
      }
      const M = P.value, q = P.selectionStart, K = P.selectionEnd;
      t.value = M, Ee(() => {
        let j = 0;
        M.trimStart().length === P.value.length && (j = M.length - P.value.length), q != null && (P.selectionStart = q - j), K != null && (P.selectionEnd = K - j);
      });
    }
    return me(() => {
      const _ = !!(n.counter || e.counter !== !1 && e.counter != null), P = !!(_ || n.details), [M, q] = Ba(i), {
        modelValue: K,
        ...j
      } = Tt.filterProps(e), H = Dn.filterProps(e);
      return C(Tt, re({
        ref: v,
        modelValue: t.value,
        "onUpdate:modelValue": (B) => t.value = B,
        class: ["v-text-field", {
          "v-text-field--prefixed": e.prefix,
          "v-text-field--suffixed": e.suffix,
          "v-input--plain-underlined": f.value
        }, e.class],
        style: e.style
      }, M, j, {
        centerAffix: !f.value,
        focused: s.value
      }), {
        ...n,
        default: (B) => {
          let {
            id: L,
            isDisabled: O,
            isDirty: U,
            isReadonly: Z,
            isValid: J,
            hasDetails: A,
            reset: T
          } = B;
          return C(Dn, re({
            ref: g,
            onMousedown: b,
            onClick: w,
            "onClick:clear": (E) => k(E, T),
            role: e.role
          }, Le(H, ["onClick:clear"]), {
            id: L.value,
            labelId: `${L.value}-label`,
            active: m.value || U.value,
            dirty: U.value || e.dirty,
            disabled: O.value,
            focused: s.value,
            details: A.value,
            error: J.value === !1
          }), {
            ...n,
            default: (E) => {
              let {
                props: {
                  class: x,
                  ...$
                },
                controlRef: V
              } = E;
              const F = D("input", re({
                ref: (z) => h.value = V.value = z,
                value: t.value,
                onInput: S,
                autofocus: e.autofocus,
                readonly: Z.value,
                disabled: O.value,
                name: y.fieldName.value,
                autocomplete: y.fieldAutocomplete.value,
                placeholder: e.placeholder,
                size: 1,
                role: e.role,
                type: e.type,
                onFocus: o,
                onBlur: l,
                "aria-labelledby": `${L.value}-label`
              }, $, q), null);
              return D(pe, null, [e.prefix && D("span", {
                class: "v-text-field__prefix"
              }, [D("span", {
                class: "v-text-field__prefix__text"
              }, [e.prefix])]), Je(n.default ? D("div", {
                class: ue(x),
                "data-no-activator": ""
              }, [n.default({
                id: L
              }), F]) : vy(F, {
                class: x
              }), [[qa, u, null, {
                once: !0
              }]]), e.suffix && D("span", {
                class: "v-text-field__suffix"
              }, [D("span", {
                class: "v-text-field__suffix__text"
              }, [e.suffix])])]);
            }
          });
        },
        details: P ? (B) => D(pe, null, [n.details?.(B), _ && D(pe, null, [D("span", null, null), C(Tu, {
          active: e.persistentCounter || s.value,
          value: c.value,
          max: d.value,
          disabled: e.disabled
        }, n.counter)])]) : void 0
      });
    }), Pt({}, v, g, h);
  }
}), Vm = {
  fieldPropsCompact: {
    hideDetails: "auto"
  },
  fieldPropsReadOnly: { hideDetails: "auto", variant: "plain" }
};
function jo(e) {
  const a = { class: [] };
  for (const i of e)
    if (i)
      for (const r of Object.keys(i))
        r === "class" ? Array.isArray(i.class) ? a.class = a.class.concat(i.class) : a.class = [i.class] : a[Cs(r)] = i[r];
  return a;
}
function mt(e, a, i = {}) {
  i.bindData === void 0 && (i.bindData = !0), i.isMainComp === void 0 && (i.isMainComp = !0);
  const r = I(() => e.value.options), n = I(() => e.value.skeleton), t = I(() => e.value.layout), s = I(() => e.value.data), o = I(() => e.value.error), l = I(() => e.value.validated), u = I(() => e.value.props), c = I(() => e.value.autofocus), d = I(() => e.value.children), f = I(() => typeof s.value == "string" && t.value.separator ? s.value.split(
    /** @type {string} */
    t.value.separator
  ) : s.value), v = ie();
  ce(f, (m) => {
    v.value = m;
  }, { immediate: !0 });
  const g = I(() => {
    const m = [];
    r.value.density === "compact" && m.push(Vm.fieldPropsCompact), r.value.readOnly && m.push(Vm.fieldPropsReadOnly), i.isMainComp && u.value && m.push(u.value);
    const p = jo(m);
    if (p.label = t.value.label, p.hint = t.value.hint, o.value && l.value && (p.errorMessages = o.value), r.value.readOnly && (p.disabled = !0, p.class.push("vjsf-input--readonly")), c.value && p.class.push("vjsf-input--autofocus"), i.layoutPropsMap)
      for (const b of i.layoutPropsMap)
        typeof b == "string" ? b in t.value && (p[b] = t.value[b]) : b[1] in t.value && (p[b[0]] = t.value[b[1]]);
    return i.bindData && (p["onUpdate:modelValue"] = (b) => {
      const w = Array.isArray(b) && t.value.separator ? b.join(
        /** @type {string} */
        t.value.separator
      ) : b;
      return v.value = w, a.input(e.value, w);
    }), p.onBlur = () => a.blur(e.value), p;
  }), h = I(() => {
    const m = [{ density: r.value.density }];
    return i.isMainComp && m.push(t.value.props), jo(m);
  }), y = I(() => {
    if (!t.value.slots) return {};
    const m = {};
    for (const [p, b] of Object.entries(t.value.slots))
      m[p] = (w) => Oe(sr, { layoutSlot: b, node: e.value, statefulLayout: a, initialContext: w });
    return m;
  });
  return { localData: v, inputProps: g, compProps: h, compSlots: y, options: r, skeleton: n, layout: t, data: s, children: d };
}
const m1 = dt({
  props: {
    modelValue: {
      /** @type import('vue').PropType<import('../../types.js').VjsfTextFieldNode> */
      type: Object,
      required: !0
    },
    statefulLayout: {
      /** @type import('vue').PropType<import('../../types.js').VjsfStatefulLayout> */
      type: Object,
      required: !0
    }
  },
  setup(e) {
    Ge({}, "VjsfTextField");
    const { inputProps: a, localData: i, compSlots: r } = mt(
      W(e, "modelValue"),
      e.statefulLayout,
      { layoutPropsMap: ["placeholder"] }
    );
    return () => Oe(Dt, { ...a.value, modelValue: i.value }, r.value);
  }
}), v1 = ee({
  autoGrow: Boolean,
  autofocus: Boolean,
  counter: [Boolean, Number, String],
  counterValue: Function,
  prefix: String,
  placeholder: String,
  persistentPlaceholder: Boolean,
  persistentCounter: Boolean,
  noResize: Boolean,
  rows: {
    type: [Number, String],
    default: 5,
    validator: (e) => !isNaN(parseFloat(e))
  },
  maxHeight: {
    type: [Number, String],
    validator: (e) => !isNaN(parseFloat(e))
  },
  maxRows: {
    type: [Number, String],
    validator: (e) => !isNaN(parseFloat(e))
  },
  suffix: String,
  modelModifiers: Object,
  ...Kp(),
  ...Le(Ka(), ["direction"]),
  ...Gs()
}, "VTextarea"), p1 = de()({
  name: "VTextarea",
  directives: {
    vIntersect: qa
  },
  inheritAttrs: !1,
  props: v1(),
  emits: {
    "click:control": (e) => !0,
    "mousedown:control": (e) => !0,
    "update:focused": (e) => !0,
    "update:modelValue": (e) => !0,
    "update:rows": (e) => !0
  },
  setup(e, a) {
    let {
      attrs: i,
      emit: r,
      slots: n
    } = a;
    const t = $e(e, "modelValue"), {
      isFocused: s,
      focus: o,
      blur: l
    } = bn(e), {
      onIntersect: u
    } = Hp(e), c = I(() => typeof e.counterValue == "function" ? e.counterValue(t.value) : (t.value || "").toString().length), d = I(() => {
      if (i.maxlength) return i.maxlength;
      if (!(!e.counter || typeof e.counter != "number" && typeof e.counter != "string"))
        return e.counter;
    }), f = ie(), v = ie(), g = fe(""), h = ie(), y = ie(0), {
      platform: m
    } = Dr(), p = ju(e), b = I(() => e.persistentPlaceholder || s.value || e.active);
    function w() {
      p.isSuppressing.value && p.update(), h.value !== document.activeElement && h.value?.focus(), s.value || o();
    }
    function k(B) {
      w(), r("click:control", B);
    }
    function S(B) {
      r("mousedown:control", B);
    }
    function _(B) {
      B.stopPropagation(), w(), Ee(() => {
        t.value = "", Ms(e["onClick:clear"], B);
      });
    }
    function P(B) {
      const L = B.target;
      if (!e.modelModifiers?.trim) {
        t.value = L.value;
        return;
      }
      const O = L.value, U = L.selectionStart, Z = L.selectionEnd;
      t.value = O, Ee(() => {
        let J = 0;
        O.trimStart().length === L.value.length && (J = O.length - L.value.length), U != null && (L.selectionStart = U - J), Z != null && (L.selectionEnd = Z - J);
      });
    }
    const M = ie(), q = ie(Number(e.rows)), K = I(() => ["plain", "underlined"].includes(e.variant));
    wt(() => {
      e.autoGrow || (q.value = Number(e.rows));
    });
    function j() {
      Ee(() => {
        if (!h.value) return;
        if (m.value.firefox) {
          y.value = 12;
          return;
        }
        const {
          offsetWidth: B,
          clientWidth: L
        } = h.value;
        y.value = Math.max(0, B - L);
      }), e.autoGrow && Ee(() => {
        if (!M.value || !v.value) return;
        const B = getComputedStyle(M.value), L = getComputedStyle(v.value.$el), O = parseFloat(B.getPropertyValue("--v-field-padding-top")) + parseFloat(B.getPropertyValue("--v-input-padding-top")) + parseFloat(B.getPropertyValue("--v-field-padding-bottom")), U = M.value.scrollHeight, Z = parseFloat(B.lineHeight), J = Math.max(parseFloat(e.rows) * Z + O, parseFloat(L.getPropertyValue("--v-input-control-height"))), A = e.maxHeight ? parseFloat(e.maxHeight) : parseFloat(e.maxRows) * Z + O || 1 / 0, T = Xe(U ?? 0, J, A);
        q.value = Math.floor((T - O) / Z), g.value = he(T);
      });
    }
    ua(j), ce(t, j), ce(() => e.rows, j), ce(() => e.maxHeight, j), ce(() => e.maxRows, j), ce(() => e.density, j), ce(q, (B) => {
      r("update:rows", B);
    });
    let H;
    return ce(M, (B) => {
      B ? (H = new ResizeObserver(j), H.observe(M.value)) : H?.disconnect();
    }), ha(() => {
      H?.disconnect();
    }), me(() => {
      const B = !!(n.counter || e.counter || e.counterValue), L = !!(B || n.details), [O, U] = Ba(i), {
        modelValue: Z,
        ...J
      } = Tt.filterProps(e), A = {
        ...Dn.filterProps(e),
        "onClick:clear": _
      };
      return C(Tt, re({
        ref: f,
        modelValue: t.value,
        "onUpdate:modelValue": (T) => t.value = T,
        class: ["v-textarea v-text-field", {
          "v-textarea--prefixed": e.prefix,
          "v-textarea--suffixed": e.suffix,
          "v-text-field--prefixed": e.prefix,
          "v-text-field--suffixed": e.suffix,
          "v-textarea--auto-grow": e.autoGrow,
          "v-textarea--no-resize": e.noResize || e.autoGrow,
          "v-input--plain-underlined": K.value
        }, e.class],
        style: [{
          "--v-textarea-max-height": e.maxHeight ? he(e.maxHeight) : void 0,
          "--v-textarea-scroll-bar-width": he(y.value)
        }, e.style]
      }, O, J, {
        centerAffix: q.value === 1 && !K.value,
        focused: s.value
      }), {
        ...n,
        default: (T) => {
          let {
            id: E,
            isDisabled: x,
            isDirty: $,
            isReadonly: V,
            isValid: F,
            hasDetails: z
          } = T;
          return C(Dn, re({
            ref: v,
            style: {
              "--v-textarea-control-height": g.value
            },
            onClick: k,
            onMousedown: S,
            "onClick:prependInner": e["onClick:prependInner"],
            "onClick:appendInner": e["onClick:appendInner"]
          }, A, {
            id: E.value,
            active: b.value || $.value,
            labelId: `${E.value}-label`,
            centerAffix: q.value === 1 && !K.value,
            dirty: $.value || e.dirty,
            disabled: x.value,
            focused: s.value,
            details: z.value,
            error: F.value === !1
          }), {
            ...n,
            default: (X) => {
              let {
                props: {
                  class: Q,
                  ...te
                },
                controlRef: N
              } = X;
              return D(pe, null, [e.prefix && D("span", {
                class: "v-text-field__prefix"
              }, [e.prefix]), Je(D("textarea", re({
                ref: (R) => h.value = N.value = R,
                class: Q,
                value: t.value,
                onInput: P,
                autofocus: e.autofocus,
                readonly: V.value,
                disabled: x.value,
                placeholder: e.placeholder,
                rows: e.rows,
                name: p.fieldName.value,
                autocomplete: p.fieldAutocomplete.value,
                onFocus: w,
                onBlur: l,
                "aria-labelledby": `${E.value}-label`
              }, te, U), null), [[qa, {
                handler: u
              }, null, {
                once: !0
              }]]), e.autoGrow && Je(D("textarea", {
                class: ue([Q, "v-textarea__sizer"]),
                id: `${te.id}-sizer`,
                "onUpdate:modelValue": (R) => t.value = R,
                ref: M,
                readonly: !0,
                "aria-hidden": "true"
              }, null), [[py, t.value]]), e.suffix && D("span", {
                class: "v-text-field__suffix"
              }, [e.suffix])]);
            }
          });
        },
        details: L ? (T) => D(pe, null, [n.details?.(T), B && D(pe, null, [D("span", null, null), C(Tu, {
          active: e.persistentCounter || s.value,
          value: c.value,
          max: d.value,
          disabled: e.disabled
        }, n.counter)])]) : void 0
      });
    }), Pt({}, f, v, h);
  }
}), h1 = dt({
  props: {
    modelValue: {
      /** @type import('vue').PropType<import('../../types.js').VjsfTextareaNode> */
      type: Object,
      required: !0
    },
    statefulLayout: {
      /** @type import('vue').PropType<import('../../types.js').VjsfStatefulLayout> */
      type: Object,
      required: !0
    }
  },
  setup(e) {
    Ge({}, "VjsfTextArea");
    const a = ie(null), { inputProps: i, localData: r, compSlots: n, options: t } = mt(
      W(e, "modelValue"),
      e.statefulLayout,
      { layoutPropsMap: ["placeholder", "rows"] }
    ), s = I(() => t.value.readOnly && t.value.summary ? 3 : void 0), o = I(() => {
      const l = { ...i.value };
      return l.ref = a, l.rows = l.rows ?? s.value, l.modelValue = r.value, l;
    });
    return ce(() => t.value.readOnly, (l) => {
      l && a.value && (a.value.scrollTop = 0);
    }), () => Oe(p1, o.value, n.value);
  }
}), Wp = /* @__PURE__ */ Symbol.for("vuetify:selection-control-group"), Du = ee({
  color: String,
  disabled: {
    type: Boolean,
    default: null
  },
  defaultsTarget: String,
  error: Boolean,
  id: String,
  inline: Boolean,
  falseIcon: Pe,
  trueIcon: Pe,
  ripple: {
    type: [Boolean, Object],
    default: !0
  },
  multiple: {
    type: Boolean,
    default: null
  },
  name: String,
  readonly: {
    type: Boolean,
    default: null
  },
  modelValue: null,
  type: String,
  valueComparator: {
    type: Function,
    default: bt
  },
  ...Se(),
  ...Kt(),
  ...Qe()
}, "SelectionControlGroup"), y1 = ee({
  ...Du({
    defaultsTarget: "VSelectionControl"
  })
}, "VSelectionControlGroup"), g1 = de()({
  name: "VSelectionControlGroup",
  props: y1(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, a) {
    let {
      slots: i
    } = a;
    const r = $e(e, "modelValue"), n = Xt(), t = W(() => e.id || `v-selection-control-group-${n}`), s = W(() => e.name || t.value), o = /* @__PURE__ */ new Set();
    return ht(Wp, {
      modelValue: r,
      forceUpdate: () => {
        o.forEach((l) => l());
      },
      onForceUpdate: (l) => {
        o.add(l), st(() => {
          o.delete(l);
        });
      }
    }), da({
      [e.defaultsTarget]: {
        color: W(() => e.color),
        disabled: W(() => e.disabled),
        density: W(() => e.density),
        error: W(() => e.error),
        inline: W(() => e.inline),
        modelValue: r,
        multiple: W(() => !!e.multiple || e.multiple == null && Array.isArray(r.value)),
        name: s,
        falseIcon: W(() => e.falseIcon),
        trueIcon: W(() => e.trueIcon),
        readonly: W(() => e.readonly),
        ripple: W(() => e.ripple),
        type: W(() => e.type),
        valueComparator: W(() => e.valueComparator)
      }
    }), me(() => D("div", {
      class: ue(["v-selection-control-group", {
        "v-selection-control-group--inline": e.inline
      }, e.class]),
      style: be(e.style),
      role: e.type === "radio" ? "radiogroup" : void 0
    }, [i.default?.()])), {};
  }
}), Ys = ee({
  label: String,
  baseColor: String,
  trueValue: null,
  falseValue: null,
  value: null,
  ...Se(),
  ...Du()
}, "VSelectionControl");
function b1(e) {
  const a = qe(Wp, void 0), {
    densityClasses: i
  } = Qt(e), r = $e(e, "modelValue"), n = I(() => e.trueValue !== void 0 ? e.trueValue : e.value !== void 0 ? e.value : !0), t = I(() => e.falseValue !== void 0 ? e.falseValue : !1), s = I(() => !!e.multiple || e.multiple == null && Array.isArray(r.value)), o = I({
    get() {
      const v = a ? a.modelValue.value : r.value;
      return s.value ? Ze(v).some((g) => e.valueComparator(g, n.value)) : e.valueComparator(v, n.value);
    },
    set(v) {
      if (e.readonly) return;
      const g = v ? n.value : t.value;
      let h = g;
      s.value && (h = v ? [...Ze(r.value), g] : Ze(r.value).filter((y) => !e.valueComparator(y, n.value))), a ? a.modelValue.value = h : r.value = h;
    }
  }), {
    textColorClasses: l,
    textColorStyles: u
  } = kt(() => {
    if (!(e.error || e.disabled))
      return o.value ? e.color : e.baseColor;
  }), {
    backgroundColorClasses: c,
    backgroundColorStyles: d
  } = at(() => o.value && !e.error && !e.disabled ? e.color : e.baseColor), f = I(() => o.value ? e.trueIcon : e.falseIcon);
  return {
    group: a,
    densityClasses: i,
    trueValue: n,
    falseValue: t,
    model: o,
    textColorClasses: l,
    textColorStyles: u,
    backgroundColorClasses: c,
    backgroundColorStyles: d,
    icon: f
  };
}
const mn = de()({
  name: "VSelectionControl",
  directives: {
    vRipple: At
  },
  inheritAttrs: !1,
  props: Ys(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, a) {
    let {
      attrs: i,
      slots: r
    } = a;
    const {
      group: n,
      densityClasses: t,
      icon: s,
      model: o,
      textColorClasses: l,
      textColorStyles: u,
      backgroundColorClasses: c,
      backgroundColorStyles: d,
      trueValue: f
    } = b1(e), v = Xt(), g = fe(!1), h = fe(!1), y = ie(), m = W(() => e.id || `input-${v}`), p = W(() => !e.disabled && !e.readonly);
    n?.onForceUpdate(() => {
      y.value && (y.value.checked = o.value);
    });
    function b(_) {
      p.value && (g.value = !0, An(_.target, ":focus-visible") !== !1 && (h.value = !0));
    }
    function w() {
      g.value = !1, h.value = !1;
    }
    function k(_) {
      _.stopPropagation();
    }
    function S(_) {
      if (!p.value) {
        y.value && (y.value.checked = o.value);
        return;
      }
      e.readonly && n && Ee(() => n.forceUpdate()), o.value = _.target.checked;
    }
    return me(() => {
      const _ = r.label ? r.label({
        label: e.label,
        props: {
          for: m.value
        }
      }) : e.label, [P, M] = Ba(i), q = D("input", re({
        ref: y,
        checked: o.value,
        disabled: !!e.disabled,
        id: m.value,
        onBlur: w,
        onFocus: b,
        onInput: S,
        "aria-disabled": !!e.disabled,
        "aria-label": e.label,
        type: e.type,
        value: f.value,
        name: e.name,
        "aria-checked": e.type === "checkbox" ? o.value : void 0
      }, M), null);
      return D("div", re({
        class: ["v-selection-control", {
          "v-selection-control--dirty": o.value,
          "v-selection-control--disabled": e.disabled,
          "v-selection-control--error": e.error,
          "v-selection-control--focused": g.value,
          "v-selection-control--focus-visible": h.value,
          "v-selection-control--inline": e.inline
        }, t.value, e.class]
      }, P, {
        style: e.style
      }), [D("div", {
        class: ue(["v-selection-control__wrapper", l.value]),
        style: be(u.value)
      }, [r.default?.({
        backgroundColorClasses: c,
        backgroundColorStyles: d
      }), Je(D("div", {
        class: ue(["v-selection-control__input"])
      }, [r.input?.({
        model: o,
        textColorClasses: l,
        textColorStyles: u,
        backgroundColorClasses: c,
        backgroundColorStyles: d,
        inputNode: q,
        icon: s.value,
        props: {
          onFocus: b,
          onBlur: w,
          id: m.value
        }
      }) ?? D(pe, null, [s.value && C(xe, {
        key: "icon",
        icon: s.value
      }, null), q])]), [[At, !e.disabled && !e.readonly && e.ripple, null, {
        center: !0,
        circle: !0
      }]])]), _ && C(qr, {
        for: m.value,
        onClick: k
      }, {
        default: () => [_]
      })]);
    }), {
      isFocused: g,
      input: y
    };
  }
}), Gp = ee({
  indeterminate: Boolean,
  indeterminateIcon: {
    type: Pe,
    default: "$checkboxIndeterminate"
  },
  ...Ys({
    falseIcon: "$checkboxOff",
    trueIcon: "$checkboxOn"
  })
}, "VCheckboxBtn"), Mn = de()({
  name: "VCheckboxBtn",
  props: Gp(),
  emits: {
    "update:modelValue": (e) => !0,
    "update:indeterminate": (e) => !0
  },
  setup(e, a) {
    let {
      slots: i
    } = a;
    const r = $e(e, "indeterminate"), n = $e(e, "modelValue");
    function t(l) {
      r.value && (r.value = !1);
    }
    const s = W(() => r.value ? e.indeterminateIcon : e.falseIcon), o = W(() => r.value ? e.indeterminateIcon : e.trueIcon);
    return me(() => {
      const l = Le(mn.filterProps(e), ["modelValue"]);
      return C(mn, re(l, {
        modelValue: n.value,
        "onUpdate:modelValue": [(u) => n.value = u, t],
        class: ["v-checkbox-btn", e.class],
        style: e.style,
        type: "checkbox",
        falseIcon: s.value,
        trueIcon: o.value,
        "aria-checked": r.value ? "mixed" : void 0
      }), i);
    }), {};
  }
}), k1 = ee({
  ...Le(Ka(), ["direction"]),
  ...Le(Gp(), ["inline"])
}, "VCheckbox"), Yp = de()({
  name: "VCheckbox",
  inheritAttrs: !1,
  props: k1(),
  emits: {
    "update:modelValue": (e) => !0,
    "update:focused": (e) => !0
  },
  setup(e, a) {
    let {
      attrs: i,
      slots: r
    } = a;
    const n = $e(e, "modelValue"), {
      isFocused: t,
      focus: s,
      blur: o
    } = bn(e), l = ie(), u = Xt();
    return me(() => {
      const [c, d] = Ba(i), f = Tt.filterProps(e), v = Mn.filterProps(e);
      return C(Tt, re({
        ref: l,
        class: ["v-checkbox", e.class]
      }, c, f, {
        modelValue: n.value,
        "onUpdate:modelValue": (g) => n.value = g,
        id: e.id || `checkbox-${u}`,
        focused: t.value,
        style: e.style
      }), {
        ...r,
        default: (g) => {
          let {
            id: h,
            messagesId: y,
            isDisabled: m,
            isReadonly: p,
            isValid: b
          } = g;
          return C(Mn, re(v, {
            id: h.value,
            "aria-describedby": y.value,
            disabled: m.value,
            readonly: p.value
          }, d, {
            error: b.value === !1,
            modelValue: n.value,
            "onUpdate:modelValue": (w) => n.value = w,
            onFocus: s,
            onBlur: o
          }), r);
        }
      });
    }), Pt({}, l);
  }
}), w1 = dt({
  props: {
    modelValue: {
      /** @type import('vue').PropType<import('../../types.js').VjsfCheckboxNode> */
      type: Object,
      required: !0
    },
    statefulLayout: {
      /** @type import('vue').PropType<import('../../types.js').VjsfStatefulLayout> */
      type: Object,
      required: !0
    }
  },
  setup(e) {
    Ge({}, "VjsfCheckbox");
    const { inputProps: a, localData: i, compSlots: r } = mt(W(e, "modelValue"), e.statefulLayout), n = I(() => {
      const t = { ...a.value };
      return "hideDetails" in a || (t.hideDetails = "auto"), t.modelValue = i.value, t;
    });
    return () => Oe(Yp, n.value, r.value);
  }
}), S1 = ee({
  indeterminate: Boolean,
  inset: Boolean,
  flat: Boolean,
  loading: {
    type: [Boolean, String],
    default: !1
  },
  ...Ka(),
  ...Ys()
}, "VSwitch"), Xp = de()({
  name: "VSwitch",
  inheritAttrs: !1,
  props: S1(),
  emits: {
    "update:focused": (e) => !0,
    "update:modelValue": (e) => !0,
    "update:indeterminate": (e) => !0
  },
  setup(e, a) {
    let {
      attrs: i,
      slots: r
    } = a;
    const n = $e(e, "indeterminate"), t = $e(e, "modelValue"), {
      loaderClasses: s
    } = zs(e), {
      isFocused: o,
      focus: l,
      blur: u
    } = bn(e), c = ie(), d = ie(), f = Dv && window.matchMedia("(forced-colors: active)").matches, v = W(() => typeof e.loading == "string" && e.loading !== "" ? e.loading : e.color), g = Xt(), h = W(() => e.id || `switch-${g}`);
    function y() {
      n.value && (n.value = !1);
    }
    function m(p) {
      p.stopPropagation(), p.preventDefault(), c.value?.input?.click();
    }
    return me(() => {
      const [p, b] = Ba(i), w = Tt.filterProps(e), k = mn.filterProps(e);
      return C(Tt, re({
        ref: d,
        class: ["v-switch", {
          "v-switch--flat": e.flat
        }, {
          "v-switch--inset": e.inset
        }, {
          "v-switch--indeterminate": n.value
        }, s.value, e.class]
      }, p, w, {
        modelValue: t.value,
        "onUpdate:modelValue": (S) => t.value = S,
        id: h.value,
        focused: o.value,
        style: e.style
      }), {
        ...r,
        default: (S) => {
          let {
            id: _,
            messagesId: P,
            isDisabled: M,
            isReadonly: q,
            isValid: K
          } = S;
          const j = {
            model: t,
            isValid: K
          };
          return C(mn, re({
            ref: c
          }, k, {
            modelValue: t.value,
            "onUpdate:modelValue": [(H) => t.value = H, y],
            id: _.value,
            "aria-describedby": P.value,
            type: "checkbox",
            "aria-checked": n.value ? "mixed" : void 0,
            disabled: M.value,
            readonly: q.value,
            onFocus: l,
            onBlur: u
          }, b), {
            ...r,
            default: (H) => {
              let {
                backgroundColorClasses: B,
                backgroundColorStyles: L
              } = H;
              return D("div", {
                class: ue(["v-switch__track", f ? void 0 : B.value]),
                style: be(L.value),
                onClick: m
              }, [r["track-true"] && D("div", {
                key: "prepend",
                class: "v-switch__track-true"
              }, [r["track-true"](j)]), r["track-false"] && D("div", {
                key: "append",
                class: "v-switch__track-false"
              }, [r["track-false"](j)])]);
            },
            input: (H) => {
              let {
                inputNode: B,
                icon: L,
                backgroundColorClasses: O,
                backgroundColorStyles: U
              } = H;
              return D(pe, null, [B, D("div", {
                class: ue(["v-switch__thumb", {
                  "v-switch__thumb--filled": L || e.loading
                }, e.inset || f ? void 0 : O.value]),
                style: be(e.inset ? void 0 : U.value)
              }, [r.thumb ? C(je, {
                defaults: {
                  VIcon: {
                    icon: L,
                    size: "x-small"
                  }
                }
              }, {
                default: () => [r.thumb({
                  ...j,
                  icon: L
                })]
              }) : C(Ep, null, {
                default: () => [e.loading ? C(Pu, {
                  name: "v-switch",
                  active: !0,
                  color: K.value === !1 ? void 0 : v.value
                }, {
                  default: (Z) => r.loader ? r.loader(Z) : C(bp, {
                    active: Z.isActive,
                    color: Z.color,
                    indeterminate: !0,
                    size: "16",
                    width: "2"
                  }, null)
                }) : L && C(xe, {
                  key: String(L),
                  icon: L,
                  size: "x-small"
                }, null)]
              })])]);
            }
          });
        }
      });
    }), Pt({}, d);
  }
}), $1 = dt({
  props: {
    modelValue: {
      /** @type import('vue').PropType<import('../../types.js').VjsfSwitchNode> */
      type: Object,
      required: !0
    },
    statefulLayout: {
      /** @type import('vue').PropType<import('../../types.js').VjsfStatefulLayout> */
      type: Object,
      required: !0
    }
  },
  setup(e) {
    Ge({}, "VjsfSwitch");
    const { inputProps: a, localData: i, compSlots: r } = mt(W(e, "modelValue"), e.statefulLayout), n = I(() => {
      const t = { ...a.value };
      return "hideDetails" in a || (t.hideDetails = "auto"), t.modelValue = i.value, t;
    });
    return () => Oe(Xp, n.value, r.value);
  }
}), _1 = ["dotted", "dashed", "solid", "double"], P1 = ee({
  color: String,
  contentOffset: [Number, String, Array],
  gradient: Boolean,
  inset: Boolean,
  length: [Number, String],
  opacity: [Number, String],
  thickness: [Number, String],
  vertical: Boolean,
  variant: {
    type: String,
    default: "solid",
    validator: (e) => _1.includes(e)
  },
  ...Se(),
  ...Qe()
}, "VDivider"), ia = de()({
  name: "VDivider",
  props: P1(),
  setup(e, a) {
    let {
      attrs: i,
      slots: r
    } = a;
    const {
      themeClasses: n
    } = ut(e), {
      textColorClasses: t,
      textColorStyles: s
    } = kt(() => e.color), o = I(() => {
      const u = {};
      return e.length && (u[e.vertical ? "height" : "width"] = he(e.length)), e.thickness && (u[e.vertical ? "borderRightWidth" : "borderTopWidth"] = he(e.thickness)), u;
    }), l = W(() => {
      const u = Array.isArray(e.contentOffset) ? e.contentOffset[0] : e.contentOffset, c = Array.isArray(e.contentOffset) ? e.contentOffset[1] : 0;
      return {
        marginBlock: e.vertical && u ? he(u) : void 0,
        marginInline: !e.vertical && u ? he(u) : void 0,
        transform: c ? `translate${e.vertical ? "X" : "Y"}(${he(c)})` : void 0
      };
    });
    return me(() => {
      const u = D("hr", {
        class: ue([{
          "v-divider": !0,
          "v-divider--gradient": e.gradient && !r.default,
          "v-divider--inset": e.inset,
          "v-divider--vertical": e.vertical
        }, n.value, t.value, e.class]),
        style: be([o.value, s.value, {
          "--v-border-opacity": e.opacity
        }, {
          "border-style": e.variant
        }, e.style]),
        "aria-orientation": !i.role || i.role === "separator" ? e.vertical ? "vertical" : "horizontal" : void 0,
        role: `${i.role || "separator"}`
      }, null);
      return r.default ? D("div", {
        class: ue(["v-divider__wrapper", {
          "v-divider__wrapper--gradient": e.gradient,
          "v-divider__wrapper--inset": e.inset,
          "v-divider__wrapper--vertical": e.vertical
        }])
      }, [u, D("div", {
        class: "v-divider__content",
        style: be(l.value)
      }, [r.default()]), u]) : u;
    }), {};
  }
}), C1 = 50, x1 = 500;
function V1(e) {
  let {
    toggleUpDown: a
  } = e, i = -1, r = -1;
  st(t);
  function n(o) {
    t(), s(o), window.addEventListener("pointerup", t), document.addEventListener("blur", t), i = window.setTimeout(() => {
      r = window.setInterval(() => s(o), C1);
    }, x1);
  }
  function t() {
    window.clearTimeout(i), window.clearInterval(r), window.removeEventListener("pointerup", t), document.removeEventListener("blur", t);
  }
  st(t);
  function s(o) {
    a(o === "up");
  }
  return {
    holdStart: n,
    holdStop: t
  };
}
const I1 = ee({
  controlVariant: {
    type: String,
    default: "default"
  },
  inset: Boolean,
  hideInput: Boolean,
  modelValue: {
    type: Number,
    default: null
  },
  min: {
    type: Number,
    default: Number.MIN_SAFE_INTEGER
  },
  max: {
    type: Number,
    default: Number.MAX_SAFE_INTEGER
  },
  step: {
    type: Number,
    default: 1
  },
  precision: {
    type: Number,
    default: 0
  },
  minFractionDigits: {
    type: Number,
    default: null
  },
  decimalSeparator: {
    type: String,
    validator: (e) => !e || e.length === 1
  },
  ...Le(Zn(), ["modelValue", "validationValue"])
}, "VNumberInput"), O1 = de()({
  name: "VNumberInput",
  props: {
    ...I1()
  },
  emits: {
    "update:focused": (e) => !0,
    "update:modelValue": (e) => !0
  },
  setup(e, a) {
    let {
      slots: i
    } = a;
    const r = ie(), {
      holdStart: n,
      holdStop: t
    } = V1({
      toggleUpDown: K
    }), s = Xn(e), o = I(() => s.isDisabled.value || s.isReadonly.value), l = fe(e.focused), {
      decimalSeparator: u
    } = nt(), c = I(() => e.decimalSeparator?.[0] || u.value);
    function d(x) {
      let $ = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : e.precision, V = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0;
      const F = $ == null ? String(x) : x.toFixed($);
      if (l.value && V)
        return Number(F).toString().replace(".", c.value);
      if (e.minFractionDigits === null || $ !== null && $ < e.minFractionDigits)
        return F.replace(".", c.value);
      let [z, X] = F.split(".");
      return X = (X ?? "").padEnd(e.minFractionDigits, "0").replace(new RegExp(`(?<=\\d{${e.minFractionDigits}})0+$`, "g"), ""), [z, X].filter(Boolean).join(c.value);
    }
    const f = $e(e, "modelValue", null, (x) => x ?? null, (x) => x == null ? x ?? null : Xe(Number(x), e.min, e.max)), v = fe(null), g = fe(null);
    ce(f, (x) => {
      l.value && !o.value && Number(v.value?.replace(c.value, ".")) === x || (x == null ? (v.value = null, g.value = null) : isNaN(x) || (v.value = d(x), g.value = Number(v.value.replace(c.value, "."))));
    }, {
      immediate: !0
    });
    const h = I({
      get: () => v.value,
      set(x) {
        if (x === null || x === "") {
          f.value = null, v.value = null, g.value = null;
          return;
        }
        const $ = Number(x.replace(c.value, "."));
        isNaN($) || (v.value = x, g.value = $, $ <= e.max && $ >= e.min && (f.value = $));
      }
    }), y = I(() => {
      if (g.value === null) return !1;
      const x = Number(v.value?.replace(c.value, "."));
      return x !== Xe(x, e.min, e.max);
    }), m = I(() => o.value ? !1 : (f.value ?? 0) + e.step <= e.max), p = I(() => o.value ? !1 : (f.value ?? 0) - e.step >= e.min), b = I(() => e.hideInput ? "stacked" : e.controlVariant), w = W(() => b.value === "split" ? "$plus" : "$collapse"), k = W(() => b.value === "split" ? "$minus" : "$expand"), S = W(() => b.value === "split" ? "default" : "small"), _ = W(() => b.value === "stacked" ? "auto" : "100%"), P = {
      props: {
        onClick: B,
        onPointerup: L,
        onPointerdown: O,
        onPointercancel: L
      }
    }, M = {
      props: {
        onClick: B,
        onPointerup: L,
        onPointerdown: U,
        onPointercancel: L
      }
    };
    ce(() => e.precision, () => J()), ce(() => e.minFractionDigits, () => J()), ua(() => {
      Z();
    });
    function q(x) {
      if (x == null) return 0;
      const $ = x.toString(), V = $.indexOf(".");
      return ~V ? $.length - V : 0;
    }
    function K() {
      let x = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
      if (o.value) return;
      if (f.value == null) {
        h.value = d(Xe(0, e.min, e.max));
        return;
      }
      let $ = Math.max(q(f.value), q(e.step));
      e.precision != null && ($ = Math.max($, e.precision)), x ? m.value && (h.value = d(f.value + e.step, $)) : p.value && (h.value = d(f.value - e.step, $));
    }
    function j(x) {
      if (!x.data) return;
      const $ = x.target, {
        value: V,
        selectionStart: F,
        selectionEnd: z
      } = $ ?? {}, X = V ? V.slice(0, F) + x.data + V.slice(z) : x.data, Q = nw(X, e.precision, c.value);
      if (new RegExp(`^-?\\d*${hs(c.value)}?\\d*$`).test(X) || (x.preventDefault(), $.value = Q, Ee(() => h.value = Q)), e.precision != null) {
        if (X.split(c.value)[1]?.length > e.precision) {
          x.preventDefault(), $.value = Q, Ee(() => h.value = Q);
          const te = (F ?? 0) + x.data.length;
          $.setSelectionRange(te, te);
        }
        e.precision === 0 && X.endsWith(c.value) && (x.preventDefault(), $.value = Q, Ee(() => h.value = Q));
      }
    }
    async function H(x) {
      ["Enter", "ArrowLeft", "ArrowRight", "Backspace", "Delete", "Tab"].includes(x.key) || x.ctrlKey || ["ArrowDown", "ArrowUp"].includes(x.key) && (x.preventDefault(), x.stopPropagation(), Z(), await Ee(), x.key === "ArrowDown" ? K(!1) : K());
    }
    function B(x) {
      x.stopPropagation();
    }
    function L(x) {
      x.currentTarget?.releasePointerCapture(x.pointerId), x.preventDefault(), t();
    }
    function O(x) {
      x.currentTarget?.setPointerCapture(x.pointerId), x.preventDefault(), x.stopPropagation(), n("up");
    }
    function U(x) {
      x.currentTarget?.setPointerCapture(x.pointerId), x.preventDefault(), x.stopPropagation(), n("down");
    }
    function Z() {
      if (o.value || !r.value) return;
      const x = r.value.value, $ = Number(x.replace(c.value, "."));
      x && !isNaN($) ? h.value = d(Xe($, e.min, e.max)) : h.value = null;
    }
    function J() {
      o.value || (h.value = f.value !== null && !isNaN(f.value) ? d(f.value, e.precision, !1) : null);
    }
    function A() {
      if (!o.value) {
        if (f.value === null || isNaN(f.value)) {
          h.value = null;
          return;
        }
        h.value = f.value.toString().replace(".", c.value);
      }
    }
    function T() {
      A();
    }
    function E() {
      Z();
    }
    return me(() => {
      const {
        modelValue: x,
        type: $,
        ...V
      } = Dt.filterProps(e);
      function F() {
        return i.increment ? C(je, {
          key: "increment-defaults",
          defaults: {
            VBtn: {
              disabled: !m.value,
              height: _.value,
              size: S.value,
              icon: w.value,
              variant: "text"
            }
          }
        }, {
          default: () => [i.increment(P)]
        }) : C(Te, {
          "aria-hidden": "true",
          "data-testid": "increment",
          disabled: !m.value,
          height: _.value,
          icon: w.value,
          key: "increment-btn",
          onClick: B,
          onPointerdown: O,
          onPointerup: L,
          onPointercancel: L,
          size: S.value,
          variant: "text",
          tabindex: "-1"
        }, null);
      }
      function z() {
        return i.decrement ? C(je, {
          key: "decrement-defaults",
          defaults: {
            VBtn: {
              disabled: !p.value,
              height: _.value,
              size: S.value,
              icon: k.value,
              variant: "text"
            }
          }
        }, {
          default: () => [i.decrement(M)]
        }) : C(Te, {
          "aria-hidden": "true",
          "data-testid": "decrement",
          disabled: !p.value,
          height: _.value,
          icon: k.value,
          key: "decrement-btn",
          onClick: B,
          onPointerdown: U,
          onPointerup: L,
          onPointercancel: L,
          size: S.value,
          variant: "text",
          tabindex: "-1"
        }, null);
      }
      function X() {
        return D("div", {
          class: "v-number-input__control"
        }, [z(), C(ia, {
          vertical: b.value !== "stacked"
        }, null), F()]);
      }
      function Q() {
        return !e.hideInput && !e.inset ? C(ia, {
          vertical: !0
        }, null) : void 0;
      }
      const te = b.value === "split" ? D("div", {
        class: "v-number-input__control"
      }, [C(ia, {
        vertical: !0
      }, null), F()]) : e.reverse || b.value === "hidden" ? void 0 : D(pe, null, [Q(), X()]), N = i["append-inner"] || te, R = b.value === "split" ? D("div", {
        class: "v-number-input__control"
      }, [z(), C(ia, {
        vertical: !0
      }, null)]) : e.reverse && b.value !== "hidden" ? D(pe, null, [X(), Q()]) : void 0, G = i["prepend-inner"] || R;
      return C(Dt, re({
        ref: r
      }, V, {
        modelValue: h.value,
        "onUpdate:modelValue": (ae) => h.value = ae,
        focused: l.value,
        "onUpdate:focused": (ae) => l.value = ae,
        validationValue: f.value,
        error: e.error || y.value || void 0,
        onBeforeinput: j,
        onFocus: T,
        onBlur: E,
        onKeydown: H,
        class: ["v-number-input", {
          "v-number-input--default": b.value === "default",
          "v-number-input--hide-input": e.hideInput,
          "v-number-input--inset": e.inset,
          "v-number-input--reverse": e.reverse,
          "v-number-input--split": b.value === "split",
          "v-number-input--stacked": b.value === "stacked"
        }, e.class],
        style: e.style,
        inputmode: "decimal"
      }), {
        ...i,
        "append-inner": N ? function() {
          for (var ae = arguments.length, ve = new Array(ae), ne = 0; ne < ae; ne++)
            ve[ne] = arguments[ne];
          return D(pe, null, [i["append-inner"]?.(...ve), te]);
        } : void 0,
        "prepend-inner": G ? function() {
          for (var ae = arguments.length, ve = new Array(ae), ne = 0; ne < ae; ne++)
            ve[ne] = arguments[ne];
          return D(pe, null, [R, i["prepend-inner"]?.(...ve)]);
        } : void 0
      });
    }), Pt({}, r);
  }
}), E1 = dt({
  props: {
    modelValue: {
      /** @type import('vue').PropType<import('../../types.js').VjsfNumberFieldNode> */
      type: Object,
      required: !0
    },
    statefulLayout: {
      /** @type import('vue').PropType<import('../../types.js').VjsfStatefulLayout> */
      type: Object,
      required: !0
    }
  },
  setup(e) {
    Ge({}, "VjsfNumberField");
    const { inputProps: a, localData: i, compSlots: r } = mt(
      W(e, "modelValue"),
      e.statefulLayout,
      { layoutPropsMap: ["step", "min", "max", "precision", "placeholder"] }
    ), n = I(() => {
      const t = { ...a.value };
      return t.modelValue = i.value, t.precision === void 0 && (t.precision = null), t;
    });
    return () => Oe(O1, n.value, r.value);
  }
}), Mu = /* @__PURE__ */ Symbol.for("vuetify:v-slider");
function A1(e, a, i) {
  const r = i === "vertical", n = a.getBoundingClientRect(), t = "touches" in e ? e.touches[0] : e;
  return r ? t.clientY - (n.top + n.height / 2) : t.clientX - (n.left + n.width / 2);
}
function T1(e, a) {
  return "touches" in e && e.touches.length ? e.touches[0][a] : "changedTouches" in e && e.changedTouches.length ? e.changedTouches[0][a] : e[a];
}
const j1 = ee({
  disabled: {
    type: Boolean,
    default: null
  },
  error: Boolean,
  readonly: {
    type: Boolean,
    default: null
  },
  max: {
    type: [Number, String],
    default: 100
  },
  min: {
    type: [Number, String],
    default: 0
  },
  step: {
    type: [Number, String],
    default: 0
  },
  thumbColor: String,
  thumbLabel: {
    type: [Boolean, String],
    default: void 0,
    validator: (e) => typeof e == "boolean" || e === "always"
  },
  thumbSize: {
    type: [Number, String],
    default: 20
  },
  showTicks: {
    type: [Boolean, String],
    default: !1,
    validator: (e) => typeof e == "boolean" || e === "always"
  },
  ticks: {
    type: [Array, Object]
  },
  tickSize: {
    type: [Number, String],
    default: 2
  },
  color: String,
  trackColor: String,
  trackFillColor: String,
  trackSize: {
    type: [Number, String],
    default: 4
  },
  direction: {
    type: String,
    default: "horizontal",
    validator: (e) => ["vertical", "horizontal"].includes(e)
  },
  reverse: Boolean,
  noKeyboard: Boolean,
  ...$t(),
  ...ea({
    elevation: 2
  }),
  ripple: {
    type: Boolean,
    default: !0
  }
}, "Slider"), D1 = (e) => {
  const a = I(() => parseFloat(e.min)), i = I(() => parseFloat(e.max)), r = I(() => Number(e.step) > 0 ? parseFloat(e.step) : 0), n = I(() => Math.max(Tf(r.value), Tf(a.value)));
  function t(s) {
    if (s = parseFloat(s), r.value <= 0) return s;
    const o = Xe(s, a.value, i.value), l = a.value % r.value;
    let u = Math.round((o - l) / r.value) * r.value + l;
    return o > u && u + r.value > i.value && (u = i.value), parseFloat(Math.min(u, i.value).toFixed(n.value));
  }
  return {
    min: a,
    max: i,
    step: r,
    decimals: n,
    roundValue: t
  };
}, M1 = (e) => {
  let {
    props: a,
    steps: i,
    onSliderStart: r,
    onSliderMove: n,
    onSliderEnd: t,
    getActiveThumb: s
  } = e;
  const o = Xn(a), {
    isRtl: l
  } = St(), u = W(() => a.reverse), c = I(() => a.direction === "vertical"), d = I(() => c.value !== u.value), {
    min: f,
    max: v,
    step: g,
    decimals: h,
    roundValue: y
  } = i, m = I(() => parseInt(a.thumbSize, 10)), p = I(() => parseInt(a.tickSize, 10)), b = I(() => parseInt(a.trackSize, 10)), w = I(() => (v.value - f.value) / g.value), k = I(() => a.error || o.isDisabled.value ? void 0 : a.thumbColor ?? a.color), S = I(() => a.error || o.isDisabled.value ? void 0 : a.thumbColor), _ = I(() => a.error || o.isDisabled.value ? void 0 : a.trackColor ?? a.color), P = I(() => a.error || o.isDisabled.value ? void 0 : a.trackFillColor ?? a.color), M = fe(!1), q = fe(0), K = ie(), j = ie();
  function H(z) {
    const X = K.value?.$el;
    if (!X) return;
    const Q = a.direction === "vertical", te = Q ? "top" : "left", N = Q ? "height" : "width", R = Q ? "clientY" : "clientX", {
      [te]: G,
      [N]: ae
    } = X.getBoundingClientRect(), ve = T1(z, R);
    let ne = Xe((ve - G - q.value) / ae) || 0;
    return (Q ? d.value : d.value !== l.value) && (ne = 1 - ne), y(f.value + ne * (v.value - f.value));
  }
  const B = (z) => {
    const X = H(z);
    X != null && t({
      value: X
    }), M.value = !1, q.value = 0;
  }, L = (z) => {
    const X = H(z);
    j.value = s(z), j.value && (M.value = !0, j.value.contains(z.target) ? q.value = A1(z, j.value, a.direction) : (q.value = 0, X != null && n({
      value: X
    })), X != null && r({
      value: X
    }), Ee(() => j.value?.focus()));
  }, O = {
    passive: !0,
    capture: !0
  };
  function U(z) {
    const X = H(z);
    X != null && n({
      value: X
    });
  }
  function Z(z) {
    z.stopPropagation(), z.preventDefault(), B(z), window.removeEventListener("mousemove", U, O), window.removeEventListener("mouseup", Z);
  }
  function J(z) {
    B(z), window.removeEventListener("touchmove", U, O), z.target?.removeEventListener("touchend", J);
  }
  function A(z) {
    L(z), window.addEventListener("touchmove", U, O), z.target?.addEventListener("touchend", J, {
      passive: !1
    });
  }
  function T(z) {
    z.button === 0 && (z.preventDefault(), L(z), window.addEventListener("mousemove", U, O), window.addEventListener("mouseup", Z, {
      passive: !1
    }));
  }
  st(() => {
    window.removeEventListener("touchmove", U), window.removeEventListener("mousemove", U), window.removeEventListener("mouseup", Z);
  });
  const E = (z) => {
    const X = (z - f.value) / (v.value - f.value) * 100;
    return Xe(isNaN(X) ? 0 : X, 0, 100);
  }, x = W(() => a.showTicks), $ = I(() => x.value ? a.ticks ? Array.isArray(a.ticks) ? a.ticks.map((z) => ({
    value: z,
    position: E(z),
    label: z.toString()
  })) : Object.keys(a.ticks).map((z) => ({
    value: parseFloat(z),
    position: E(parseFloat(z)),
    label: a.ticks[z]
  })) : w.value !== 1 / 0 ? Bn(w.value + 1).map((z) => {
    const X = f.value + z * g.value;
    return {
      value: X,
      position: E(X)
    };
  }) : [] : []), V = I(() => $.value.some((z) => {
    let {
      label: X
    } = z;
    return !!X;
  })), F = {
    activeThumbRef: j,
    color: W(() => a.color),
    decimals: h,
    disabled: o.isDisabled,
    direction: W(() => a.direction),
    elevation: W(() => a.elevation),
    hasLabels: V,
    isReversed: u,
    indexFromEnd: d,
    min: f,
    max: v,
    mousePressed: M,
    noKeyboard: W(() => a.noKeyboard),
    numTicks: w,
    onSliderMousedown: T,
    onSliderTouchstart: A,
    parsedTicks: $,
    parseMouseMove: H,
    position: E,
    readonly: o.isReadonly,
    rounded: W(() => a.rounded),
    roundValue: y,
    showTicks: x,
    startOffset: q,
    step: g,
    thumbSize: m,
    thumbColor: k,
    thumbLabelColor: S,
    thumbLabel: W(() => a.thumbLabel),
    ticks: W(() => a.ticks),
    tickSize: p,
    trackColor: _,
    trackContainerRef: K,
    trackFillColor: P,
    trackSize: b,
    vertical: c
  };
  return ht(Mu, F), F;
}, R1 = ee({
  focused: Boolean,
  max: {
    type: Number,
    required: !0
  },
  min: {
    type: Number,
    required: !0
  },
  modelValue: {
    type: Number,
    required: !0
  },
  position: {
    type: Number,
    required: !0
  },
  ripple: {
    type: [Boolean, Object],
    default: !0
  },
  name: String,
  noKeyboard: Boolean,
  ...Se()
}, "VSliderThumb"), N1 = de()({
  name: "VSliderThumb",
  directives: {
    vRipple: At
  },
  props: R1(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, a) {
    let {
      slots: i,
      emit: r
    } = a;
    const n = qe(Mu), {
      isRtl: t,
      rtlClasses: s
    } = St();
    if (!n) throw new Error("[Vuetify] v-slider-thumb must be used inside v-slider or v-range-slider");
    const {
      min: o,
      max: l,
      thumbColor: u,
      thumbLabelColor: c,
      step: d,
      disabled: f,
      thumbSize: v,
      thumbLabel: g,
      direction: h,
      isReversed: y,
      vertical: m,
      readonly: p,
      elevation: b,
      mousePressed: w,
      decimals: k,
      indexFromEnd: S
    } = n, _ = I(() => f.value ? void 0 : b.value), {
      elevationClasses: P
    } = ta(_), {
      textColorClasses: M,
      textColorStyles: q
    } = kt(u), {
      backgroundColorClasses: K,
      backgroundColorStyles: j
    } = at(c), {
      pageup: H,
      pagedown: B,
      end: L,
      home: O,
      left: U,
      right: Z,
      down: J,
      up: A
    } = G0, T = [H, B, L, O, U, Z, J, A], E = I(() => d.value ? [1, 2, 3] : [1, 5, 10]);
    function x(V, F) {
      if (e.noKeyboard || f.value || !T.includes(V.key)) return;
      V.preventDefault();
      const z = d.value || 0.1, X = (l.value - o.value) / z;
      if ([U, Z, J, A].includes(V.key)) {
        const te = (m.value ? [t.value ? U : Z, y.value ? J : A] : S.value !== t.value ? [U, A] : [Z, A]).includes(V.key) ? 1 : -1, N = V.shiftKey ? 2 : V.ctrlKey ? 1 : 0;
        te === -1 && F === l.value && !N && !Number.isInteger(X) ? F = F - X % 1 * z : F = F + te * z * E.value[N];
      } else if (V.key === O)
        F = o.value;
      else if (V.key === L)
        F = l.value;
      else {
        const Q = V.key === B ? 1 : -1;
        F = F - Q * z * (X > 100 ? X / 10 : 10);
      }
      return Math.max(e.min, Math.min(e.max, F));
    }
    function $(V) {
      const F = x(V, e.modelValue);
      F != null && r("update:modelValue", F);
    }
    return me(() => {
      const V = he(S.value ? 100 - e.position : e.position, "%");
      return D("div", {
        class: ue(["v-slider-thumb", {
          "v-slider-thumb--focused": e.focused,
          "v-slider-thumb--pressed": e.focused && w.value
        }, e.class, s.value]),
        style: be([{
          "--v-slider-thumb-position": V,
          "--v-slider-thumb-size": he(v.value)
        }, e.style]),
        role: "slider",
        tabindex: f.value ? -1 : 0,
        "aria-label": e.name,
        "aria-valuemin": o.value,
        "aria-valuemax": l.value,
        "aria-valuenow": e.modelValue,
        "aria-readonly": !!p.value,
        "aria-orientation": h.value,
        onKeydown: p.value ? void 0 : $
      }, [D("div", {
        class: ue(["v-slider-thumb__surface", M.value, P.value]),
        style: be(q.value)
      }, null), Je(D("div", {
        class: ue(["v-slider-thumb__ripple", M.value]),
        style: be(q.value)
      }, null), [[At, e.ripple, null, {
        circle: !0,
        center: !0
      }]]), C(Ep, {
        origin: "bottom center"
      }, {
        default: () => [Je(D("div", {
          class: "v-slider-thumb__label-container"
        }, [D("div", {
          class: ue(["v-slider-thumb__label", K.value]),
          style: be(j.value)
        }, [D("div", null, [i["thumb-label"]?.({
          modelValue: e.modelValue
        }) ?? e.modelValue.toFixed(d.value ? k.value : 1)]), D("div", {
          class: "v-slider-thumb__label-wedge"
        }, null)])]), [[ya, g.value && e.focused || g.value === "always"]])]
      })]);
    }), {};
  }
}), L1 = ee({
  start: {
    type: Number,
    required: !0
  },
  stop: {
    type: Number,
    required: !0
  },
  ...Se()
}, "VSliderTrack"), q1 = de()({
  name: "VSliderTrack",
  props: L1(),
  emits: {},
  setup(e, a) {
    let {
      slots: i
    } = a;
    const r = qe(Mu);
    if (!r) throw new Error("[Vuetify] v-slider-track must be inside v-slider or v-range-slider");
    const {
      color: n,
      parsedTicks: t,
      rounded: s,
      showTicks: o,
      tickSize: l,
      trackColor: u,
      trackFillColor: c,
      trackSize: d,
      vertical: f,
      min: v,
      max: g,
      indexFromEnd: h
    } = r, {
      roundedClasses: y
    } = _t(s), {
      backgroundColorClasses: m,
      backgroundColorStyles: p
    } = at(c), {
      backgroundColorClasses: b,
      backgroundColorStyles: w
    } = at(u), k = I(() => `inset-${f.value ? "block" : "inline"}-${h.value ? "end" : "start"}`), S = I(() => f.value ? "height" : "width"), _ = I(() => ({
      [k.value]: "0%",
      [S.value]: "100%"
    })), P = I(() => e.stop - e.start), M = I(() => ({
      [k.value]: he(e.start, "%"),
      [S.value]: he(P.value, "%")
    })), q = I(() => o.value ? (f.value ? t.value.slice().reverse() : t.value).map((j, H) => {
      const B = j.value !== v.value && j.value !== g.value ? he(j.position, "%") : void 0;
      return D("div", {
        key: j.value,
        class: ue(["v-slider-track__tick", {
          "v-slider-track__tick--filled": j.position >= e.start && j.position <= e.stop,
          "v-slider-track__tick--first": j.value === v.value,
          "v-slider-track__tick--last": j.value === g.value
        }]),
        style: {
          [k.value]: B
        }
      }, [(j.label || i["tick-label"]) && D("div", {
        class: "v-slider-track__tick-label"
      }, [i["tick-label"]?.({
        tick: j,
        index: H
      }) ?? j.label])]);
    }) : []);
    return me(() => D("div", {
      class: ue(["v-slider-track", y.value, e.class]),
      style: be([{
        "--v-slider-track-size": he(d.value),
        "--v-slider-tick-size": he(l.value)
      }, e.style])
    }, [D("div", {
      class: ue(["v-slider-track__background", b.value, {
        "v-slider-track__background--opacity": !!n.value || !c.value
      }]),
      style: {
        ..._.value,
        ...w.value
      }
    }, null), D("div", {
      class: ue(["v-slider-track__fill", m.value]),
      style: {
        ...M.value,
        ...p.value
      }
    }, null), o.value && D("div", {
      class: ue(["v-slider-track__ticks", {
        "v-slider-track__ticks--always-show": o.value === "always"
      }])
    }, [q.value])])), {};
  }
}), z1 = ee({
  ...Ws(),
  ...j1(),
  ...Ka(),
  modelValue: {
    type: [Number, String],
    default: 0
  }
}, "VSlider"), Do = de()({
  name: "VSlider",
  inheritAttrs: !1,
  props: z1(),
  emits: {
    "update:focused": (e) => !0,
    "update:modelValue": (e) => !0,
    start: (e) => !0,
    end: (e) => !0
  },
  setup(e, a) {
    let {
      slots: i,
      emit: r,
      attrs: n
    } = a;
    const t = ie(), s = ie(), {
      rtlClasses: o
    } = St(), l = D1(e), u = $e(e, "modelValue", void 0, (q) => l.roundValue(q ?? l.min.value)), {
      min: c,
      max: d,
      mousePressed: f,
      roundValue: v,
      onSliderMousedown: g,
      onSliderTouchstart: h,
      trackContainerRef: y,
      position: m,
      hasLabels: p,
      disabled: b,
      readonly: w,
      noKeyboard: k
    } = M1({
      props: e,
      steps: l,
      onSliderStart: () => {
        !b.value && !w.value && r("start", u.value);
      },
      onSliderEnd: (q) => {
        let {
          value: K
        } = q;
        const j = v(K);
        !b.value && !w.value && (u.value = j), r("end", j);
      },
      onSliderMove: (q) => {
        let {
          value: K
        } = q;
        !b.value && !w.value && (u.value = v(K));
      },
      getActiveThumb: () => t.value?.$el
    }), {
      isFocused: S,
      focus: _,
      blur: P
    } = bn(e), M = I(() => m(u.value));
    return me(() => {
      const q = Tt.filterProps(e), [K, j] = Ba(n), H = !!(e.label || i.label || i.prepend);
      return C(Tt, re({
        ref: s,
        class: ["v-slider", {
          "v-slider--has-labels": !!i["tick-label"] || p.value,
          "v-slider--focused": S.value,
          "v-slider--pressed": f.value,
          "v-slider--disabled": b.value
        }, o.value, e.class],
        style: e.style
      }, q, K, {
        focused: S.value
      }), {
        ...i,
        prepend: H ? (B) => D(pe, null, [i.label?.(B) ?? (e.label ? C(qr, {
          id: B.id.value,
          class: "v-slider__label",
          text: e.label
        }, null) : void 0), i.prepend?.(B)]) : void 0,
        default: (B) => {
          let {
            id: L,
            messagesId: O
          } = B;
          return D("div", {
            class: "v-slider__container",
            onMousedown: w.value ? void 0 : g,
            onTouchstartPassive: w.value ? void 0 : h
          }, [D("input", {
            id: L.value,
            name: e.name || L.value,
            disabled: b.value,
            readonly: w.value,
            tabindex: "-1",
            value: u.value
          }, null), C(q1, {
            ref: y,
            start: 0,
            stop: M.value
          }, {
            "tick-label": i["tick-label"]
          }), C(N1, re({
            ref: t,
            "aria-describedby": O.value,
            focused: S.value,
            noKeyboard: k.value,
            min: c.value,
            max: d.value,
            modelValue: u.value,
            "onUpdate:modelValue": (U) => u.value = U,
            position: M.value,
            elevation: e.elevation,
            onFocus: _,
            onBlur: P,
            ripple: e.ripple,
            name: e.name
          }, j), {
            "thumb-label": i["thumb-label"]
          })]);
        }
      });
    }), Pt({
      focus: () => t.value?.$el.focus()
    }, s);
  }
}), B1 = dt({
  props: {
    modelValue: {
      /** @type import('vue').PropType<import('../../types.js').VjsfSliderNode> */
      type: Object,
      required: !0
    },
    statefulLayout: {
      /** @type import('vue').PropType<import('../../types.js').VjsfStatefulLayout> */
      type: Object,
      required: !0
    }
  },
  setup(e) {
    Ge({}, "VjsfSlider");
    const { inputProps: a, localData: i, compSlots: r } = mt(
      W(e, "modelValue"),
      e.statefulLayout,
      { layoutPropsMap: ["step", "min", "max"] }
    ), n = I(() => {
      const t = { ...a.value };
      return t.modelValue = i.value, t["onUpdate:modelValue"] = (s) => {
        const o = s && Number(s);
        i.value = o, e.statefulLayout.input(e.modelValue, o);
      }, t;
    });
    return () => Oe(Do, n.value, r.value);
  }
}), Ru = {
  __name: "text-field-menu",
  props: /* @__PURE__ */ ac({
    modelValue: {
      /** @type import('vue').PropType<import('../../types.js').VjsfNode> */
      type: Object,
      required: !0
    },
    statefulLayout: {
      /** @type import('vue').PropType<import('../../types.js').VjsfStatefulLayout> */
      type: Object,
      required: !0
    },
    readonly: {
      /** @type import('vue').PropType<boolean> */
      type: Boolean,
      default: !0
    },
    placeholder: {
      /** @type import('vue').PropType<string | null> */
      type: String,
      default: null
    },
    minWidth: {
      /** @type import('vue').PropType<string> */
      type: String,
      default: "328px"
    },
    maxWidth: {
      /** @type import('vue').PropType<string> */
      type: String,
      default: "328px"
    }
  }, {
    menuOpened: { type: Boolean, default: !1 },
    menuOpenedModifiers: {},
    formattedValue: { type: String, default: null },
    formattedValueModifiers: {}
  }),
  emits: /* @__PURE__ */ ac(["blur"], ["update:menuOpened", "update:formattedValue"]),
  setup(e, { emit: a }) {
    const i = e, r = a, { inputProps: n, skeleton: t, compProps: s, data: o } = mt(
      W(i, "modelValue"),
      i.statefulLayout,
      { isMainComp: !1, bindData: !1 }
    ), l = I(() => {
      const g = { ...n.value };
      return g.clearable = g.clearable ?? !t.value.required, i.placeholder && (g.placeholder = i.placeholder), g["onClick:clear"] = () => {
        i.statefulLayout.input(i.modelValue, null);
      }, g.readonly = i.readonly, g;
    }), u = gn(i.modelValue.fullKey), c = I(() => ({
      ...s.value,
      minWidth: i.minWidth,
      maxWidth: i.maxWidth,
      zIndex: u,
      closeOnContentClick: !1,
      disabled: !0
    })), d = ie(null), f = nc(e, "menuOpened"), v = nc(e, "formattedValue");
    return (g, h) => (oe(), De(pe, null, [
      C(Y(Dt), re({
        ref_key: "textField",
        ref: d
      }, l.value, {
        "model-value": v.value ?? Y(o),
        "onClick:control": h[0] || (h[0] = (y) => {
          f.value = !f.value, y.stopPropagation();
        }),
        "onUpdate:modelValue": h[1] || (h[1] = (y) => v.value = y),
        onBlur: h[2] || (h[2] = (y) => r("blur"))
      }), {
        "prepend-inner": le(() => [
          rc(g.$slots, "prepend-inner")
        ]),
        _: 3
      }, 16, ["model-value"]),
      d.value ? (oe(), ye(Y(La), re({ key: 0 }, c.value, {
        modelValue: f.value,
        "onUpdate:modelValue": h[3] || (h[3] = (y) => f.value = y),
        class: "vjsf-text-field-menu",
        activator: d.value
      }), {
        default: le(() => [
          rc(g.$slots, "default", {
            close: () => f.value = !1
          })
        ]),
        _: 3
      }, 16, ["modelValue", "activator"])) : Ve("", !0)
    ], 64));
  }
}, Zp = ee({
  active: {
    type: [String, Array],
    default: void 0
  },
  controlHeight: [Number, String],
  controlVariant: {
    type: String,
    default: "docked"
  },
  noMonthPicker: Boolean,
  disabled: {
    type: [Boolean, String, Array],
    default: null
  },
  nextIcon: {
    type: Pe,
    default: "$next"
  },
  prevIcon: {
    type: Pe,
    default: "$prev"
  },
  modeIcon: {
    type: Pe,
    default: "$subgroup"
  },
  text: String,
  monthText: String,
  yearText: String,
  viewMode: {
    type: String,
    default: "month"
  }
}, "VDatePickerControls"), Im = de()({
  name: "VDatePickerControls",
  props: Zp(),
  emits: {
    "click:year": () => !0,
    "click:month": () => !0,
    "click:prev": () => !0,
    "click:next": () => !0,
    "click:prev-year": () => !0,
    "click:next-year": () => !0
  },
  setup(e, a) {
    let {
      emit: i,
      slots: r
    } = a;
    const {
      t: n
    } = nt(), t = I(() => Array.isArray(e.disabled) ? e.disabled.includes("text") : !!e.disabled), s = I(() => Array.isArray(e.disabled) ? e.disabled.includes("mode") : !!e.disabled), o = I(() => Array.isArray(e.disabled) ? e.disabled.includes("prev-month") : !!e.disabled), l = I(() => Array.isArray(e.disabled) ? e.disabled.includes("next-month") : !!e.disabled), u = I(() => Array.isArray(e.disabled) ? e.disabled.includes("prev-year") : !!e.disabled), c = I(() => Array.isArray(e.disabled) ? e.disabled.includes("next-year") : !!e.disabled);
    function d() {
      i("click:prev");
    }
    function f() {
      i("click:next");
    }
    function v() {
      i("click:prev-year");
    }
    function g() {
      i("click:next-year");
    }
    function h() {
      i("click:year");
    }
    function y() {
      i("click:month");
    }
    return me(() => {
      const m = {
        VBtn: {
          density: "comfortable",
          variant: "text"
        }
      }, p = C(Te, {
        "data-testid": "prev-month",
        disabled: o.value,
        icon: e.prevIcon,
        "aria-label": n("$vuetify.datePicker.ariaLabel.previousMonth"),
        onClick: d
      }, null), b = C(Te, {
        "data-testid": "next-month",
        disabled: l.value,
        icon: e.nextIcon,
        "aria-label": n("$vuetify.datePicker.ariaLabel.nextMonth"),
        onClick: f
      }, null), w = C(Te, {
        "data-testid": "prev-year",
        disabled: u.value,
        icon: e.prevIcon,
        "aria-label": n("$vuetify.datePicker.ariaLabel.previousYear"),
        onClick: v
      }, null), k = C(Te, {
        "data-testid": "next-year",
        disabled: c.value,
        icon: e.nextIcon,
        "aria-label": n("$vuetify.datePicker.ariaLabel.nextYear"),
        onClick: g
      }, null), S = C(Te, {
        class: "v-date-picker-controls__only-month-btn",
        "data-testid": "month-btn",
        density: "default",
        disabled: t.value,
        text: e.monthText,
        appendIcon: e.modeIcon,
        rounded: !0,
        "aria-label": n("$vuetify.datePicker.ariaLabel.selectMonth"),
        onClick: y
      }, null), _ = C(Te, {
        class: "v-date-picker-controls__only-year-btn",
        "data-testid": "year-btn",
        density: "default",
        disabled: s.value,
        text: e.yearText,
        appendIcon: e.modeIcon,
        rounded: !0,
        "aria-label": n("$vuetify.datePicker.ariaLabel.selectYear"),
        onClick: h
      }, null), P = C(Te, {
        class: "v-date-picker-controls__year-btn",
        "data-testid": "year-btn",
        density: "default",
        disabled: s.value,
        text: e.text,
        appendIcon: e.modeIcon,
        rounded: !0,
        "aria-label": n("$vuetify.datePicker.ariaLabel.selectYear"),
        onClick: h
      }, null), M = D(pe, null, [C(Te, {
        class: "v-date-picker-controls__month-btn",
        "data-testid": "month-btn",
        height: "36",
        disabled: t.value,
        text: e.text,
        rounded: !0,
        "aria-label": n("$vuetify.datePicker.ariaLabel.selectMonth"),
        onClick: y
      }, null), C(Te, {
        class: "v-date-picker-controls__mode-btn",
        "data-testid": "year-btn",
        disabled: s.value,
        icon: e.modeIcon,
        "aria-label": n("$vuetify.datePicker.ariaLabel.selectYear"),
        onClick: h
      }, null)]), q = {
        viewMode: e.viewMode,
        disabled: Array.isArray(e.disabled) ? e.disabled : [],
        monthYearText: e.text ?? "",
        monthText: e.monthText ?? "",
        yearText: e.yearText ?? "",
        openMonths: y,
        openYears: h,
        prevMonth: d,
        nextMonth: f,
        prevYear: v,
        nextYear: g
      }, K = D(pe, null, [e.noMonthPicker ? P : M, C(yr, null, null), D("div", {
        class: "v-date-picker-controls__month"
      }, [p, b])]), j = D(pe, null, [D("div", {
        class: "v-date-picker-controls__month"
      }, [p, S, b]), C(yr, null, null), D("div", {
        class: "v-date-picker-controls__year"
      }, [w, _, k])]);
      return C(je, {
        defaults: m
      }, {
        default: () => [D("div", {
          class: ue(["v-date-picker-controls", `v-date-picker-controls--variant-${e.controlVariant}`]),
          style: {
            "--v-date-picker-controls-height": he(e.controlHeight)
          }
        }, [r.default?.(q) ?? D(pe, null, [e.controlVariant === "modal" && K, e.controlVariant === "docked" && j])])]
      });
    }), {};
  }
}), F1 = ee({
  appendIcon: Pe,
  color: String,
  header: String,
  transition: String,
  onClick: Et()
}, "VDatePickerHeader"), Om = de()({
  name: "VDatePickerHeader",
  props: F1(),
  emits: {
    click: () => !0,
    "click:append": () => !0
  },
  setup(e, a) {
    let {
      emit: i,
      slots: r
    } = a;
    const {
      backgroundColorClasses: n,
      backgroundColorStyles: t
    } = at(() => e.color);
    function s() {
      i("click");
    }
    function o() {
      i("click:append");
    }
    return me(() => {
      const l = !!(r.default || e.header), u = !!(r.append || e.appendIcon);
      return D("div", {
        class: ue(["v-date-picker-header", {
          "v-date-picker-header--clickable": !!e.onClick
        }, n.value]),
        style: be(t.value),
        onClick: s
      }, [r.prepend && D("div", {
        key: "prepend",
        class: "v-date-picker-header__prepend"
      }, [r.prepend()]), l && C(Wt, {
        key: "content",
        name: e.transition
      }, {
        default: () => [D("div", {
          key: e.header,
          class: "v-date-picker-header__content"
        }, [r.default?.() ?? e.header])]
      }), u && D("div", {
        class: "v-date-picker-header__append"
      }, [r.append ? C(je, {
        key: "append-defaults",
        disabled: !e.appendIcon,
        defaults: {
          VBtn: {
            icon: e.appendIcon,
            variant: "text"
          }
        }
      }, {
        default: () => [r.append?.()]
      }) : C(Te, {
        key: "append-btn",
        icon: e.appendIcon,
        variant: "text",
        onClick: o
      }, null)])]);
    }), {};
  }
}), K1 = ee({
  bordered: Boolean,
  color: String,
  content: [Number, String],
  dot: Boolean,
  floating: Boolean,
  icon: Pe,
  inline: Boolean,
  label: {
    type: String,
    default: "$vuetify.badge"
  },
  max: [Number, String],
  modelValue: {
    type: Boolean,
    default: !0
  },
  offsetX: [Number, String],
  offsetY: [Number, String],
  textColor: String,
  ...Se(),
  ...Un({
    location: "top end"
  }),
  ...$t(),
  ...Be(),
  ...Qe(),
  ...Gn({
    transition: "scale-rotate-transition"
  }),
  ...Mt()
}, "VBadge"), H1 = de()({
  name: "VBadge",
  inheritAttrs: !1,
  props: K1(),
  setup(e, a) {
    const {
      backgroundColorClasses: i,
      backgroundColorStyles: r
    } = at(() => e.color), {
      roundedClasses: n
    } = _t(e), {
      t
    } = nt(), {
      textColorClasses: s,
      textColorStyles: o
    } = kt(() => e.textColor), {
      themeClasses: l
    } = qs(), {
      locationStyles: u
    } = Wn(e, !0, (d) => (e.floating ? e.dot ? 2 : 4 : e.dot ? 8 : 12) + (["top", "bottom"].includes(d) ? Number(e.offsetY ?? 0) : ["left", "right"].includes(d) ? Number(e.offsetX ?? 0) : 0)), {
      dimensionStyles: c
    } = Rt(e);
    return me(() => {
      const d = Number(e.content), f = !e.max || isNaN(d) ? e.content : d <= Number(e.max) ? d : `${e.max}+`, [v, g] = wo(a.attrs, ["aria-atomic", "aria-label", "aria-live", "role", "title"]);
      return C(e.tag, re({
        class: ["v-badge", {
          "v-badge--bordered": e.bordered,
          "v-badge--dot": e.dot,
          "v-badge--floating": e.floating,
          "v-badge--inline": e.inline
        }, e.class]
      }, g, {
        style: e.style
      }), {
        default: () => [D("div", {
          class: "v-badge__wrapper"
        }, [a.slots.default?.(), C(Wt, {
          transition: e.transition
        }, {
          default: () => [Je(D("span", re({
            class: ["v-badge__badge", l.value, i.value, n.value, s.value],
            style: [r.value, o.value, c.value, e.inline ? {} : u.value],
            "aria-atomic": "true",
            "aria-label": t(e.label, d),
            "aria-live": "polite",
            role: "status"
          }, v), [e.dot ? void 0 : a.slots.badge ? a.slots.badge?.() : e.icon ? C(xe, {
            icon: e.icon
          }, null) : f]), [[ya, e.modelValue]])]
        })])]
      });
    }), {};
  }
}), U1 = ee({
  allowedDates: [Array, Function],
  disabled: {
    type: Boolean,
    default: null
  },
  displayValue: null,
  modelValue: Array,
  month: [Number, String],
  max: null,
  min: null,
  showAdjacentMonths: Boolean,
  year: [Number, String],
  weekdays: {
    type: Array,
    default: () => [0, 1, 2, 3, 4, 5, 6]
  },
  weeksInMonth: {
    type: String,
    default: "dynamic"
  },
  firstDayOfWeek: {
    type: [Number, String],
    default: void 0
  },
  firstDayOfYear: {
    type: [Number, String],
    default: void 0
  },
  weekdayFormat: String
}, "calendar");
function W1(e) {
  const a = Fa(), i = $e(e, "modelValue", [], (h) => Ze(h).map((y) => a.date(y))), r = I(() => e.displayValue ? a.date(e.displayValue) : i.value.length > 0 ? a.date(i.value[0]) : e.min ? a.date(e.min) : Array.isArray(e.allowedDates) ? a.date(e.allowedDates[0]) : a.date()), n = $e(e, "year", void 0, (h) => {
    const y = h != null ? Number(h) : a.getYear(r.value);
    return a.startOfYear(a.setYear(a.date(), y));
  }, (h) => a.getYear(h)), t = $e(e, "month", void 0, (h) => {
    const y = h != null ? Number(h) : a.getMonth(r.value), m = a.setYear(a.startOfMonth(a.date()), a.getYear(n.value));
    return a.setMonth(m, y);
  }, (h) => a.getMonth(h)), s = I(() => {
    const h = a.toJsDate(a.startOfWeek(a.date(), e.firstDayOfWeek)).getDay();
    return a.getWeekdays(e.firstDayOfWeek, e.weekdayFormat).filter((y, m) => e.weekdays.includes((m + h) % 7));
  }), o = I(() => {
    const h = a.getWeekArray(t.value, e.firstDayOfWeek), y = h.flat(), m = 42;
    if (e.weeksInMonth === "static" && y.length < m) {
      const p = y[y.length - 1];
      let b = [];
      for (let w = 1; w <= m - y.length; w++)
        b.push(a.addDays(p, w)), w % 7 === 0 && (h.push(b), b = []);
    }
    return h;
  });
  function l(h, y) {
    return h.filter((m) => e.weekdays.includes(a.toJsDate(m).getDay())).map((m, p) => {
      const b = a.toISO(m), w = !a.isSameMonth(m, t.value), k = a.isSameDay(m, a.startOfMonth(t.value)), S = a.isSameDay(m, a.endOfMonth(t.value)), _ = a.isSameDay(m, t.value), P = e.weekdays.length;
      return {
        date: m,
        formatted: a.format(m, "keyboardDate"),
        isAdjacent: w,
        isDisabled: g(m),
        isEnd: S,
        isHidden: w && !e.showAdjacentMonths,
        isSame: _,
        isSelected: i.value.some((M) => a.isSameDay(m, M)),
        isStart: k,
        isToday: a.isSameDay(m, y),
        isWeekEnd: p % P === P - 1,
        isWeekStart: p % P === 0,
        isoDate: b,
        localized: a.format(m, "dayOfMonth"),
        month: a.getMonth(m),
        year: a.getYear(m)
      };
    });
  }
  const u = I(() => {
    const h = a.startOfWeek(r.value, e.firstDayOfWeek), y = [];
    for (let p = 0; p <= 6; p++)
      y.push(a.addDays(h, p));
    const m = a.date();
    return l(y, m);
  }), c = I(() => {
    const h = o.value.flat(), y = a.date();
    return l(h, y);
  }), d = I(() => o.value.map((h) => h.length ? a.getWeek(h[0], e.firstDayOfWeek, e.firstDayOfYear) : null)), {
    minDate: f,
    maxDate: v
  } = Jp(e);
  function g(h) {
    if (e.disabled) return !0;
    const y = a.date(h);
    return f.value && a.isBefore(a.endOfDay(y), f.value) || v.value && a.isAfter(y, v.value) ? !0 : Array.isArray(e.allowedDates) && e.allowedDates.length > 0 ? !e.allowedDates.some((m) => a.isSameDay(a.date(m), y)) : typeof e.allowedDates == "function" ? !e.allowedDates(y) : !1;
  }
  return {
    displayValue: r,
    daysInMonth: c,
    daysInWeek: u,
    genDays: l,
    model: i,
    weeksInMonth: o,
    weekdayLabels: s,
    weekNumbers: d
  };
}
function Jp(e) {
  const a = Fa(), i = I(() => {
    if (!e.min) return null;
    const s = a.date(e.min);
    return a.isValid(s) ? s : null;
  }), r = I(() => {
    if (!e.max) return null;
    const s = a.date(e.max);
    return a.isValid(s) ? s : null;
  });
  function n(s) {
    return i.value && a.isBefore(s, i.value) ? i.value : r.value && a.isAfter(s, r.value) ? r.value : s;
  }
  function t(s) {
    return (!i.value || a.isAfter(s, i.value)) && (!r.value || a.isBefore(s, r.value));
  }
  return {
    minDate: i,
    maxDate: r,
    clampDate: n,
    isInAllowedRange: t
  };
}
const Qp = ee({
  color: String,
  hideWeekdays: Boolean,
  multiple: [Boolean, Number, String],
  showWeek: Boolean,
  transition: {
    type: String,
    default: "picker-transition"
  },
  reverseTransition: {
    type: String,
    default: "picker-reverse-transition"
  },
  events: {
    type: [Array, Function, Object],
    default: () => null
  },
  eventColor: {
    type: [Array, Function, Object, String],
    default: () => null
  },
  ...Le(U1(), ["displayValue"])
}, "VDatePickerMonth"), Em = de()({
  name: "VDatePickerMonth",
  props: Qp(),
  emits: {
    "update:modelValue": (e) => !0,
    "update:month": (e) => !0,
    "update:year": (e) => !0
  },
  setup(e, a) {
    let {
      emit: i,
      slots: r
    } = a;
    const n = ie(), {
      t
    } = nt(), {
      daysInMonth: s,
      model: o,
      weekNumbers: l,
      weekdayLabels: u
    } = W1(e), c = Fa(), d = fe(), f = fe(), v = fe(!1), g = W(() => v.value ? e.reverseTransition : e.transition);
    e.multiple === "range" && o.value.length > 0 && (d.value = o.value[0], o.value.length > 1 && (f.value = o.value[o.value.length - 1]));
    const h = I(() => {
      const S = ["number", "string"].includes(typeof e.multiple) ? Number(e.multiple) : 1 / 0;
      return o.value.length >= S;
    });
    ce(s, (S, _) => {
      _ && (v.value = c.isBefore(S[0].date, _[0].date));
    });
    function y(S) {
      const _ = c.startOfDay(S);
      if (o.value.length === 0 ? d.value = void 0 : o.value.length === 1 && (d.value = o.value[0], f.value = void 0), !d.value)
        d.value = _, o.value = [d.value];
      else if (f.value)
        d.value = S, f.value = void 0, o.value = [d.value];
      else {
        if (c.isSameDay(_, d.value)) {
          d.value = void 0, o.value = [];
          return;
        } else c.isBefore(_, d.value) ? (f.value = c.endOfDay(d.value), d.value = _) : f.value = c.endOfDay(_);
        o.value = eS(c, d.value, f.value);
      }
    }
    function m(S) {
      const _ = c.format(S.date, "fullDateWithWeekday"), P = S.isToday ? "currentDate" : "selectDate";
      return t(`$vuetify.datePicker.ariaLabel.${P}`, _);
    }
    function p(S) {
      const _ = o.value.findIndex((P) => c.isSameDay(P, S));
      if (_ === -1)
        o.value = [...o.value, S];
      else {
        const P = [...o.value];
        P.splice(_, 1), o.value = P;
      }
    }
    function b(S) {
      e.multiple === "range" ? y(S) : e.multiple ? p(S) : o.value = [S];
    }
    function w(S) {
      const {
        events: _,
        eventColor: P
      } = e;
      let M, q = [];
      if (Array.isArray(_) ? M = _.includes(S) : _ instanceof Function ? M = _(S) || !1 : _ ? M = _[S] || !1 : M = !1, M)
        M !== !0 ? q = Ze(M) : typeof P == "string" ? q = [P] : typeof P == "function" ? q = Ze(P(S)) : Array.isArray(P) ? q = P : typeof P == "object" && P !== null && (q = Ze(P[S]));
      else return [];
      return q.length ? q.filter(Boolean).map((K) => typeof K == "string" ? K : "surface-variant") : ["surface-variant"];
    }
    function k(S) {
      const _ = w(S);
      return _.length ? D("div", {
        class: "v-date-picker-month__events"
      }, [_.map((P) => C(H1, {
        dot: !0,
        color: P
      }, null))]) : null;
    }
    me(() => D("div", {
      class: "v-date-picker-month",
      style: {
        "--v-date-picker-days-in-week": e.weekdays.length
      }
    }, [e.showWeek && D("div", {
      key: "weeks",
      class: "v-date-picker-month__weeks"
    }, [!e.hideWeekdays && D("div", {
      key: "hide-week-days",
      class: "v-date-picker-month__day"
    }, [Fe(" ")]), l.value.map((S) => D("div", {
      class: ue(["v-date-picker-month__day", "v-date-picker-month__day--adjacent"])
    }, [S]))]), C(Wt, {
      name: g.value
    }, {
      default: () => [D("div", {
        ref: n,
        key: s.value[0].date?.toString(),
        class: "v-date-picker-month__days"
      }, [!e.hideWeekdays && u.value.map((S) => D("div", {
        class: ue(["v-date-picker-month__day", "v-date-picker-month__weekday"])
      }, [S])), s.value.map((S, _) => {
        const P = {
          props: {
            class: "v-date-picker-month__day-btn",
            color: S.isSelected || S.isToday ? e.color : void 0,
            disabled: S.isDisabled,
            icon: !0,
            ripple: !1,
            variant: S.isSelected ? "flat" : S.isToday ? "outlined" : "text",
            "aria-label": m(S),
            "aria-current": S.isToday ? "date" : void 0,
            onClick: () => b(S.date)
          },
          item: S,
          i: _
        };
        return h.value && !S.isSelected && (S.isDisabled = !0), D("div", {
          class: ue(["v-date-picker-month__day", {
            "v-date-picker-month__day--adjacent": S.isAdjacent,
            "v-date-picker-month__day--hide-adjacent": S.isHidden,
            "v-date-picker-month__day--selected": S.isSelected,
            "v-date-picker-month__day--week-end": S.isWeekEnd,
            "v-date-picker-month__day--week-start": S.isWeekStart
          }]),
          "data-v-date": S.isDisabled ? void 0 : S.isoDate
        }, [(e.showAdjacentMonths || !S.isAdjacent) && (r.day?.(P) ?? C(Te, P.props, {
          default: () => [S.localized, k(S.isoDate)]
        }))]);
      })])]
    })]));
  }
}), eh = ee({
  color: String,
  height: [String, Number],
  min: null,
  max: null,
  modelValue: Number,
  year: Number,
  allowedMonths: [Array, Function]
}, "VDatePickerMonths"), Am = de()({
  name: "VDatePickerMonths",
  props: eh(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, a) {
    let {
      emit: i,
      slots: r
    } = a;
    const n = Fa(), t = $e(e, "modelValue"), s = I(() => {
      let l = n.startOfYear(n.date());
      return e.year && (l = n.setYear(l, e.year)), Bn(12).map((u) => {
        const c = n.format(l, "monthShort"), d = n.format(l, "month"), f = !!(!o(u) || e.min && n.isAfter(n.startOfMonth(n.date(e.min)), l) || e.max && n.isAfter(l, n.startOfMonth(n.date(e.max))));
        return l = n.getNextMonth(l), {
          isDisabled: f,
          text: c,
          label: d,
          value: u
        };
      });
    });
    wt(() => {
      t.value = t.value ?? n.getMonth(n.date());
    });
    function o(l) {
      return Array.isArray(e.allowedMonths) && e.allowedMonths.length ? e.allowedMonths.includes(l) : typeof e.allowedMonths == "function" ? e.allowedMonths(l) : !0;
    }
    return me(() => D("div", {
      class: "v-date-picker-months",
      style: {
        height: he(e.height)
      }
    }, [D("div", {
      class: "v-date-picker-months__content"
    }, [s.value.map((l, u) => {
      const c = {
        active: t.value === u,
        ariaLabel: l.label,
        color: t.value === u ? e.color : void 0,
        disabled: l.isDisabled,
        rounded: !0,
        text: l.text,
        variant: t.value === l.value ? "flat" : "text",
        onClick: () => d(u)
      };
      function d(f) {
        if (t.value === f) {
          i("update:modelValue", t.value);
          return;
        }
        t.value = f;
      }
      return r.month?.({
        month: l,
        i: u,
        props: c
      }) ?? C(Te, re({
        key: "month"
      }, c), null);
    })])])), {};
  }
}), th = ee({
  color: String,
  height: [String, Number],
  min: null,
  max: null,
  modelValue: Number,
  allowedYears: [Array, Function]
}, "VDatePickerYears"), Tm = de()({
  name: "VDatePickerYears",
  props: th(),
  directives: {
    vIntersect: qa
  },
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, a) {
    let {
      emit: i,
      slots: r
    } = a;
    const n = Fa(), t = $e(e, "modelValue"), s = fe(!1), o = I(() => {
      const d = n.getYear(n.date());
      let f = d - 100, v = d + 52;
      e.min && (f = n.getYear(n.date(e.min))), e.max && (v = n.getYear(n.date(e.max)));
      let g = n.startOfYear(n.date());
      return g = n.setYear(g, f), Bn(v - f + 1, f).map((h) => {
        const y = n.format(g, "year");
        return g = n.setYear(g, n.getYear(g) + 1), {
          text: y,
          value: h,
          isDisabled: !c(h)
        };
      });
    });
    wt(() => {
      t.value = t.value ?? n.getYear(n.date());
    });
    const l = ps();
    function u() {
      l.el?.scrollIntoView({
        block: "center"
      });
    }
    function c(d) {
      return Array.isArray(e.allowedYears) && e.allowedYears.length ? e.allowedYears.includes(d) : typeof e.allowedYears == "function" ? e.allowedYears(d) : !0;
    }
    return me(() => Je(D("div", {
      class: "v-date-picker-years",
      style: {
        height: he(e.height)
      }
    }, [D("div", {
      class: "v-date-picker-years__content",
      onFocus: () => l.el?.focus(),
      onFocusin: () => s.value = !0,
      onFocusout: () => s.value = !1,
      tabindex: s.value ? -1 : 0
    }, [o.value.map((d, f) => {
      const v = {
        ref: t.value === d.value ? l : void 0,
        active: t.value === d.value,
        color: t.value === d.value ? e.color : void 0,
        rounded: !0,
        text: d.text,
        disabled: d.isDisabled,
        variant: t.value === d.value ? "flat" : "text",
        onClick: () => {
          if (t.value === d.value) {
            i("update:modelValue", t.value);
            return;
          }
          t.value = d.value;
        }
      };
      return r.year?.({
        year: d,
        i: f,
        props: v
      }) ?? C(Te, re({
        key: "month"
      }, v), null);
    })])]), [[qa, {
      handler: u
    }, null, {
      once: !0
    }]])), {};
  }
}), G1 = Fn("v-picker-title"), Nu = ee({
  color: String,
  ...Aa(),
  ...Se(),
  ...Mt(),
  ...ea(),
  ...Un(),
  ...Bs(),
  ...$t(),
  ...Be(),
  ...Qe()
}, "VSheet"), pa = de()({
  name: "VSheet",
  props: Nu(),
  setup(e, a) {
    let {
      slots: i
    } = a;
    const {
      themeClasses: r
    } = ut(e), {
      backgroundColorClasses: n,
      backgroundColorStyles: t
    } = at(() => e.color), {
      borderClasses: s
    } = Ta(e), {
      dimensionStyles: o
    } = Rt(e), {
      elevationClasses: l
    } = ta(e), {
      locationStyles: u
    } = Wn(e), {
      positionClasses: c
    } = Fs(e), {
      roundedClasses: d
    } = _t(e);
    return me(() => C(e.tag, {
      class: ue(["v-sheet", r.value, n.value, s.value, l.value, c.value, d.value, e.class]),
      style: be([t.value, o.value, u.value, e.style])
    }, i)), {};
  }
}), Xs = ee({
  bgColor: String,
  divided: Boolean,
  landscape: Boolean,
  title: String,
  hideHeader: Boolean,
  hideTitle: Boolean,
  ...Nu()
}, "VPicker"), Rn = de()({
  name: "VPicker",
  props: Xs(),
  setup(e, a) {
    let {
      slots: i
    } = a;
    const {
      backgroundColorClasses: r,
      backgroundColorStyles: n
    } = at(() => e.color);
    return me(() => {
      const t = pa.filterProps(e), s = !e.hideTitle && !!(e.title || i.title);
      return C(pa, re(t, {
        color: e.bgColor,
        class: ["v-picker", {
          "v-picker--divided": e.divided,
          "v-picker--landscape": e.landscape,
          "v-picker--with-actions": !!i.actions
        }, e.class],
        style: e.style
      }), {
        default: () => [!e.hideHeader && D("div", {
          key: "header",
          class: ue(["v-picker__header-wrapper", r.value]),
          style: be([n.value])
        }, [s && C(G1, {
          key: "picker-title"
        }, {
          default: () => [i.title?.() ?? e.title]
        }), i.header && D("div", {
          class: "v-picker__header"
        }, [i.header()])]), D("div", {
          class: "v-picker__body"
        }, [i.default?.()]), i.actions && C(je, {
          defaults: {
            VBtn: {
              slim: !0,
              variant: "text"
            }
          }
        }, {
          default: () => [D("div", {
            class: "v-picker__actions"
          }, [i.actions()])]
        })]
      });
    }), {};
  }
}), Y1 = ee({
  // TODO: implement in v3.5
  // calendarIcon: {
  //   type: String,
  //   default: '$calendar',
  // },
  // keyboardIcon: {
  //   type: String,
  //   default: '$edit',
  // },
  // inputMode: {
  //   type: String as PropType<'calendar' | 'keyboard'>,
  //   default: 'calendar',
  // },
  // inputText: {
  //   type: String,
  //   default: '$vuetify.datePicker.input.placeholder',
  // },
  // inputPlaceholder: {
  //   type: String,
  //   default: 'dd/mm/yyyy',
  // },
  header: {
    type: String,
    default: "$vuetify.datePicker.header"
  },
  headerColor: String,
  headerDateFormat: {
    type: String,
    default: "normalDateWithWeekday"
  },
  landscapeHeaderWidth: [Number, String],
  ...Le(Zp(), ["active", "monthText", "yearText"]),
  ...Qp({
    weeksInMonth: "static"
  }),
  ...Le(eh(), ["modelValue"]),
  ...Le(th(), ["modelValue"]),
  ...Xs({
    title: "$vuetify.datePicker.title"
  }),
  modelValue: null
}, "VDatePicker"), ah = de()({
  name: "VDatePicker",
  props: Y1(),
  emits: {
    "update:modelValue": (e) => !0,
    "update:month": (e) => !0,
    "update:year": (e) => !0,
    // 'update:inputMode': (date: any) => true,
    "update:viewMode": (e) => !0
  },
  setup(e, a) {
    let {
      emit: i,
      slots: r
    } = a;
    const n = Fa(), {
      t
    } = nt(), {
      rtlClasses: s
    } = St(), o = $e(e, "modelValue", void 0, ($) => Ze($).map((V) => n.date(V)), ($) => e.multiple ? $ : $[0]), l = $e(e, "viewMode"), {
      minDate: u,
      maxDate: c,
      clampDate: d
    } = Jp(e), f = I(() => {
      const $ = n.date(), V = o.value?.[0] ? n.date(o.value[0]) : d($);
      return V && n.isValid(V) ? V : $;
    }), v = W(() => e.headerColor ?? e.color), g = $e(e, "month"), h = I({
      get: () => Number(g.value ?? n.getMonth(n.startOfMonth(f.value))),
      set: ($) => g.value = $
    }), y = $e(e, "year"), m = I({
      get: () => Number(y.value ?? n.getYear(n.startOfYear(n.setMonth(f.value, h.value)))),
      set: ($) => y.value = $
    }), p = fe(!1), b = I(() => {
      if (e.multiple && o.value.length > 1)
        return t("$vuetify.datePicker.itemsSelected", o.value.length);
      const $ = o.value[0] && n.isValid(o.value[0]) ? n.format(n.date(o.value[0]), e.headerDateFormat) : t(e.header);
      return e.landscape && $.split(" ").length === 3 ? $.replace(" ", `
`) : $;
    }), w = W(() => {
      let $ = n.date();
      return $ = n.setDate($, 1), $ = n.setMonth($, h.value), $ = n.setYear($, m.value), $;
    }), k = W(() => n.format(w.value, "monthAndYear")), S = W(() => n.format(w.value, "monthShort")), _ = W(() => n.format(w.value, "year")), P = W(() => `date-picker-header${p.value ? "-reverse" : ""}-transition`), M = I(() => {
      if (e.disabled) return !0;
      const $ = [];
      if (l.value !== "month")
        $.push("prev-month", "next-month", "prev-year", "next-year");
      else {
        let V = n.date();
        if (V = n.startOfMonth(V), V = n.setMonth(V, h.value), V = n.setYear(V, m.value), u.value) {
          const F = n.addDays(n.startOfMonth(V), -1), z = n.addDays(n.startOfYear(V), -1);
          n.isAfter(u.value, F) && $.push("prev-month"), n.isAfter(u.value, z) && $.push("prev-year");
        }
        if (c.value) {
          const F = n.addDays(n.endOfMonth(V), 1), z = n.addDays(n.endOfYear(V), 1);
          n.isAfter(F, c.value) && $.push("next-month"), n.isAfter(z, c.value) && $.push("next-year");
        }
      }
      return $;
    }), q = I(() => e.allowedYears || H), K = I(() => e.allowedMonths || B);
    function j($, V) {
      const F = e.allowedDates;
      if (typeof F != "function") return !0;
      const z = 1 + vp(n, $, V);
      for (let X = 0; X < z; X++)
        if (F(n.addDays($, X))) return !0;
      return !1;
    }
    function H($) {
      if (typeof e.allowedDates == "function") {
        const V = n.parseISO(`${$}-01-01`);
        return j(V, n.endOfYear(V));
      }
      if (Array.isArray(e.allowedDates) && e.allowedDates.length) {
        for (const V of e.allowedDates)
          if (n.getYear(n.date(V)) === $) return !0;
        return !1;
      }
      return !0;
    }
    function B($) {
      if (typeof e.allowedDates == "function") {
        const V = String($ + 1).padStart(2, "0"), F = n.parseISO(`${m.value}-${V}-01`);
        return j(F, n.endOfMonth(F));
      }
      if (Array.isArray(e.allowedDates) && e.allowedDates.length) {
        for (const V of e.allowedDates)
          if (n.getYear(n.date(V)) === m.value && n.getMonth(n.date(V)) === $) return !0;
        return !1;
      }
      return !0;
    }
    function L() {
      h.value < 11 ? h.value++ : (m.value++, h.value = 0, x()), E();
    }
    function O() {
      h.value > 0 ? h.value-- : (m.value--, h.value = 11, x()), E();
    }
    function U() {
      if (m.value++, c.value) {
        const $ = String(h.value + 1).padStart(2, "0"), V = n.parseISO(`${m.value}-${$}-01`);
        n.isAfter(V, c.value) && (h.value = n.getMonth(c.value));
      }
      x();
    }
    function Z() {
      if (m.value--, u.value) {
        const $ = String(h.value + 1).padStart(2, "0"), V = n.endOfMonth(n.parseISO(`${m.value}-${$}-01`));
        n.isAfter(u.value, V) && (h.value = n.getMonth(u.value));
      }
      x();
    }
    function J() {
      l.value = "month";
    }
    function A() {
      l.value = l.value === "months" ? "month" : "months";
    }
    function T() {
      l.value = l.value === "year" ? "month" : "year";
    }
    function E() {
      l.value === "months" && A();
    }
    function x() {
      l.value === "year" && T();
    }
    return ce(o, ($, V) => {
      const F = Ze(V), z = Ze($);
      if (!z.length) return;
      const X = n.date(F[F.length - 1]), Q = n.date(z[z.length - 1]);
      if (n.isSameDay(X, Q)) return;
      const te = n.getMonth(Q), N = n.getYear(Q);
      te !== h.value && (h.value = te, E()), N !== m.value && (m.value = N, x()), p.value = n.isBefore(X, Q);
    }), me(() => {
      const $ = Rn.filterProps(e), V = Le(Im.filterProps(e), ["viewMode"]), F = Om.filterProps(e), z = Em.filterProps(e), X = Le(Am.filterProps(e), ["modelValue"]), Q = Le(Tm.filterProps(e), ["modelValue"]), te = {
        color: v.value,
        header: b.value,
        transition: P.value
      };
      return C(Rn, re($, {
        color: v.value,
        class: ["v-date-picker", `v-date-picker--${l.value}`, {
          "v-date-picker--show-week": e.showWeek
        }, s.value, e.class],
        style: [{
          "--v-date-picker-landscape-header-width": he(e.landscapeHeaderWidth)
        }, e.style]
      }), {
        title: () => r.title?.() ?? D("div", {
          class: "v-date-picker__title"
        }, [t(e.title)]),
        header: () => r.header ? C(je, {
          defaults: {
            VDatePickerHeader: {
              ...te
            }
          }
        }, {
          default: () => [r.header?.(te)]
        }) : C(Om, re({
          key: "header"
        }, F, te, {
          onClick: l.value !== "month" ? J : void 0
        }), {
          prepend: r.prepend,
          append: r.append
        }),
        default: () => D(pe, null, [C(Im, re(V, {
          disabled: M.value,
          viewMode: l.value,
          text: k.value,
          monthText: S.value,
          yearText: _.value,
          "onClick:next": L,
          "onClick:prev": O,
          "onClick:nextYear": U,
          "onClick:prevYear": Z,
          "onClick:month": A,
          "onClick:year": T
        }), {
          default: r.controls
        }), C(Vo, {
          hideOnLeave: !0
        }, {
          default: () => [l.value === "months" ? C(Am, re({
            key: "date-picker-months"
          }, X, {
            modelValue: h.value,
            "onUpdate:modelValue": [(N) => h.value = N, E],
            min: u.value,
            max: c.value,
            year: m.value,
            allowedMonths: K.value
          }), {
            month: r.month
          }) : l.value === "year" ? C(Tm, re({
            key: "date-picker-years"
          }, Q, {
            modelValue: m.value,
            "onUpdate:modelValue": [(N) => m.value = N, x],
            min: u.value,
            max: c.value,
            allowedYears: q.value
          }), {
            year: r.year
          }) : C(Em, re({
            key: "date-picker-month"
          }, z, {
            modelValue: o.value,
            "onUpdate:modelValue": (N) => o.value = N,
            month: h.value,
            "onUpdate:month": [(N) => h.value = N, E],
            year: m.value,
            "onUpdate:year": [(N) => m.value = N, x],
            min: u.value,
            max: c.value
          }), {
            day: r.day
          })]
        })]),
        actions: r.actions
      });
    }), {};
  }
}), zt = (e, a = 2) => ("" + e).padStart(a, "0"), Lu = (e) => {
  const a = e.getTimezoneOffset(), i = `${zt(Math.abs(a / 60))}:${zt(Math.abs(a % 60))}`;
  let r;
  return a < 0 ? r = `+${i}` : a > 0 ? r = `-${i}` : r = "Z", `${zt(e.getFullYear(), 4)}-${zt(e.getMonth() + 1)}-${zt(e.getDate())}T${zt(e.getHours())}:${zt(e.getMinutes())}:${zt(e.getSeconds())}${r}`;
}, nh = (e) => [`${zt(e.getFullYear(), 4)}-${zt(e.getMonth() + 1)}-${zt(e.getDate())}`, `${zt(e.getHours())}:${zt(e.getMinutes())}`], X1 = (e) => {
  const a = /* @__PURE__ */ new Date(), i = e[0].split("-");
  a.setFullYear(Number(i[0])), a.setMonth(Number(i[1]) - 1), a.setDate(Number(i[2]));
  const r = e[1].split(":");
  return a.setHours(Number(r[0] || "00")), a.setMinutes(Number(r[1] || "00")), a.setSeconds(0), Lu(a);
}, rh = (e) => e ? e.slice(0, 5) : "", Z1 = (e) => e + ":00Z", jm = (e, a, i) => {
  if (!e || !a || !i) return null;
  const r = Number(e);
  if (isNaN(r)) return null;
  const n = Number(a);
  if (isNaN(n) || n < 1 || n > 12) return null;
  const t = Number(i);
  if (isNaN(t) || t < 1 || t > 31) return null;
  const s = /* @__PURE__ */ new Date();
  return s.setFullYear(r), s.setMonth(n - 1), s.setDate(t), s.setHours(0), s.setMinutes(0), s.setSeconds(0), s.setMilliseconds(0), isNaN(s.getTime()) ? null : s;
}, Dm = {}, Mm = (e) => {
  const a = new Intl.DateTimeFormat(e, { year: "numeric", month: "2-digit", day: "2-digit" }), i = a.formatToParts(/* @__PURE__ */ new Date()), r = {
    format: (n) => a.format(n),
    parse: (n) => {
      let t = n, s = "", o = "", l = "";
      for (let v = 0; v < i.length; v++) {
        const g = i[v];
        if (g.type !== "literal") {
          const h = i[v + 1];
          if (h && h.type !== "literal")
            throw console.error("failed to work on keyboard date format", i), new Error("failed to work on keyboard date format");
          let y = t;
          if (h?.type === "literal") {
            const m = t.indexOf(h.value);
            y = t.substring(0, m), t = t.substring(m + h.value.length);
          }
          g.type === "year" && (s = y), g.type === "month" && (o = y), g.type === "day" && (l = y);
        }
      }
      const u = jm(s, o, l);
      if (u) return u;
      const [c, d, f] = n.split("-");
      return jm(c, d, f);
    }
  };
  return Dm[e] || (Dm[e] = r), r;
};
function vt(e, a = null) {
  const i = qe(/* @__PURE__ */ Symbol.for("vuetify:defaults"));
  if (!i) throw new Error("[vjsf] Could not find defaults instance");
  return I(() => {
    const r = i.value?.[e] ?? {};
    return a ? { ...a, ...r } : r;
  });
}
const J1 = {
  __name: "date-picker",
  props: {
    modelValue: {
      /** @type import('vue').PropType<import('../../types.js').VjsfDatePickerNode> */
      type: Object,
      required: !0
    },
    statefulLayout: {
      /** @type import('vue').PropType<import('../../types.js').VjsfStatefulLayout> */
      type: Object,
      required: !0
    }
  },
  setup(e) {
    const a = Jt("vjsf:date-picker");
    Ge({}, "VjsfDatePicker");
    const i = vt("VDatePicker", { hideHeader: !0 }), r = e, n = ie(!1), { compProps: t, localData: s } = mt(W(r, "modelValue"), r.statefulLayout), o = (v) => {
      if (!v) return;
      const g = r.modelValue.layout.format === "date-time" ? Lu(v) : nh(
        /** @type Date */
        /** @type unknown */
        v
      )[0];
      g !== s.value && (a(`apply normalized iso value ${v.toLocaleString()} -> ${g}`), r.statefulLayout.input(r.modelValue, g), n.value = !1);
    }, l = I(() => s.value ? r.modelValue.layout.format === "date-time" ? new Date(
      /** @type {string} */
      s.value
    ) : new Date(X1([s.value, "00:00:00"])) : null), u = I(() => {
      const v = { ...i.value, ...t.value };
      return v.hideActions = !0, l.value && (v.modelValue = l.value), v["onUpdate:modelValue"] = (g) => {
        o(g);
      }, v;
    }), c = ie(), d = () => {
      l.value ? c.value = Mm(r.modelValue.options.locale).format(l.value) : c.value = void 0;
    };
    ce(l, d, { immediate: !0 });
    const f = () => {
      if (c.value) {
        const v = Mm(r.modelValue.options.locale).parse(c.value);
        a(`parsed user input as date ${c.value} -> ${v?.toLocaleString()}`), v ? o(v) : d();
      }
    };
    return (v, g) => (oe(), ye(Ru, {
      "menu-opened": n.value,
      "onUpdate:menuOpened": g[0] || (g[0] = (h) => n.value = h),
      "formatted-value": c.value,
      "onUpdate:formattedValue": g[1] || (g[1] = (h) => c.value = h),
      "model-value": r.modelValue,
      "stateful-layout": e.statefulLayout,
      readonly: !1,
      placeholder: r.modelValue.messages.keyboardDate,
      onBlur: f
    }, {
      "prepend-inner": le(() => [
        C(Y(xe), {
          icon: e.statefulLayout.options.icons.calendar
        }, null, 8, ["icon"])
      ]),
      default: le(() => [
        C(Y(ah), Gt(oa(u.value)), null, 16)
      ]),
      _: 1
    }, 8, ["menu-opened", "formatted-value", "model-value", "stateful-layout", "placeholder"]));
  }
}, Q1 = ee({
  allowedValues: Function,
  ampm: Boolean,
  color: String,
  disabled: Boolean,
  displayedValue: null,
  double: Boolean,
  format: {
    type: Function,
    default: (e) => e
  },
  max: {
    type: Number,
    required: !0
  },
  min: {
    type: Number,
    required: !0
  },
  scrollable: Boolean,
  readonly: Boolean,
  rotate: {
    type: Number,
    default: 0
  },
  step: {
    type: Number,
    default: 1
  },
  modelValue: {
    type: Number
  }
}, "VTimePickerClock"), Rm = de()({
  name: "VTimePickerClock",
  props: Q1(),
  emits: {
    change: (e) => !0,
    input: (e) => !0
  },
  setup(e, a) {
    let {
      emit: i
    } = a;
    const r = ie(null), n = ie(null), t = ie(void 0), s = ie(!1), o = ie(null), l = ie(null), u = Bv((A) => i("change", A), 750), {
      textColorClasses: c,
      textColorStyles: d
    } = kt(() => e.color), {
      backgroundColorClasses: f,
      backgroundColorStyles: v
    } = at(() => e.color), g = I(() => e.max - e.min + 1), h = I(() => e.double ? g.value / 2 : g.value), y = I(() => 360 / h.value), m = I(() => y.value * Math.PI / 180), p = I(() => e.modelValue == null ? e.min : e.modelValue), b = I(() => 0.62), w = I(() => {
      const A = [];
      for (let T = e.min; T <= e.max; T = T + e.step)
        A.push(T);
      return A;
    });
    ce(() => e.modelValue, (A) => {
      t.value = A;
    });
    function k(A) {
      t.value !== A && (t.value = A), i("input", A);
    }
    function S(A) {
      return !e.allowedValues || e.allowedValues(A);
    }
    function _(A) {
      if (!e.scrollable || e.disabled) return;
      A.preventDefault();
      const T = Math.sign(-A.deltaY || 1);
      let E = p.value;
      do
        E = E + T, E = (E - e.min + g.value) % g.value + e.min;
      while (!S(E) && E !== p.value);
      E !== e.displayedValue && k(E), u(E);
    }
    function P(A) {
      return e.double && A - e.min >= h.value;
    }
    function M(A) {
      return P(A) ? b.value : 1;
    }
    function q(A) {
      const T = e.rotate * Math.PI / 180;
      return {
        x: Math.sin((A - e.min) * m.value + T) * M(A),
        y: -Math.cos((A - e.min) * m.value + T) * M(A)
      };
    }
    function K(A, T) {
      const E = (Math.round(A / y.value) + (T ? h.value : 0)) % g.value + e.min;
      return A < 360 - y.value / 2 ? E : T ? e.max - h.value + 1 : e.min;
    }
    function j(A) {
      const {
        x: T,
        y: E
      } = q(A);
      return {
        left: `${Math.round(50 + T * 50)}%`,
        top: `${Math.round(50 + E * 50)}%`
      };
    }
    function H(A, T) {
      const E = T.x - A.x, x = T.y - A.y;
      return Math.sqrt(E * E + x * x);
    }
    function B(A, T) {
      const E = 2 * Math.atan2(T.y - A.y - H(A, T), T.x - A.x);
      return Math.abs(E * 180 / Math.PI);
    }
    function L(A) {
      o.value === null && (o.value = A), l.value = A, k(A);
    }
    function O(A) {
      if (A.preventDefault(), !s.value && A.type !== "click" || !r.value) return;
      const {
        width: T,
        top: E,
        left: x
      } = r.value?.getBoundingClientRect(), {
        width: $
      } = n.value?.getBoundingClientRect() ?? {
        width: 0
      }, {
        clientX: V,
        clientY: F
      } = "touches" in A ? A.touches[0] : A, z = {
        x: T / 2,
        y: -T / 2
      }, X = {
        x: V - x,
        y: E - F
      }, Q = Math.round(B(z, X) - e.rotate + 360) % 360, te = e.double && H(z, X) < ($ + $ * b.value) / 4, N = Math.ceil(15 / y.value);
      let R;
      for (let G = 0; G < N; G++)
        if (R = K(Q + G * y.value, te), S(R) || (R = K(Q - G * y.value, te), S(R))) return L(R);
    }
    function U(A) {
      e.disabled || (A.preventDefault(), window.addEventListener("mousemove", O), window.addEventListener("touchmove", O), window.addEventListener("mouseup", Z), window.addEventListener("touchend", Z), o.value = null, l.value = null, s.value = !0, O(A));
    }
    function Z(A) {
      A.stopPropagation(), J(), s.value = !1, l.value !== null && S(l.value) && i("change", l.value);
    }
    function J() {
      window.removeEventListener("mousemove", O), window.removeEventListener("touchmove", O), window.removeEventListener("mouseup", Z), window.removeEventListener("touchend", Z);
    }
    st(J), me(() => D("div", {
      class: ue([{
        "v-time-picker-clock": !0,
        "v-time-picker-clock--indeterminate": e.modelValue == null,
        "v-time-picker-clock--readonly": e.readonly
      }]),
      onMousedown: U,
      onTouchstart: U,
      onWheel: _,
      ref: r
    }, [D("div", {
      class: "v-time-picker-clock__inner",
      ref: n
    }, [D("div", {
      class: ue([{
        "v-time-picker-clock__hand": !0,
        "v-time-picker-clock__hand--inner": P(e.modelValue)
      }, c.value]),
      style: be([{
        transform: `rotate(${e.rotate + y.value * (p.value - e.min)}deg) scaleY(${M(p.value)})`
      }, d.value])
    }, null), w.value.map((A) => {
      const T = A === p.value;
      return D("div", {
        class: ue([{
          "v-time-picker-clock__item": !0,
          "v-time-picker-clock__item--active": T,
          "v-time-picker-clock__item--disabled": e.disabled || !S(A)
        }, T && f.value]),
        style: be([j(A), T && v.value])
      }, [D("span", null, [e.format(A)])]);
    })])]));
  }
}), e_ = ee({
  active: Boolean,
  color: String,
  disabled: Boolean,
  label: String,
  modelValue: String,
  readonly: Boolean
}, "VTimePickerField"), to = de()({
  name: "VTimePickerField",
  inheritAttrs: !1,
  props: e_(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, a) {
    let {
      emit: i,
      attrs: r
    } = a;
    const {
      textColorClasses: n,
      textColorStyles: t
    } = kt(() => e.color), s = ie(), o = fe(!1);
    function l(u) {
      if (["Backspace", "Delete"].includes(u.key)) {
        u.preventDefault();
        const c = u.target;
        c.value = "", i("update:modelValue", null);
      }
    }
    return me(() => D("div", null, [C(Dt, re({
      ref: s,
      _as: "VTimePickerField",
      autocomplete: "off",
      class: ["v-time-picker-controls__time__field", {
        "v-time-picker-controls__time__field--active": e.active
      }, e.active ? n.value : []],
      style: e.active ? t.value : [],
      disabled: e.disabled,
      variant: "solo-filled",
      inputmode: "numeric",
      hideDetails: !0,
      flat: !0,
      modelValue: e.modelValue ?? (o.value ? "" : "--"),
      "onUpdate:modelValue": (u) => i("update:modelValue", u),
      onKeydown: l,
      onFocus: () => o.value = !0,
      onBlur: () => o.value = !1
    }, r), null), D("div", {
      class: "v-time-picker-controls__field-label"
    }, [e.label])])), Pt({}, s);
  }
});
function Pa(e) {
  let a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2;
  return String(e).padStart(a, "0");
}
function ih(e) {
  return e ? (e - 1) % 12 + 1 : 12;
}
function Mo(e, a) {
  return e % 12 + (a === "pm" ? 12 : 0);
}
function rr(e) {
  const a = e.replaceAll(/\D/g, "");
  return a.length > 0 ? Number(a) : null;
}
function t_(e, a, i) {
  if (i) {
    if (e === 12 && a)
      return {
        value: 1
      };
    if (e === 11 && a)
      return {
        value: 12,
        togglePeriod: !0
      };
    if (e === 12 && !a)
      return {
        value: 11,
        togglePeriod: !0
      };
    if (e === 1 && !a)
      return {
        value: 12
      };
  } else {
    if (e === 23 && a)
      return {
        value: 0
      };
    if (e === 0 && !a)
      return {
        value: 23
      };
  }
  return {
    value: e + (a ? 1 : -1)
  };
}
function Nm(e, a) {
  return e === 59 && a ? 0 : e === 0 && !a ? 59 : e + (a ? 1 : -1);
}
const a_ = ee({
  ampm: Boolean,
  color: String,
  disabled: Boolean,
  hour: [Number, String],
  minute: [Number, String],
  second: [Number, String],
  period: String,
  readonly: Boolean,
  useSeconds: Boolean,
  value: Number,
  viewMode: String
}, "VTimePickerControls"), Lm = de()({
  name: "VTimePickerControls",
  props: a_(),
  emits: {
    "update:period": (e) => !0,
    "update:viewMode": (e) => !0,
    "update:hour": (e) => !0,
    "update:minute": (e) => !0,
    "update:second": (e) => !0
  },
  setup(e, a) {
    let {
      emit: i,
      slots: r
    } = a;
    const {
      t: n
    } = nt(), t = {
      in: (w) => {
        if (w == null || isNaN(Number(w))) return null;
        const k = Number(w);
        return e.ampm ? Pa(ih(k)) : Pa(k);
      },
      out: (w) => {
        if (isNaN(Number(w)) || w == null || w === "") return null;
        const k = typeof w == "string" ? rr(w) : Number(w);
        return k === null ? null : e.ampm ? Mo(k, e.period ?? "am") : Xe(k, 0, 23);
      }
    }, s = $e(e, "hour", void 0, t.in, t.out), o = {
      in: (w) => w != null && !isNaN(Number(w)) ? Pa(`${w}`) : null,
      out: (w) => {
        if (isNaN(Number(w)) || w == null || w === "") return null;
        const k = typeof w == "string" ? rr(w) : Number(w);
        return k !== null ? Xe(k, 0, 59) : null;
      }
    }, l = $e(e, "minute", void 0, o.in, o.out), u = $e(e, "second", void 0, o.in, o.out);
    function c(w) {
      if (!["ArrowUp", "ArrowDown"].includes(w.key)) return;
      w.preventDefault(), w.stopPropagation();
      const k = Number(s.value ?? 0), S = e.ampm ? e.period ?? "am" : null, {
        value: _,
        togglePeriod: P
      } = t_(k, w.key === "ArrowUp", S);
      s.value = Pa(_), P && i("update:period", e.period === "am" ? "pm" : "am");
    }
    function d(w) {
      ["ArrowUp", "ArrowDown"].includes(w.key) && (w.preventDefault(), w.stopPropagation(), l.value = Nm(Number(l.value), w.key === "ArrowUp"));
    }
    function f(w) {
      ["ArrowUp", "ArrowDown"].includes(w.key) && (w.preventDefault(), w.stopPropagation(), u.value = Nm(Number(u.value), w.key === "ArrowUp"));
    }
    function v(w, k, S) {
      return (_) => {
        if (!_.data) return;
        const P = _.target, {
          value: M,
          selectionStart: q,
          selectionEnd: K
        } = P ?? {};
        if (rr(_.data) === null) {
          _.preventDefault();
          return;
        }
        const j = M ? M.slice(0, q) + _.data + M.slice(K) : _.data;
        if (j.length > 2) {
          if (q === K && K === 0 && _.data.trim().startsWith("0")) {
            _.preventDefault(), P.value = j.trim().substring(0, 2), S(P.value), _.data.trim().length === 1 && P.setSelectionRange(1, 1);
            return;
          }
          if (q === K && K === 1 && M.startsWith("0")) {
            _.preventDefault(), P.value = j.trim().substring(0, 2), S(P.value);
            return;
          }
          const B = e.viewMode === "hour" ? e.ampm ? 12 : 23 : 59;
          if (rr(j) > B) {
            _.preventDefault(), P.value = Pa(String(rr(_.data)).substring(0, 2)), S(P.value);
            return;
          }
        }
        const H = w(j);
        k(H) && _.preventDefault();
      };
    }
    const g = ie(), h = ie(), y = ie();
    ce(() => e.viewMode, (w, k) => {
      switch (k) {
        case "hour":
          g.value.blur();
          break;
        case "minute":
          h.value.blur();
          break;
        case "second":
          y.value.blur();
          break;
      }
    });
    const m = v(t.out, (w) => t.in(w) === s.value, (w) => s.value = w), p = v(o.out, (w) => o.in(w) === l.value, (w) => l.value = w), b = v(o.out, (w) => o.in(w) === u.value, (w) => u.value = w);
    return me(() => D("div", {
      class: "v-time-picker-controls"
    }, [D("div", {
      class: ue({
        "v-time-picker-controls__time": !0,
        "v-time-picker-controls__time--with-ampm": e.ampm,
        "v-time-picker-controls__time--with-seconds": e.useSeconds
      })
    }, [C(to, {
      ref: g,
      active: e.viewMode === "hour",
      color: e.color,
      disabled: e.disabled,
      label: n("$vuetify.timePicker.hour"),
      modelValue: s.value,
      "onUpdate:modelValue": (w) => s.value = w,
      onKeydown: c,
      onBeforeinput: m,
      onFocus: () => i("update:viewMode", "hour")
    }, null), D("span", {
      class: "v-time-picker-controls__time__separator"
    }, [Fe(":")]), C(to, {
      ref: h,
      active: e.viewMode === "minute",
      color: e.color,
      disabled: e.disabled,
      label: n("$vuetify.timePicker.minute"),
      modelValue: l.value,
      "onUpdate:modelValue": (w) => l.value = w,
      onKeydown: d,
      onBeforeinput: p,
      onFocus: () => i("update:viewMode", "minute")
    }, null), e.useSeconds && D("span", {
      key: "secondsDivider",
      class: "v-time-picker-controls__time__separator"
    }, [Fe(":")]), e.useSeconds && C(to, {
      key: "secondsVal",
      ref: y,
      active: e.viewMode === "second",
      color: e.color,
      disabled: e.disabled,
      label: n("$vuetify.timePicker.second"),
      modelValue: u.value,
      "onUpdate:modelValue": (w) => u.value = w,
      onKeydown: f,
      onBeforeinput: b,
      onFocus: () => i("update:viewMode", "second")
    }, null), e.ampm && D("div", {
      class: "v-time-picker-controls__ampm"
    }, [C(Te, {
      active: e.period === "am",
      color: e.period === "am" ? e.color : void 0,
      class: ue({
        "v-time-picker-controls__ampm__am": !0,
        "v-time-picker-controls__ampm__btn": !0,
        "v-time-picker-controls__ampm__btn__active": e.period === "am"
      }),
      disabled: e.disabled,
      text: n("$vuetify.timePicker.am"),
      variant: e.disabled && e.period === "am" ? "elevated" : "tonal",
      onClick: () => e.period !== "am" ? i("update:period", "am") : null
    }, null), C(Te, {
      active: e.period === "pm",
      color: e.period === "pm" ? e.color : void 0,
      class: ue({
        "v-time-picker-controls__ampm__pm": !0,
        "v-time-picker-controls__ampm__btn": !0,
        "v-time-picker-controls__ampm__btn__active": e.period === "pm"
      }),
      disabled: e.disabled,
      text: n("$vuetify.timePicker.pm"),
      variant: e.disabled && e.period === "pm" ? "elevated" : "tonal",
      onClick: () => e.period !== "pm" ? i("update:period", "pm") : null
    }, null)])])])), {};
  }
}), n_ = Bn(24), sh = Bn(12), r_ = sh.map((e) => e + 12);
Bn(60);
const i_ = ee({
  allowedHours: [Function, Array],
  allowedMinutes: [Function, Array],
  allowedSeconds: [Function, Array],
  disabled: Boolean,
  format: {
    type: String,
    default: "ampm"
  },
  max: String,
  min: String,
  viewMode: {
    type: String,
    default: "hour"
  },
  period: {
    type: String,
    default: "am",
    validator: (e) => ["am", "pm"].includes(e)
  },
  modelValue: null,
  readonly: Boolean,
  scrollable: Boolean,
  useSeconds: Boolean,
  variant: {
    type: String,
    default: "dial"
  },
  ...Le(Xs({
    title: "$vuetify.timePicker.title"
  }), ["landscape"]),
  ...Kt()
}, "VTimePicker"), lh = de()({
  name: "VTimePicker",
  props: i_(),
  emits: {
    "update:hour": (e) => !0,
    "update:minute": (e) => !0,
    "update:period": (e) => !0,
    "update:second": (e) => !0,
    "update:modelValue": (e) => !0,
    "update:viewMode": (e) => !0
  },
  setup(e, a) {
    let {
      emit: i,
      slots: r
    } = a;
    const {
      t: n
    } = nt(), {
      densityClasses: t
    } = Qt(e), s = ie(null), o = ie(null), l = ie(null), u = ie(null), c = ie(null), d = ie(null), f = $e(e, "period", "am"), v = $e(e, "viewMode", "hour"), g = ie(null), h = ie(null), y = I(() => {
      let j;
      if (e.allowedHours instanceof Array ? j = (L) => e.allowedHours.includes(L) : j = e.allowedHours, !e.min && !e.max) return j;
      const H = e.min ? Number(e.min.split(":")[0]) : 0, B = e.max ? Number(e.max.split(":")[0]) : 23;
      return (L) => L >= Number(H) && L <= Number(B) && (!j || j(L));
    }), m = I(() => {
      let j;
      const H = !y.value || s.value === null || y.value(s.value);
      if (e.allowedMinutes instanceof Array ? j = (A) => e.allowedMinutes.includes(A) : j = e.allowedMinutes, !e.min && !e.max)
        return H ? j : () => !1;
      const [B, L] = e.min ? e.min.split(":").map(Number) : [0, 0], [O, U] = e.max ? e.max.split(":").map(Number) : [23, 59], Z = B * 60 + Number(L), J = O * 60 + Number(U);
      return (A) => {
        const T = 60 * s.value + A;
        return T >= Z && T <= J && H && (!j || j(A));
      };
    }), p = I(() => {
      let j;
      const B = (!y.value || s.value === null || y.value(s.value)) && (!m.value || o.value === null || m.value(o.value));
      if (e.allowedSeconds instanceof Array ? j = (x) => e.allowedSeconds.includes(x) : j = e.allowedSeconds, !e.min && !e.max)
        return B ? j : () => !1;
      const [L, O, U] = e.min ? e.min.split(":").map(Number) : [0, 0, 0], [Z, J, A] = e.max ? e.max.split(":").map(Number) : [23, 59, 59], T = L * 3600 + O * 60 + Number(U || 0), E = Z * 3600 + J * 60 + Number(A || 0);
      return (x) => {
        const $ = 3600 * s.value + 60 * o.value + x;
        return $ >= T && $ <= E && B && (!j || j(x));
      };
    }), b = I(() => e.format === "ampm"), w = W(() => e.modelValue !== null && s.value === null && o.value === null && (!e.useSeconds || l.value === null));
    function k() {
      const j = S();
      j !== null && j !== e.modelValue && i("update:modelValue", j), w.value && i("update:modelValue", null);
    }
    ce(s, k), ce(o, k), ce(l, k), ce(() => e.period, (j) => M(j)), ce(() => e.modelValue, (j) => _(j)), ce(() => e.useSeconds, (j, H) => {
      H && !j && v.value === "second" && (v.value = "minute"), !j && l.value !== null && (l.value = null);
    }), ua(() => {
      _(e.modelValue);
    });
    function S() {
      return s.value != null && o.value != null && (!e.useSeconds || l.value != null) ? `${Pa(s.value)}:${Pa(o.value)}` + (e.useSeconds ? `:${Pa(l.value)}` : "") : null;
    }
    function _(j) {
      if (j == null || j === "")
        s.value = null, o.value = null, l.value = null;
      else if (j instanceof Date)
        s.value = j.getHours(), o.value = j.getMinutes(), l.value = j.getSeconds();
      else {
        const [H, , B, , L, O] = j.trim().toLowerCase().match(/^(\d+):(\d+)(:(\d+))?([ap]m)?$/) || new Array(6);
        s.value = O ? Mo(parseInt(H, 10), O) : parseInt(H, 10), o.value = parseInt(B, 10), l.value = parseInt(L || 0, 10);
      }
      f.value = s.value == null || s.value < 12 ? "am" : "pm";
    }
    function P(j, H) {
      const B = y.value;
      if (!B) return H;
      const L = b.value ? H < 12 ? sh : r_ : n_;
      return ((L.find((U) => B((U + H) % L.length + L[0])) || 0) + H) % L.length + L[0];
    }
    function M(j) {
      if (f.value = j, s.value != null) {
        const H = s.value + (f.value === "am" ? -12 : 12);
        s.value = P("hour", H);
      }
      return i("update:period", j), k(), !0;
    }
    function q(j) {
      v.value === "hour" ? s.value = b.value ? Mo(j, f.value) : j : v.value === "minute" ? o.value = j : l.value = j;
    }
    function K(j) {
      switch (v.value || "hour") {
        case "hour":
          i("update:hour", j);
          break;
        case "minute":
          i("update:minute", j);
          break;
        case "second":
          i("update:second", j);
          break;
      }
      const H = s.value !== null && o.value !== null && (e.useSeconds ? l.value !== null : !0);
      v.value === "hour" ? v.value = "minute" : e.useSeconds && v.value === "minute" && (v.value = "second"), !(s.value === u.value && o.value === c.value && (!e.useSeconds || l.value === d.value) || S() === null) && (u.value = s.value, c.value = o.value, e.useSeconds && (d.value = l.value), H && k());
    }
    me(() => {
      const j = Le(Rn.filterProps(e), ["hideHeader"]), H = Lm.filterProps(e), B = Rm.filterProps(Le(e, ["format", "modelValue", "min", "max"]));
      return C(Rn, re(j, {
        color: void 0,
        class: ["v-time-picker", `v-time-picker--variant-${e.variant}`, e.class, t.value],
        hideHeader: e.hideHeader && e.variant !== "input",
        style: e.style
      }), {
        title: () => r.title?.() ?? D("div", {
          class: "v-time-picker__title"
        }, [n(e.title)]),
        header: () => C(Lm, re(H, {
          ampm: b.value,
          hour: s.value,
          minute: o.value,
          period: f.value,
          second: l.value,
          viewMode: v.value,
          "onUpdate:hour": (L) => s.value = L,
          "onUpdate:minute": (L) => o.value = L,
          "onUpdate:period": (L) => M(L),
          "onUpdate:second": (L) => l.value = L,
          "onUpdate:viewMode": (L) => v.value = L,
          ref: g
        }), null),
        default: () => C(Rm, re(B, {
          allowedValues: v.value === "hour" ? y.value : v.value === "minute" ? m.value : p.value,
          double: v.value === "hour" && !b.value,
          format: v.value === "hour" ? b.value ? ih : (L) => L : (L) => Pa(L, 2),
          max: v.value === "hour" ? b.value && f.value === "am" ? 11 : 23 : 59,
          min: v.value === "hour" && b.value && f.value === "pm" ? 12 : 0,
          size: 20,
          step: v.value === "hour" ? 1 : 5,
          modelValue: v.value === "hour" ? s.value : v.value === "minute" ? o.value : l.value,
          onChange: K,
          onInput: q,
          ref: h
        }), null),
        actions: r.actions
      });
    });
  }
}), s_ = {
  __name: "time-picker",
  props: {
    modelValue: {
      /** @type import('vue').PropType<import('../../types.js').VjsfDatePickerNode> */
      type: Object,
      required: !0
    },
    statefulLayout: {
      /** @type import('vue').PropType<import('../../types.js').VjsfStatefulLayout> */
      type: Object,
      required: !0
    }
  },
  setup(e) {
    Ge({}, "VjsfTimePicker");
    const a = vt("VTimePicker", { title: "" }), i = e, r = Fa(), { compProps: n, localData: t } = mt(W(i, "modelValue"), i.statefulLayout), s = I(() => {
      const o = { ...a.value, ...n.value };
      return o.format !== "24hr" && (o["ampm-in-title"] = !0), t.value && (o.modelValue = rh(t.value)), o;
    });
    return (o, l) => (oe(), ye(Ru, {
      "model-value": i.modelValue,
      "stateful-layout": e.statefulLayout,
      "formatted-value": s.value.modelValue && Y(r).format("2010-04-13T" + s.value.modelValue, "fullTime")
    }, {
      "prepend-inner": le(() => [
        C(Y(xe), {
          icon: e.statefulLayout.options.icons.clock
        }, null, 8, ["icon"])
      ]),
      default: le(() => [
        C(Y(pa), null, {
          default: le(() => [
            C(Y(je), { defaults: { global: { density: "default" } } }, {
              default: le(() => [
                C(Y(lh), re(s.value, {
                  "onUpdate:modelValue": l[0] || (l[0] = (u) => {
                    e.statefulLayout.input(i.modelValue, u && Y(Z1)(u));
                  })
                }), null, 16)
              ]),
              _: 1
            })
          ]),
          _: 1
        })
      ]),
      _: 1
    }, 8, ["model-value", "stateful-layout", "formatted-value"]));
  }
}, qu = /* @__PURE__ */ Symbol.for("vuetify:v-tabs"), oh = ee({
  fixed: Boolean,
  sliderColor: String,
  sliderTransition: String,
  sliderTransitionDuration: [String, Number],
  hideSlider: Boolean,
  inset: Boolean,
  direction: {
    type: String,
    default: "horizontal"
  },
  ...Le(xp({
    selectedClass: "v-tab--selected",
    variant: "text"
  }), ["active", "block", "flat", "location", "position", "symbol"])
}, "VTab"), kr = de()({
  name: "VTab",
  props: oh(),
  setup(e, a) {
    let {
      slots: i,
      attrs: r
    } = a;
    const {
      textColorClasses: n,
      textColorStyles: t
    } = kt(() => e.sliderColor), {
      backgroundColorClasses: s,
      backgroundColorStyles: o
    } = at(() => e.sliderColor), l = ie(), u = ie(), c = I(() => e.direction === "horizontal"), d = I(() => l.value?.group?.isSelected.value ?? !1);
    function f(y, m) {
      return {
        opacity: [0, 1]
      };
    }
    function v(y, m) {
      return e.direction === "vertical" ? {
        transform: ["scaleY(0)", "scaleY(1)"]
      } : {
        transform: ["scaleX(0)", "scaleX(1)"]
      };
    }
    function g(y, m) {
      const p = m.getBoundingClientRect(), b = y.getBoundingClientRect(), w = c.value ? "x" : "y", k = c.value ? "X" : "Y", S = c.value ? "right" : "bottom", _ = c.value ? "width" : "height", P = p[w], M = b[w], q = P > M ? p[S] - b[S] : p[w] - b[w], K = Math.sign(q) > 0 ? c.value ? "right" : "bottom" : Math.sign(q) < 0 ? c.value ? "left" : "top" : "center", H = (Math.abs(q) + (Math.sign(q) < 0 ? p[_] : b[_])) / Math.max(p[_], b[_]) || 0, B = p[_] / b[_] || 0, L = 1.5;
      return {
        transform: [`translate${k}(${q}px) scale${k}(${B})`, `translate${k}(${q / L}px) scale${k}(${(H - 1) / L + 1})`, "none"],
        transformOrigin: Array(3).fill(K)
      };
    }
    function h(y) {
      let {
        value: m
      } = y;
      if (m) {
        const p = l.value?.$el.parentElement?.querySelector(".v-tab--selected .v-tab__slider"), b = u.value;
        if (!p || !b) return;
        const w = getComputedStyle(p).color, k = {
          fade: f,
          grow: v,
          shift: g
        }[e.sliderTransition ?? "shift"] ?? g, S = Number(e.sliderTransitionDuration) || ({
          fade: 400,
          grow: 350,
          shift: 225
        }[e.sliderTransition ?? "shift"] ?? 225);
        _a(b, {
          backgroundColor: [w, "currentcolor"],
          ...k(b, p)
        }, {
          duration: S,
          easing: hr
        });
      }
    }
    return me(() => {
      const y = Te.filterProps(e);
      return C(Te, re({
        symbol: qu,
        ref: l,
        class: ["v-tab", e.class, d.value && e.inset ? s.value : []],
        style: [e.style, d.value && e.inset ? o.value : []],
        tabindex: d.value ? 0 : -1,
        role: "tab",
        "aria-selected": String(d.value),
        active: !1
      }, y, r, {
        block: e.fixed,
        maxWidth: e.fixed ? 300 : void 0,
        "onGroup:selected": h
      }), {
        ...i,
        default: () => D(pe, null, [i.default?.() ?? e.text, !e.hideSlider && D("div", {
          ref: u,
          class: ue(["v-tab__slider", n.value]),
          style: be(t.value)
        }, null)])
      });
    }), Pt({}, l);
  }
}), l_ = (e) => {
  const {
    touchstartX: a,
    touchendX: i,
    touchstartY: r,
    touchendY: n
  } = e, t = 0.5, s = 16;
  e.offsetX = i - a, e.offsetY = n - r, Math.abs(e.offsetY) < t * Math.abs(e.offsetX) && (e.left && i < a - s && e.left(e), e.right && i > a + s && e.right(e)), Math.abs(e.offsetX) < t * Math.abs(e.offsetY) && (e.up && n < r - s && e.up(e), e.down && n > r + s && e.down(e));
};
function o_(e, a) {
  const i = e.changedTouches[0];
  a.touchstartX = i.clientX, a.touchstartY = i.clientY, a.start?.({
    originalEvent: e,
    ...a
  });
}
function u_(e, a) {
  const i = e.changedTouches[0];
  a.touchendX = i.clientX, a.touchendY = i.clientY, a.end?.({
    originalEvent: e,
    ...a
  }), l_(a);
}
function c_(e, a) {
  const i = e.changedTouches[0];
  a.touchmoveX = i.clientX, a.touchmoveY = i.clientY, a.move?.({
    originalEvent: e,
    ...a
  });
}
function d_() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const a = {
    touchstartX: 0,
    touchstartY: 0,
    touchendX: 0,
    touchendY: 0,
    touchmoveX: 0,
    touchmoveY: 0,
    offsetX: 0,
    offsetY: 0,
    left: e.left,
    right: e.right,
    up: e.up,
    down: e.down,
    start: e.start,
    move: e.move,
    end: e.end
  };
  return {
    touchstart: (i) => o_(i, a),
    touchend: (i) => u_(i, a),
    touchmove: (i) => c_(i, a)
  };
}
function f_(e, a) {
  const i = a.value, r = i?.parent ? e.parentElement : e, n = i?.options ?? {
    passive: !0
  }, t = a.instance?.$.uid;
  if (!r || t === void 0) return;
  const s = d_(a.value);
  r._touchHandlers = r._touchHandlers ?? /* @__PURE__ */ Object.create(null), r._touchHandlers[t] = s, Lv(s).forEach((o) => {
    r.addEventListener(o, s[o], n);
  });
}
function m_(e, a) {
  const i = a.value?.parent ? e.parentElement : e, r = a.instance?.$.uid;
  if (!i?._touchHandlers || r === void 0) return;
  const n = i._touchHandlers[r];
  Lv(n).forEach((t) => {
    i.removeEventListener(t, n[t]);
  }), delete i._touchHandlers[r];
}
const Ro = {
  mounted: f_,
  unmounted: m_
}, uh = /* @__PURE__ */ Symbol.for("vuetify:v-window"), ch = /* @__PURE__ */ Symbol.for("vuetify:v-window-group"), zu = ee({
  continuous: Boolean,
  nextIcon: {
    type: [Boolean, String, Function, Object],
    default: "$next"
  },
  prevIcon: {
    type: [Boolean, String, Function, Object],
    default: "$prev"
  },
  reverse: Boolean,
  showArrows: {
    type: [Boolean, String],
    validator: (e) => typeof e == "boolean" || e === "hover"
  },
  verticalArrows: [Boolean, String],
  touch: {
    type: [Object, Boolean],
    default: void 0
  },
  direction: {
    type: String,
    default: "horizontal"
  },
  modelValue: null,
  disabled: Boolean,
  selectedClass: {
    type: String,
    default: "v-window-item--active"
  },
  // TODO: mandatory should probably not be exposed but do this for now
  mandatory: {
    type: [Boolean, String],
    default: "force"
  },
  crossfade: Boolean,
  transitionDuration: Number,
  ...Se(),
  ...Be(),
  ...Qe()
}, "VWindow"), Nn = de()({
  name: "VWindow",
  directives: {
    vTouch: Ro
  },
  props: zu(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, a) {
    let {
      slots: i
    } = a;
    const {
      themeClasses: r
    } = ut(e), {
      isRtl: n
    } = St(), {
      t
    } = nt(), s = Hn(e, ch), o = ie(), l = I(() => n.value ? !e.reverse : e.reverse), u = fe(!1), c = I(() => {
      if (e.crossfade)
        return "v-window-crossfade-transition";
      const w = e.direction === "vertical" ? "y" : "x", S = (l.value ? !u.value : u.value) ? "-reverse" : "";
      return `v-window-${w}${S}-transition`;
    }), d = fe(0), f = ie(void 0), v = I(() => s.items.value.findIndex((w) => s.selected.value.includes(w.id)));
    ce(v, (w, k) => {
      let S;
      const _ = {
        left: 0,
        top: 0
      };
      et && k >= 0 && (S = gu(o.value), _.left = S?.scrollLeft, _.top = S?.scrollTop);
      const P = s.items.value.length, M = P - 1;
      P <= 2 ? u.value = w < k : w === M && k === 0 ? u.value = !1 : w === 0 && k === M ? u.value = !0 : u.value = w < k, Ee(() => {
        if (!et || !S) return;
        S.scrollTop !== _.top && S.scrollTo({
          ..._,
          behavior: "instant"
        }), requestAnimationFrame(() => {
          if (!S) return;
          S.scrollTop !== _.top && S.scrollTo({
            ..._,
            behavior: "instant"
          });
        });
      });
    }, {
      flush: "sync"
    }), ht(uh, {
      transition: c,
      isReversed: u,
      transitionCount: d,
      transitionHeight: f,
      rootRef: o
    });
    const g = W(() => e.continuous || v.value !== 0), h = W(() => e.continuous || v.value !== s.items.value.length - 1);
    function y() {
      g.value && s.prev();
    }
    function m() {
      h.value && s.next();
    }
    const p = I(() => {
      const w = [], k = {
        icon: n.value ? e.nextIcon : e.prevIcon,
        class: `v-window__${l.value ? "right" : "left"}`,
        onClick: s.prev,
        "aria-label": t("$vuetify.carousel.prev")
      };
      w.push(g.value ? i.prev ? i.prev({
        props: k
      }) : C(Te, k, null) : D("div", null, null));
      const S = {
        icon: n.value ? e.prevIcon : e.nextIcon,
        class: `v-window__${l.value ? "left" : "right"}`,
        onClick: s.next,
        "aria-label": t("$vuetify.carousel.next")
      };
      return w.push(h.value ? i.next ? i.next({
        props: S
      }) : C(Te, S, null) : D("div", null, null)), w;
    }), b = I(() => e.touch === !1 ? e.touch : {
      ...{
        left: () => {
          l.value ? y() : m();
        },
        right: () => {
          l.value ? m() : y();
        },
        start: (k) => {
          let {
            originalEvent: S
          } = k;
          S.stopPropagation();
        }
      },
      ...e.touch === !0 ? {} : e.touch
    });
    return me(() => Je(C(e.tag, {
      ref: o,
      class: ue(["v-window", {
        "v-window--show-arrows-on-hover": e.showArrows === "hover",
        "v-window--vertical-arrows": !!e.verticalArrows,
        "v-window--crossfade": !!e.crossfade
      }, r.value, e.class]),
      style: be([e.style, {
        "--v-window-transition-duration": cn() ? null : he(e.transitionDuration, "ms")
      }])
    }, {
      default: () => [D("div", {
        class: "v-window__container",
        style: {
          height: f.value
        }
      }, [i.default?.({
        group: s
      }), e.showArrows !== !1 && D("div", {
        class: ue(["v-window__controls", {
          "v-window__controls--left": e.verticalArrows === "left" || e.verticalArrows === !0
        }, {
          "v-window__controls--right": e.verticalArrows === "right"
        }])
      }, [p.value])]), i.additional?.({
        group: s
      })]
    }), [[Ro, b.value]])), {
      group: s
    };
  }
}), v_ = ee({
  ...Le(zu(), ["continuous", "nextIcon", "prevIcon", "showArrows", "touch", "mandatory"])
}, "VTabsWindow"), dh = de()({
  name: "VTabsWindow",
  props: v_(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, a) {
    let {
      slots: i
    } = a;
    const r = qe(qu, null), n = $e(e, "modelValue"), t = I({
      get() {
        return n.value != null || !r ? n.value : r.items.value.find((s) => r.selected.value.includes(s.id))?.value;
      },
      set(s) {
        n.value = s;
      }
    });
    return me(() => {
      const s = Nn.filterProps(e);
      return C(Nn, re({
        _as: "VTabsWindow"
      }, s, {
        modelValue: t.value,
        "onUpdate:modelValue": (o) => t.value = o,
        class: ["v-tabs-window", e.class],
        style: e.style,
        mandatory: !1,
        touch: !1
      }), i);
    }), {};
  }
});
function fh() {
  const e = fe(!1);
  return ua(() => {
    window.requestAnimationFrame(() => {
      e.value = !0;
    });
  }), {
    ssrBootStyles: W(() => e.value ? void 0 : {
      transition: "none !important"
    }),
    isBooted: Uo(e)
  };
}
const Bu = ee({
  reverseTransition: {
    type: [Boolean, String],
    default: void 0
  },
  transition: {
    type: [Boolean, String],
    default: void 0
  },
  ...Se(),
  ...Rr(),
  ...Iu()
}, "VWindowItem"), Ln = de()({
  name: "VWindowItem",
  directives: {
    vTouch: Ro
  },
  props: Bu(),
  emits: {
    "group:selected": (e) => !0
  },
  setup(e, a) {
    let {
      slots: i
    } = a;
    const r = qe(uh), n = jn(e, ch), {
      isBooted: t
    } = fh();
    if (!r || !n) throw new Error("[Vuetify] VWindowItem must be used inside VWindow");
    const s = fe(!1), o = I(() => t.value && (r.isReversed.value ? e.reverseTransition !== !1 : e.transition !== !1));
    function l() {
      !s.value || !r || (s.value = !1, r.transitionCount.value > 0 && (r.transitionCount.value -= 1, r.transitionCount.value === 0 && (r.transitionHeight.value = void 0)));
    }
    function u() {
      s.value || !r || (s.value = !0, r.transitionCount.value === 0 && (r.transitionHeight.value = he(r.rootRef.value?.clientHeight)), r.transitionCount.value += 1);
    }
    function c() {
      l();
    }
    function d(g) {
      s.value && Ee(() => {
        !o.value || !s.value || !r || (r.transitionHeight.value = he(g.clientHeight));
      });
    }
    const f = I(() => {
      const g = r.isReversed.value ? e.reverseTransition : e.transition;
      return o.value ? {
        name: typeof g != "string" ? r.transition.value : g,
        onBeforeEnter: u,
        onAfterEnter: l,
        onEnterCancelled: c,
        onBeforeLeave: u,
        onAfterLeave: l,
        onLeaveCancelled: c,
        onEnter: d
      } : !1;
    }), {
      hasContent: v
    } = Ou(e, n.isSelected);
    return me(() => C(Wt, {
      transition: f.value,
      disabled: !t.value
    }, {
      default: () => [Je(D("div", {
        class: ue(["v-window-item", n.selectedClass.value, e.class]),
        style: be(e.style)
      }, [v.value && i.default?.()]), [[ya, n.isSelected.value]])]
    })), {
      groupItem: n
    };
  }
}), p_ = ee({
  ...Bu()
}, "VTabsWindowItem"), No = de()({
  name: "VTabsWindowItem",
  props: p_(),
  setup(e, a) {
    let {
      slots: i
    } = a;
    return me(() => {
      const r = Ln.filterProps(e);
      return C(Ln, re({
        _as: "VTabsWindowItem"
      }, r, {
        class: ["v-tabs-window-item", e.class],
        style: e.style
      }), i);
    }), {};
  }
});
function h_(e) {
  let {
    selectedElement: a,
    containerElement: i,
    isRtl: r,
    isHorizontal: n
  } = e;
  const t = wr(n, i), s = mh(n, r, i), o = wr(n, a), l = vh(n, a), u = o * 0.4;
  return s > l ? l - u : s + t < l + o ? l - t + o + u : s;
}
function y_(e) {
  let {
    selectedElement: a,
    containerElement: i,
    isHorizontal: r
  } = e;
  const n = wr(r, i), t = vh(r, a), s = wr(r, a);
  return t - n / 2 + s / 2;
}
function qm(e, a) {
  return a?.[e ? "scrollWidth" : "scrollHeight"] || 0;
}
function g_(e, a) {
  return a?.[e ? "clientWidth" : "clientHeight"] || 0;
}
function mh(e, a, i) {
  if (!i)
    return 0;
  const {
    scrollLeft: r,
    offsetWidth: n,
    scrollWidth: t
  } = i;
  return e ? a ? t - n + r : r : i.scrollTop;
}
function wr(e, a) {
  return a?.[e ? "offsetWidth" : "offsetHeight"] || 0;
}
function vh(e, a) {
  return a?.[e ? "offsetLeft" : "offsetTop"] || 0;
}
const ph = /* @__PURE__ */ Symbol.for("vuetify:v-slide-group"), Fu = ee({
  centerActive: Boolean,
  scrollToActive: {
    type: Boolean,
    default: !0
  },
  contentClass: null,
  direction: {
    type: String,
    default: "horizontal"
  },
  symbol: {
    type: null,
    default: ph
  },
  nextIcon: {
    type: Pe,
    default: "$next"
  },
  prevIcon: {
    type: Pe,
    default: "$prev"
  },
  showArrows: {
    type: [Boolean, String],
    validator: (e) => typeof e == "boolean" || ["always", "desktop", "mobile", "never"].includes(e)
  },
  ...Se(),
  ...ap({
    mobile: null
  }),
  ...Be(),
  ...Mr({
    selectedClass: "v-slide-group-item--active"
  })
}, "VSlideGroup"), _s = de()({
  name: "VSlideGroup",
  props: Fu(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, a) {
    let {
      slots: i
    } = a;
    const {
      isRtl: r
    } = St(), {
      displayClasses: n,
      mobile: t
    } = Dr(e), s = Hn(e, e.symbol), o = fe(!1), l = fe(0), u = fe(0), c = fe(0), d = I(() => e.direction === "horizontal"), {
      resizeRef: f,
      contentRect: v
    } = fn(), {
      resizeRef: g,
      contentRect: h
    } = fn(), y = iS(), m = I(() => ({
      container: f.el,
      duration: 200,
      easing: "easeOutQuart"
    })), p = I(() => s.selected.value.length ? s.items.value.findIndex((E) => E.id === s.selected.value[0]) : -1), b = I(() => s.selected.value.length ? s.items.value.findIndex((E) => E.id === s.selected.value[s.selected.value.length - 1]) : -1);
    if (et) {
      let E = -1;
      ce(() => [s.selected.value, v.value, h.value, d.value], () => {
        cancelAnimationFrame(E), E = requestAnimationFrame(() => {
          if (v.value && h.value) {
            const x = d.value ? "width" : "height";
            u.value = v.value[x], c.value = h.value[x], o.value = u.value + 1 < c.value;
          }
          if (e.scrollToActive && p.value >= 0 && g.el) {
            const x = g.el.children[b.value];
            k(x, e.centerActive);
          }
        });
      });
    }
    const w = fe(!1);
    function k(E, x) {
      let $ = 0;
      x ? $ = y_({
        containerElement: f.el,
        isHorizontal: d.value,
        selectedElement: E
      }) : $ = h_({
        containerElement: f.el,
        isHorizontal: d.value,
        isRtl: r.value,
        selectedElement: E
      }), S($);
    }
    function S(E) {
      if (!et || !f.el) return;
      const x = wr(d.value, f.el), $ = mh(d.value, r.value, f.el);
      if (!(qm(d.value, f.el) <= x || // Prevent scrolling by only a couple of pixels, which doesn't look smooth
      Math.abs(E - $) < 16)) {
        if (d.value && r.value && f.el) {
          const {
            scrollWidth: F,
            offsetWidth: z
          } = f.el;
          E = F - z - E;
        }
        d.value ? y.horizontal(E, m.value) : y(E, m.value);
      }
    }
    function _(E) {
      const {
        scrollTop: x,
        scrollLeft: $
      } = E.target;
      l.value = d.value ? $ : x;
    }
    function P(E) {
      if (w.value = !0, !(!o.value || !g.el)) {
        for (const x of E.composedPath())
          for (const $ of g.el.children)
            if ($ === x) {
              k($);
              return;
            }
      }
    }
    function M(E) {
      w.value = !1;
    }
    let q = !1;
    function K(E) {
      !q && !w.value && !(E.relatedTarget && g.el?.contains(E.relatedTarget)) && L(), q = !1;
    }
    function j() {
      q = !0;
    }
    function H(E) {
      if (!g.el) return;
      function x($) {
        E.preventDefault(), L($);
      }
      d.value ? E.key === "ArrowRight" ? x(r.value ? "prev" : "next") : E.key === "ArrowLeft" && x(r.value ? "next" : "prev") : E.key === "ArrowDown" ? x("next") : E.key === "ArrowUp" && x("prev"), E.key === "Home" ? x("first") : E.key === "End" && x("last");
    }
    function B(E, x) {
      if (!E) return;
      let $ = E;
      do
        $ = $?.[x === "next" ? "nextElementSibling" : "previousElementSibling"];
      while ($?.hasAttribute("disabled"));
      return $;
    }
    function L(E) {
      if (!g.el) return;
      let x;
      if (!E)
        x = an(g.el)[0];
      else if (E === "next") {
        if (x = B(g.el.querySelector(":focus"), E), !x) return L("first");
      } else if (E === "prev") {
        if (x = B(g.el.querySelector(":focus"), E), !x) return L("last");
      } else E === "first" ? (x = g.el.firstElementChild, x?.hasAttribute("disabled") && (x = B(x, "next"))) : E === "last" && (x = g.el.lastElementChild, x?.hasAttribute("disabled") && (x = B(x, "prev")));
      x && x.focus({
        preventScroll: !0
      });
    }
    function O(E) {
      const x = d.value && r.value ? -1 : 1, $ = (E === "prev" ? -x : x) * u.value;
      let V = l.value + $;
      if (d.value && r.value && f.el) {
        const {
          scrollWidth: F,
          offsetWidth: z
        } = f.el;
        V += F - z;
      }
      S(V);
    }
    const U = I(() => ({
      next: s.next,
      prev: s.prev,
      select: s.select,
      isSelected: s.isSelected
    })), Z = I(() => o.value || Math.abs(l.value) > 0), J = I(() => {
      switch (e.showArrows) {
        case "never":
          return !1;
        // Always show arrows on desktop & mobile
        case "always":
          return !0;
        // Always show arrows on desktop
        case "desktop":
          return !t.value;
        // Show arrows on mobile when overflowing.
        // This matches the default 2.2 behavior
        case !0:
          return Z.value;
        // Always show on mobile
        case "mobile":
          return t.value || Z.value;
        // https://material.io/components/tabs#scrollable-tabs
        // Always show arrows when
        // overflowed on desktop
        default:
          return !t.value && Z.value;
      }
    }), A = I(() => Math.abs(l.value) > 1), T = I(() => {
      if (!f.value || !Z.value) return !1;
      const E = qm(d.value, f.el), x = g_(d.value, f.el);
      return E - x - Math.abs(l.value) > 1;
    });
    return me(() => C(e.tag, {
      class: ue(["v-slide-group", {
        "v-slide-group--vertical": !d.value,
        "v-slide-group--has-affixes": J.value,
        "v-slide-group--is-overflowing": o.value
      }, n.value, e.class]),
      style: be(e.style),
      tabindex: w.value || s.selected.value.length ? -1 : 0,
      onFocus: K
    }, {
      default: () => [J.value && D("div", {
        key: "prev",
        class: ue(["v-slide-group__prev", {
          "v-slide-group__prev--disabled": !A.value
        }]),
        onMousedown: j,
        onClick: () => A.value && O("prev")
      }, [i.prev?.(U.value) ?? C(Vo, null, {
        default: () => [C(xe, {
          icon: r.value ? e.nextIcon : e.prevIcon
        }, null)]
      })]), D("div", {
        key: "container",
        ref: f,
        class: ue(["v-slide-group__container", e.contentClass]),
        onScroll: _
      }, [D("div", {
        ref: g,
        class: "v-slide-group__content",
        onFocusin: P,
        onFocusout: M,
        onKeydown: H
      }, [i.default?.(U.value)])]), J.value && D("div", {
        key: "next",
        class: ue(["v-slide-group__next", {
          "v-slide-group__next--disabled": !T.value
        }]),
        onMousedown: j,
        onClick: () => T.value && O("next")
      }, [i.next?.(U.value) ?? C(Vo, null, {
        default: () => [C(xe, {
          icon: r.value ? e.prevIcon : e.nextIcon
        }, null)]
      })])]
    })), {
      selected: s.selected,
      scrollTo: O,
      scrollOffset: l,
      focus: L,
      hasPrev: A,
      hasNext: T
    };
  }
});
function b_(e) {
  return e ? e.map((a) => ms(a) ? a : {
    text: a,
    value: a
  }) : [];
}
const k_ = ee({
  alignTabs: {
    type: String,
    default: "start"
  },
  color: String,
  fixedTabs: Boolean,
  items: {
    type: Array,
    default: () => []
  },
  stacked: Boolean,
  bgColor: String,
  grow: Boolean,
  height: {
    type: [Number, String],
    default: void 0
  },
  hideSlider: Boolean,
  inset: Boolean,
  insetPadding: [String, Number],
  insetRadius: [String, Number],
  sliderColor: String,
  ...za(oh(), ["spaced", "sliderTransition", "sliderTransitionDuration"]),
  ...Fu({
    mandatory: "force",
    selectedClass: "v-tab-item--selected"
  }),
  ...Kt(),
  ...Be()
}, "VTabs"), Ku = de()({
  name: "VTabs",
  props: k_(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, a) {
    let {
      attrs: i,
      slots: r
    } = a;
    const n = $e(e, "modelValue"), t = I(() => b_(e.items)), {
      densityClasses: s
    } = Qt(e), {
      backgroundColorClasses: o,
      backgroundColorStyles: l
    } = at(() => e.bgColor), {
      scopeId: u
    } = Us();
    return da({
      VTab: {
        color: W(e, "color"),
        direction: W(e, "direction"),
        stacked: W(e, "stacked"),
        fixed: W(e, "fixedTabs"),
        inset: W(e, "inset"),
        sliderColor: W(e, "sliderColor"),
        sliderTransition: W(e, "sliderTransition"),
        sliderTransitionDuration: W(e, "sliderTransitionDuration"),
        hideSlider: W(e, "hideSlider")
      }
    }), me(() => {
      const c = _s.filterProps(e), d = !!(r.window || e.items.length > 0);
      return D(pe, null, [C(_s, re(c, {
        modelValue: n.value,
        "onUpdate:modelValue": (f) => n.value = f,
        class: ["v-tabs", `v-tabs--${e.direction}`, `v-tabs--align-tabs-${e.alignTabs}`, {
          "v-tabs--fixed-tabs": e.fixedTabs,
          "v-tabs--grow": e.grow,
          "v-tabs--inset": e.inset,
          "v-tabs--stacked": e.stacked
        }, s.value, o.value, e.class],
        style: [{
          "--v-tabs-height": he(e.height),
          "--v-tabs-inset-padding": e.inset ? he(e.insetPadding) : void 0,
          "--v-tabs-inset-radius": e.inset ? he(e.insetRadius) : void 0
        }, l.value, e.style],
        role: "tablist",
        symbol: qu
      }, u, i), {
        default: r.default ?? (() => t.value.map((f) => r.tab?.({
          item: f
        }) ?? C(kr, re(f, {
          key: f.text,
          value: f.value,
          spaced: e.spaced
        }), {
          default: r[`tab.${f.value}`] ? () => r[`tab.${f.value}`]?.({
            item: f
          }) : void 0
        }))),
        prev: r.prev,
        next: r.next
      }), d && C(dh, re({
        modelValue: n.value,
        "onUpdate:modelValue": (f) => n.value = f,
        key: "tabs-window"
      }, u), {
        default: () => [t.value.map((f) => r.item?.({
          item: f
        }) ?? C(No, {
          value: f.value
        }, {
          default: () => r[`item.${f.value}`]?.({
            item: f
          })
        })), r.window?.()]
      })]);
    }), {};
  }
}), w_ = {
  __name: "date-time-picker",
  props: {
    modelValue: {
      /** @type import('vue').PropType<import('../../types.js').VjsfDatePickerNode> */
      type: Object,
      required: !0
    },
    statefulLayout: {
      /** @type import('vue').PropType<import('../../types.js').VjsfStatefulLayout> */
      type: Object,
      required: !0
    }
  },
  setup(e) {
    Ge({}, "VjsfDatePicker");
    const a = vt("VDatePicker", { hideHeader: !0 }), i = vt("VTimePicker", { title: "" }), r = e, n = Fa(), t = ie("date"), s = ie(!1);
    ce(s, () => {
      t.value = "date";
    });
    const { compProps: o, localData: l } = mt(W(r, "modelValue"), r.statefulLayout), u = I(() => {
      const d = { ...a.value, ...o.value };
      return d.hideActions = !0, l.value && (d.modelValue = new Date(l.value)), d["onUpdate:modelValue"] = (f) => {
        if (f) {
          if (l.value) {
            const v = f && nh(
              /** @type Date */
              /** @type unknown */
              f
            )[0];
            r.statefulLayout.input(r.modelValue, v + l.value.slice(10));
          } else
            r.statefulLayout.input(r.modelValue, Lu(f));
          t.value = "time";
        }
      }, d;
    }), c = I(() => {
      const d = { ...i.value, ...o.value };
      return d.format !== "24hr" && (d["ampm-in-title"] = !0), l.value && (d.modelValue = rh(l.value.slice(11))), d["onUpdate:modelValue"] = (f) => {
        l.value && r.statefulLayout.input(r.modelValue, l.value.slice(0, 11) + f + l.value.slice(16));
      }, d;
    });
    return (d, f) => (oe(), ye(Ru, {
      "menu-opened": s.value,
      "onUpdate:menuOpened": f[2] || (f[2] = (v) => s.value = v),
      "model-value": e.modelValue,
      "stateful-layout": e.statefulLayout,
      "formatted-value": e.modelValue.data ? Y(n).format(e.modelValue.data, "fullDateTime") : void 0
    }, {
      "prepend-inner": le(() => [
        C(Y(xe), {
          icon: e.statefulLayout.options.icons.calendar
        }, null, 8, ["icon"])
      ]),
      default: le(() => [
        C(Y(pa), null, {
          default: le(() => [
            C(Y(Ku), {
              modelValue: t.value,
              "onUpdate:modelValue": f[0] || (f[0] = (v) => t.value = v),
              "align-tabs": "center"
            }, {
              default: le(() => [
                C(Y(kr), { value: "date" }, {
                  default: le(() => [
                    C(Y(xe), {
                      icon: e.statefulLayout.options.icons.calendar
                    }, null, 8, ["icon"])
                  ]),
                  _: 1
                }),
                C(Y(kr), {
                  value: "time",
                  disabled: !e.modelValue.data
                }, {
                  default: le(() => [
                    C(Y(xe), {
                      icon: e.statefulLayout.options.icons.clock
                    }, null, 8, ["icon"])
                  ]),
                  _: 1
                }, 8, ["disabled"])
              ]),
              _: 1
            }, 8, ["modelValue"]),
            C(Y(dh), {
              modelValue: t.value,
              "onUpdate:modelValue": f[1] || (f[1] = (v) => t.value = v)
            }, {
              default: le(() => [
                C(Y(No), { value: "date" }, {
                  default: le(() => [
                    C(Y(ah), Gt(oa(u.value)), null, 16)
                  ]),
                  _: 1
                }),
                C(Y(No), { value: "time" }, {
                  default: le(() => [
                    C(Y(je), { defaults: { global: { density: "default" } } }, {
                      default: le(() => [
                        C(Y(lh), Gt(oa(c.value)), null, 16)
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                })
              ]),
              _: 1
            }, 8, ["modelValue"])
          ]),
          _: 1
        })
      ]),
      _: 1
    }, 8, ["menu-opened", "model-value", "stateful-layout", "formatted-value"]));
  }
};
function S_(e) {
  return {
    aspectStyles: I(() => {
      const a = Number(e.aspectRatio);
      return a ? {
        paddingBottom: String(1 / a * 100) + "%"
      } : void 0;
    })
  };
}
const hh = ee({
  aspectRatio: [String, Number],
  contentClass: null,
  inline: Boolean,
  ...Se(),
  ...Mt()
}, "VResponsive"), zm = de()({
  name: "VResponsive",
  props: hh(),
  setup(e, a) {
    let {
      slots: i
    } = a;
    const {
      aspectStyles: r
    } = S_(e), {
      dimensionStyles: n
    } = Rt(e);
    return me(() => D("div", {
      class: ue(["v-responsive", {
        "v-responsive--inline": e.inline
      }, e.class]),
      style: be([n.value, e.style])
    }, [D("div", {
      class: "v-responsive__sizer",
      style: be(r.value)
    }, null), i.additional?.(), i.default && D("div", {
      class: ue(["v-responsive__content", e.contentClass])
    }, [i.default()])])), {};
  }
}), $_ = ee({
  absolute: Boolean,
  alt: String,
  cover: Boolean,
  color: String,
  draggable: {
    type: [Boolean, String],
    default: void 0
  },
  eager: Boolean,
  gradient: String,
  lazySrc: String,
  options: {
    type: Object,
    // For more information on types, navigate to:
    // https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API
    default: () => ({
      root: void 0,
      rootMargin: void 0,
      threshold: void 0
    })
  },
  sizes: String,
  src: {
    type: [String, Object],
    default: ""
  },
  crossorigin: String,
  referrerpolicy: String,
  srcset: String,
  position: String,
  ...hh(),
  ...Se(),
  ...$t(),
  ...Gn()
}, "VImg"), Zs = de()({
  name: "VImg",
  directives: {
    vIntersect: qa
  },
  props: $_(),
  emits: {
    loadstart: (e) => !0,
    load: (e) => !0,
    error: (e) => !0
  },
  setup(e, a) {
    let {
      emit: i,
      slots: r
    } = a;
    const {
      backgroundColorClasses: n,
      backgroundColorStyles: t
    } = at(() => e.color), {
      roundedClasses: s
    } = _t(e), o = ft("VImg"), l = fe(""), u = ie(), c = fe(e.eager ? "loading" : "idle"), d = fe(), f = fe(), v = I(() => e.src && typeof e.src == "object" ? {
      src: e.src.src,
      srcset: e.srcset || e.src.srcset,
      lazySrc: e.lazySrc || e.src.lazySrc,
      aspect: Number(e.aspectRatio || e.src.aspect || 0)
    } : {
      src: e.src,
      srcset: e.srcset,
      lazySrc: e.lazySrc,
      aspect: Number(e.aspectRatio || 0)
    }), g = I(() => v.value.aspect || d.value / f.value || 0);
    ce(() => e.src, () => {
      h(c.value !== "idle");
    }), ce(g, (j, H) => {
      !j && H && u.value && w(u.value);
    }), Cr(() => h());
    function h(j) {
      if (!(e.eager && j) && !(mu && !j && !e.eager)) {
        if (c.value = "loading", v.value.lazySrc) {
          const H = new Image();
          H.src = v.value.lazySrc, w(H, null);
        }
        v.value.src && Ee(() => {
          i("loadstart", u.value?.currentSrc || v.value.src), setTimeout(() => {
            if (!o.isUnmounted)
              if (u.value?.complete) {
                if (u.value.naturalWidth || m(), c.value === "error") return;
                g.value || w(u.value, null), c.value === "loading" && y();
              } else
                g.value || w(u.value), p();
          });
        });
      }
    }
    function y() {
      o.isUnmounted || (p(), w(u.value), c.value = "loaded", i("load", u.value?.currentSrc || v.value.src));
    }
    function m() {
      o.isUnmounted || (c.value = "error", i("error", u.value?.currentSrc || v.value.src));
    }
    function p() {
      const j = u.value;
      j && (l.value = j.currentSrc || j.src);
    }
    let b = -1;
    ha(() => {
      clearTimeout(b);
    });
    function w(j) {
      let H = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 100;
      const B = () => {
        if (clearTimeout(b), o.isUnmounted) return;
        const {
          naturalHeight: L,
          naturalWidth: O
        } = j;
        L || O ? (d.value = O, f.value = L) : !j.complete && c.value === "loading" && H != null ? b = window.setTimeout(B, H) : (j.currentSrc.endsWith(".svg") || j.currentSrc.startsWith("data:image/svg+xml")) && (d.value = 1, f.value = 1);
      };
      B();
    }
    const k = W(() => ({
      "v-img__img--cover": e.cover,
      "v-img__img--contain": !e.cover
    })), S = () => {
      if (!v.value.src || c.value === "idle") return null;
      const j = D("img", {
        class: ue(["v-img__img", k.value]),
        style: {
          objectPosition: e.position
        },
        crossorigin: e.crossorigin,
        src: v.value.src,
        srcset: v.value.srcset,
        alt: e.alt,
        referrerpolicy: e.referrerpolicy,
        draggable: e.draggable,
        sizes: e.sizes,
        ref: u,
        onLoad: y,
        onError: m
      }, null), H = r.sources?.();
      return C(Wt, {
        transition: e.transition,
        appear: !0
      }, {
        default: () => [Je(H ? D("picture", {
          class: "v-img__picture"
        }, [H, j]) : j, [[ya, c.value === "loaded"]])]
      });
    }, _ = () => C(Wt, {
      transition: e.transition
    }, {
      default: () => [v.value.lazySrc && c.value !== "loaded" && D("img", {
        class: ue(["v-img__img", "v-img__img--preload", k.value]),
        style: {
          objectPosition: e.position
        },
        crossorigin: e.crossorigin,
        src: v.value.lazySrc,
        alt: e.alt,
        referrerpolicy: e.referrerpolicy,
        draggable: e.draggable
      }, null)]
    }), P = () => r.placeholder ? C(Wt, {
      transition: e.transition,
      appear: !0
    }, {
      default: () => [(c.value === "loading" || c.value === "error" && !r.error) && D("div", {
        class: "v-img__placeholder"
      }, [r.placeholder()])]
    }) : null, M = () => r.error ? C(Wt, {
      transition: e.transition,
      appear: !0
    }, {
      default: () => [c.value === "error" && D("div", {
        class: "v-img__error"
      }, [r.error()])]
    }) : null, q = () => e.gradient ? D("div", {
      class: "v-img__gradient",
      style: {
        backgroundImage: `linear-gradient(${e.gradient})`
      }
    }, null) : null, K = fe(!1);
    {
      const j = ce(g, (H) => {
        H && (requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            K.value = !0;
          });
        }), j());
      });
    }
    return me(() => {
      const j = zm.filterProps(e);
      return Je(C(zm, re({
        class: ["v-img", {
          "v-img--absolute": e.absolute,
          "v-img--booting": !K.value
        }, n.value, s.value, e.class],
        style: [{
          width: he(e.width === "auto" ? d.value : e.width)
        }, t.value, e.style]
      }, j, {
        aspectRatio: g.value,
        "aria-label": e.alt,
        role: e.alt ? "img" : void 0
      }), {
        additional: () => D(pe, null, [C(S, null, null), C(_, null, null), C(q, null, null), C(P, null, null), C(M, null, null)]),
        default: r.default
      }), [[qa, {
        handler: h,
        options: e.options
      }, null, {
        once: !0
      }]]);
    }), {
      currentSrc: l,
      image: u,
      state: c,
      naturalWidth: d,
      naturalHeight: f
    };
  }
}), __ = ee({
  start: Boolean,
  end: Boolean,
  icon: Pe,
  image: String,
  text: String,
  ...Aa(),
  ...Se(),
  ...Kt(),
  ...$t(),
  ...Nr(),
  ...Be(),
  ...Qe(),
  ...ja({
    variant: "flat"
  })
}, "VAvatar"), Yt = de()({
  name: "VAvatar",
  props: __(),
  setup(e, a) {
    let {
      slots: i
    } = a;
    const {
      themeClasses: r
    } = ut(e), {
      borderClasses: n
    } = Ta(e), {
      colorClasses: t,
      colorStyles: s,
      variantClasses: o
    } = Kn(e), {
      densityClasses: l
    } = Qt(e), {
      roundedClasses: u
    } = _t(e), {
      sizeClasses: c,
      sizeStyles: d
    } = Lr(e);
    return me(() => C(e.tag, {
      class: ue(["v-avatar", {
        "v-avatar--start": e.start,
        "v-avatar--end": e.end
      }, r.value, n.value, t.value, l.value, u.value, c.value, o.value, e.class]),
      style: be([s.value, d.value, e.style])
    }, {
      default: () => [i.default ? C(je, {
        key: "content-defaults",
        defaults: {
          VImg: {
            cover: !0,
            src: e.image
          },
          VIcon: {
            icon: e.icon
          }
        }
      }, {
        default: () => [i.default()]
      }) : e.image ? C(Zs, {
        key: "image",
        src: e.image,
        alt: "",
        cover: !0
      }, null) : e.icon ? C(xe, {
        key: "icon",
        icon: e.icon
      }, null) : e.text, yn(!1, "v-avatar")]
    })), {};
  }
}), P_ = ee({
  color: {
    type: Object
  },
  disabled: Boolean,
  dotSize: {
    type: [Number, String],
    default: 10
  },
  height: {
    type: [Number, String],
    default: 150
  },
  width: {
    type: [Number, String],
    default: 300
  },
  ...Se()
}, "VColorPickerCanvas"), C_ = ba({
  name: "VColorPickerCanvas",
  props: P_(),
  emits: {
    "update:color": (e) => !0,
    "update:position": (e) => !0
  },
  setup(e, a) {
    let {
      emit: i
    } = a;
    const r = fe(!1), n = ie(), t = fe(parseFloat(e.width)), s = fe(parseFloat(e.height)), o = ie({
      x: 0,
      y: 0
    }), l = I({
      get: () => o.value,
      set(y) {
        if (!n.value) return;
        const {
          x: m,
          y: p
        } = y;
        o.value = y, i("update:color", {
          h: e.color?.h ?? 0,
          s: Xe(m, 0, t.value) / t.value,
          v: 1 - Xe(p, 0, s.value) / s.value,
          a: e.color?.a ?? 1
        });
      }
    }), u = I(() => {
      const {
        x: y,
        y: m
      } = l.value, p = parseInt(e.dotSize, 10) / 2;
      return {
        width: he(e.dotSize),
        height: he(e.dotSize),
        transform: `translate(${he(y - p)}, ${he(m - p)})`
      };
    }), {
      resizeRef: c
    } = fn((y) => {
      if (!c.el?.offsetParent) return;
      const {
        width: m,
        height: p
      } = y[0].contentRect;
      t.value = m, s.value = p;
    });
    function d(y, m, p) {
      const {
        left: b,
        top: w,
        width: k,
        height: S
      } = p;
      l.value = {
        x: Xe(y - b, 0, k),
        y: Xe(m - w, 0, S)
      };
    }
    function f(y) {
      y.type === "mousedown" && y.preventDefault(), !e.disabled && (v(y), window.addEventListener("mousemove", v), window.addEventListener("mouseup", g), window.addEventListener("touchmove", v), window.addEventListener("touchend", g));
    }
    function v(y) {
      if (e.disabled || !n.value) return;
      r.value = !0;
      const m = ew(y);
      d(m.clientX, m.clientY, n.value.getBoundingClientRect());
    }
    function g() {
      window.removeEventListener("mousemove", v), window.removeEventListener("mouseup", g), window.removeEventListener("touchmove", v), window.removeEventListener("touchend", g);
    }
    function h() {
      if (!n.value) return;
      const y = n.value, m = y.getContext("2d");
      if (!m) return;
      const p = m.createLinearGradient(0, 0, y.width, 0);
      p.addColorStop(0, "hsla(0, 0%, 100%, 1)"), p.addColorStop(1, `hsla(${e.color?.h ?? 0}, 100%, 50%, 1)`), m.fillStyle = p, m.fillRect(0, 0, y.width, y.height);
      const b = m.createLinearGradient(0, 0, 0, y.height);
      b.addColorStop(0, "hsla(0, 0%, 0%, 0)"), b.addColorStop(1, "hsla(0, 0%, 0%, 1)"), m.fillStyle = b, m.fillRect(0, 0, y.width, y.height);
    }
    return ce(() => e.color?.h, h, {
      immediate: !0
    }), ce(() => [t.value, s.value], (y, m) => {
      h(), o.value = {
        x: l.value.x * y[0] / m[0],
        y: l.value.y * y[1] / m[1]
      };
    }, {
      flush: "post"
    }), ce(() => e.color, () => {
      if (r.value) {
        r.value = !1;
        return;
      }
      o.value = e.color ? {
        x: e.color.s * t.value,
        y: (1 - e.color.v) * s.value
      } : {
        x: 0,
        y: 0
      };
    }, {
      deep: !0,
      immediate: !0
    }), ua(() => h()), me(() => D("div", {
      ref: c,
      class: ue(["v-color-picker-canvas", e.class]),
      style: be(e.style),
      onMousedown: f,
      onTouchstartPassive: f
    }, [D("canvas", {
      ref: n,
      width: t.value,
      height: s.value
    }, null), e.color && D("div", {
      class: ue(["v-color-picker-canvas__dot", {
        "v-color-picker-canvas__dot--disabled": e.disabled
      }]),
      style: be(u.value)
    }, null)])), {};
  }
});
function x_(e, a) {
  if (a) {
    const {
      a: i,
      ...r
    } = e;
    return r;
  }
  return e;
}
function V_(e, a) {
  if (a == null || typeof a == "string") {
    const i = e.a !== 1;
    if (a?.startsWith("rgb(")) {
      const {
        r: n,
        g: t,
        b: s,
        a: o
      } = va(e);
      return `rgb(${n} ${t} ${s}` + (i ? ` / ${o})` : ")");
    } else if (a?.startsWith("hsl(")) {
      const {
        h: n,
        s: t,
        l: s,
        a: o
      } = _o(e);
      return `hsl(${n} ${Math.round(t * 100)} ${Math.round(s * 100)}` + (i ? ` / ${o})` : ")");
    }
    const r = Jv(e);
    return e.a === 1 ? r.slice(0, 7) : r;
  }
  if (typeof a == "object") {
    let i;
    return Qa(a, ["r", "g", "b"]) ? i = va(e) : Qa(a, ["h", "s", "l"]) ? i = _o(e) : Qa(a, ["h", "s", "v"]) && (i = e), x_(i, !Qa(a, ["a"]) && e.a === 1);
  }
  return e;
}
const On = {
  h: 0,
  s: 0,
  v: 0,
  a: 1
}, Lo = {
  inputProps: {
    type: "number",
    min: 0
  },
  inputs: [{
    label: "R",
    max: 255,
    step: 1,
    getValue: (e) => Math.round(e.r),
    getColor: (e, a) => ({
      ...e,
      r: Number(a)
    }),
    localeKey: "redInput"
  }, {
    label: "G",
    max: 255,
    step: 1,
    getValue: (e) => Math.round(e.g),
    getColor: (e, a) => ({
      ...e,
      g: Number(a)
    }),
    localeKey: "greenInput"
  }, {
    label: "B",
    max: 255,
    step: 1,
    getValue: (e) => Math.round(e.b),
    getColor: (e, a) => ({
      ...e,
      b: Number(a)
    }),
    localeKey: "blueInput"
  }, {
    label: "A",
    max: 1,
    step: 0.01,
    getValue: (e) => {
      let {
        a
      } = e;
      return a != null ? Math.round(a * 100) / 100 : 1;
    },
    getColor: (e, a) => ({
      ...e,
      a: Number(a)
    }),
    localeKey: "alphaInput"
  }],
  to: va,
  from: Tr
}, I_ = {
  ...Lo,
  inputs: Lo.inputs?.slice(0, 3)
}, qo = {
  inputProps: {
    type: "number",
    min: 0
  },
  inputs: [{
    label: "H",
    max: 360,
    step: 1,
    getValue: (e) => Math.round(e.h),
    getColor: (e, a) => ({
      ...e,
      h: Number(a)
    }),
    localeKey: "hueInput"
  }, {
    label: "S",
    max: 1,
    step: 0.01,
    getValue: (e) => Math.round(e.s * 100) / 100,
    getColor: (e, a) => ({
      ...e,
      s: Number(a)
    }),
    localeKey: "saturationInput"
  }, {
    label: "L",
    max: 1,
    step: 0.01,
    getValue: (e) => Math.round(e.l * 100) / 100,
    getColor: (e, a) => ({
      ...e,
      l: Number(a)
    }),
    localeKey: "lightnessInput"
  }, {
    label: "A",
    max: 1,
    step: 0.01,
    getValue: (e) => {
      let {
        a
      } = e;
      return a != null ? Math.round(a * 100) / 100 : 1;
    },
    getColor: (e, a) => ({
      ...e,
      a: Number(a)
    }),
    localeKey: "alphaInput"
  }],
  to: _o,
  from: hu
}, O_ = {
  ...qo,
  inputs: qo.inputs.slice(0, 3)
}, yh = {
  inputProps: {
    type: "text"
  },
  inputs: [{
    label: "HEXA",
    getValue: (e) => e,
    getColor: (e, a) => a,
    localeKey: "hexaInput"
  }],
  to: Jv,
  from: $w
}, E_ = {
  ...yh,
  inputs: [{
    label: "HEX",
    getValue: (e) => e.slice(0, 7),
    getColor: (e, a) => a,
    localeKey: "hexInput"
  }]
}, nn = {
  rgb: I_,
  rgba: Lo,
  hsl: O_,
  hsla: qo,
  hex: E_,
  hexa: yh
}, A_ = (e) => {
  let {
    label: a,
    ...i
  } = e;
  return D("div", {
    class: "v-color-picker-edit__input"
  }, [D("input", Gt(oa(i)), null), D("span", null, [a])]);
}, T_ = ee({
  color: Object,
  disabled: Boolean,
  mode: {
    type: String,
    default: "rgba",
    validator: (e) => Object.keys(nn).includes(e)
  },
  modes: {
    type: Array,
    default: () => Object.keys(nn),
    validator: (e) => Array.isArray(e) && e.every((a) => Object.keys(nn).includes(a))
  },
  ...Se()
}, "VColorPickerEdit"), j_ = ba({
  name: "VColorPickerEdit",
  props: T_(),
  emits: {
    "update:color": (e) => !0,
    "update:mode": (e) => !0
  },
  setup(e, a) {
    let {
      emit: i
    } = a;
    const {
      t: r
    } = nt(), n = I(() => e.modes.map((s) => ({
      ...nn[s],
      name: s
    }))), t = I(() => {
      const s = n.value.find((l) => l.name === e.mode);
      if (!s) return [];
      const o = e.color ? s.to(e.color) : null;
      return s.inputs?.map((l) => {
        let {
          getValue: u,
          getColor: c,
          localeKey: d,
          ...f
        } = l;
        return {
          ...s.inputProps,
          ...f,
          ariaLabel: r(`$vuetify.colorPicker.ariaLabel.${d}`),
          disabled: e.disabled,
          value: o && u(o),
          onChange: (v) => {
            const g = v.target;
            g && i("update:color", s.from(c(o ?? s.to(On), g.value)));
          }
        };
      });
    });
    return me(() => D("div", {
      class: ue(["v-color-picker-edit", e.class]),
      style: be(e.style)
    }, [t.value?.map((s) => C(A_, s, null)), n.value.length > 1 && C(Te, {
      icon: "$unfold",
      size: "x-small",
      variant: "plain",
      "aria-label": r("$vuetify.colorPicker.ariaLabel.changeFormat"),
      onClick: () => {
        const s = n.value.findIndex((o) => o.name === e.mode);
        i("update:mode", n.value[(s + 1) % n.value.length].name);
      }
    }, null)])), {};
  }
}), gh = ee({
  color: {
    type: Object
  },
  disabled: Boolean,
  hideAlpha: Boolean,
  hideEyeDropper: Boolean,
  eyeDropperIcon: {
    type: Pe,
    default: "$eyeDropper"
  },
  ...Se()
}, "VColorPickerPreview"), D_ = ba({
  name: "VColorPickerPreview",
  props: gh(),
  emits: {
    "update:color": (e) => !0
  },
  setup(e, a) {
    let {
      emit: i
    } = a;
    const {
      t: r
    } = nt(), n = new AbortController();
    hy(() => n.abort());
    async function t() {
      if (!Of || e.disabled) return;
      const s = new window.EyeDropper();
      try {
        const o = await s.open({
          signal: n.signal
        }), l = Tr(Ia(o.sRGBHex));
        i("update:color", {
          ...e.color ?? On,
          ...l
        });
      } catch {
      }
    }
    return me(() => D("div", {
      class: ue(["v-color-picker-preview", {
        "v-color-picker-preview--hide-alpha": e.hideAlpha
      }, e.class]),
      style: be(e.style)
    }, [Of && !e.hideEyeDropper && D("div", {
      class: "v-color-picker-preview__eye-dropper",
      key: "eyeDropper"
    }, [C(Te, {
      "aria-label": r("$vuetify.colorPicker.ariaLabel.eyedropper"),
      density: "comfortable",
      disabled: e.disabled,
      icon: e.eyeDropperIcon,
      variant: "plain",
      onClick: t
    }, null)]), D("div", {
      class: "v-color-picker-preview__dot"
    }, [D("div", {
      style: {
        background: Xv(e.color ?? On)
      }
    }, null)]), D("div", {
      class: "v-color-picker-preview__sliders"
    }, [C(Do, {
      class: "v-color-picker-preview__track v-color-picker-preview__hue",
      "aria-label": r("$vuetify.colorPicker.ariaLabel.hueSlider"),
      modelValue: e.color?.h,
      "onUpdate:modelValue": (s) => i("update:color", {
        ...e.color ?? On,
        h: s
      }),
      step: 1,
      min: 0,
      max: 360,
      disabled: e.disabled,
      thumbSize: 14,
      trackSize: 8,
      trackFillColor: "white",
      hideDetails: !0
    }, null), !e.hideAlpha && C(Do, {
      class: "v-color-picker-preview__track v-color-picker-preview__alpha",
      "aria-label": r("$vuetify.colorPicker.ariaLabel.alphaSlider"),
      modelValue: e.color?.a ?? 1,
      "onUpdate:modelValue": (s) => i("update:color", {
        ...e.color ?? On,
        a: s
      }),
      step: 0.01,
      min: 0,
      max: 1,
      disabled: e.disabled,
      thumbSize: 14,
      trackSize: 8,
      trackFillColor: "white",
      hideDetails: !0
    }, null)])])), {};
  }
}), M_ = {
  base: "#f44336",
  lighten5: "#ffebee",
  lighten4: "#ffcdd2",
  lighten3: "#ef9a9a",
  lighten2: "#e57373",
  lighten1: "#ef5350",
  darken1: "#e53935",
  darken2: "#d32f2f",
  darken3: "#c62828",
  darken4: "#b71c1c",
  accent1: "#ff8a80",
  accent2: "#ff5252",
  accent3: "#ff1744",
  accent4: "#d50000"
}, R_ = {
  base: "#e91e63",
  lighten5: "#fce4ec",
  lighten4: "#f8bbd0",
  lighten3: "#f48fb1",
  lighten2: "#f06292",
  lighten1: "#ec407a",
  darken1: "#d81b60",
  darken2: "#c2185b",
  darken3: "#ad1457",
  darken4: "#880e4f",
  accent1: "#ff80ab",
  accent2: "#ff4081",
  accent3: "#f50057",
  accent4: "#c51162"
}, N_ = {
  base: "#9c27b0",
  lighten5: "#f3e5f5",
  lighten4: "#e1bee7",
  lighten3: "#ce93d8",
  lighten2: "#ba68c8",
  lighten1: "#ab47bc",
  darken1: "#8e24aa",
  darken2: "#7b1fa2",
  darken3: "#6a1b9a",
  darken4: "#4a148c",
  accent1: "#ea80fc",
  accent2: "#e040fb",
  accent3: "#d500f9",
  accent4: "#aa00ff"
}, L_ = {
  base: "#673ab7",
  lighten5: "#ede7f6",
  lighten4: "#d1c4e9",
  lighten3: "#b39ddb",
  lighten2: "#9575cd",
  lighten1: "#7e57c2",
  darken1: "#5e35b1",
  darken2: "#512da8",
  darken3: "#4527a0",
  darken4: "#311b92",
  accent1: "#b388ff",
  accent2: "#7c4dff",
  accent3: "#651fff",
  accent4: "#6200ea"
}, q_ = {
  base: "#3f51b5",
  lighten5: "#e8eaf6",
  lighten4: "#c5cae9",
  lighten3: "#9fa8da",
  lighten2: "#7986cb",
  lighten1: "#5c6bc0",
  darken1: "#3949ab",
  darken2: "#303f9f",
  darken3: "#283593",
  darken4: "#1a237e",
  accent1: "#8c9eff",
  accent2: "#536dfe",
  accent3: "#3d5afe",
  accent4: "#304ffe"
}, z_ = {
  base: "#2196f3",
  lighten5: "#e3f2fd",
  lighten4: "#bbdefb",
  lighten3: "#90caf9",
  lighten2: "#64b5f6",
  lighten1: "#42a5f5",
  darken1: "#1e88e5",
  darken2: "#1976d2",
  darken3: "#1565c0",
  darken4: "#0d47a1",
  accent1: "#82b1ff",
  accent2: "#448aff",
  accent3: "#2979ff",
  accent4: "#2962ff"
}, B_ = {
  base: "#03a9f4",
  lighten5: "#e1f5fe",
  lighten4: "#b3e5fc",
  lighten3: "#81d4fa",
  lighten2: "#4fc3f7",
  lighten1: "#29b6f6",
  darken1: "#039be5",
  darken2: "#0288d1",
  darken3: "#0277bd",
  darken4: "#01579b",
  accent1: "#80d8ff",
  accent2: "#40c4ff",
  accent3: "#00b0ff",
  accent4: "#0091ea"
}, F_ = {
  base: "#00bcd4",
  lighten5: "#e0f7fa",
  lighten4: "#b2ebf2",
  lighten3: "#80deea",
  lighten2: "#4dd0e1",
  lighten1: "#26c6da",
  darken1: "#00acc1",
  darken2: "#0097a7",
  darken3: "#00838f",
  darken4: "#006064",
  accent1: "#84ffff",
  accent2: "#18ffff",
  accent3: "#00e5ff",
  accent4: "#00b8d4"
}, K_ = {
  base: "#009688",
  lighten5: "#e0f2f1",
  lighten4: "#b2dfdb",
  lighten3: "#80cbc4",
  lighten2: "#4db6ac",
  lighten1: "#26a69a",
  darken1: "#00897b",
  darken2: "#00796b",
  darken3: "#00695c",
  darken4: "#004d40",
  accent1: "#a7ffeb",
  accent2: "#64ffda",
  accent3: "#1de9b6",
  accent4: "#00bfa5"
}, H_ = {
  base: "#4caf50",
  lighten5: "#e8f5e9",
  lighten4: "#c8e6c9",
  lighten3: "#a5d6a7",
  lighten2: "#81c784",
  lighten1: "#66bb6a",
  darken1: "#43a047",
  darken2: "#388e3c",
  darken3: "#2e7d32",
  darken4: "#1b5e20",
  accent1: "#b9f6ca",
  accent2: "#69f0ae",
  accent3: "#00e676",
  accent4: "#00c853"
}, U_ = {
  base: "#8bc34a",
  lighten5: "#f1f8e9",
  lighten4: "#dcedc8",
  lighten3: "#c5e1a5",
  lighten2: "#aed581",
  lighten1: "#9ccc65",
  darken1: "#7cb342",
  darken2: "#689f38",
  darken3: "#558b2f",
  darken4: "#33691e",
  accent1: "#ccff90",
  accent2: "#b2ff59",
  accent3: "#76ff03",
  accent4: "#64dd17"
}, W_ = {
  base: "#cddc39",
  lighten5: "#f9fbe7",
  lighten4: "#f0f4c3",
  lighten3: "#e6ee9c",
  lighten2: "#dce775",
  lighten1: "#d4e157",
  darken1: "#c0ca33",
  darken2: "#afb42b",
  darken3: "#9e9d24",
  darken4: "#827717",
  accent1: "#f4ff81",
  accent2: "#eeff41",
  accent3: "#c6ff00",
  accent4: "#aeea00"
}, G_ = {
  base: "#ffeb3b",
  lighten5: "#fffde7",
  lighten4: "#fff9c4",
  lighten3: "#fff59d",
  lighten2: "#fff176",
  lighten1: "#ffee58",
  darken1: "#fdd835",
  darken2: "#fbc02d",
  darken3: "#f9a825",
  darken4: "#f57f17",
  accent1: "#ffff8d",
  accent2: "#ffff00",
  accent3: "#ffea00",
  accent4: "#ffd600"
}, Y_ = {
  base: "#ffc107",
  lighten5: "#fff8e1",
  lighten4: "#ffecb3",
  lighten3: "#ffe082",
  lighten2: "#ffd54f",
  lighten1: "#ffca28",
  darken1: "#ffb300",
  darken2: "#ffa000",
  darken3: "#ff8f00",
  darken4: "#ff6f00",
  accent1: "#ffe57f",
  accent2: "#ffd740",
  accent3: "#ffc400",
  accent4: "#ffab00"
}, X_ = {
  base: "#ff9800",
  lighten5: "#fff3e0",
  lighten4: "#ffe0b2",
  lighten3: "#ffcc80",
  lighten2: "#ffb74d",
  lighten1: "#ffa726",
  darken1: "#fb8c00",
  darken2: "#f57c00",
  darken3: "#ef6c00",
  darken4: "#e65100",
  accent1: "#ffd180",
  accent2: "#ffab40",
  accent3: "#ff9100",
  accent4: "#ff6d00"
}, Z_ = {
  base: "#ff5722",
  lighten5: "#fbe9e7",
  lighten4: "#ffccbc",
  lighten3: "#ffab91",
  lighten2: "#ff8a65",
  lighten1: "#ff7043",
  darken1: "#f4511e",
  darken2: "#e64a19",
  darken3: "#d84315",
  darken4: "#bf360c",
  accent1: "#ff9e80",
  accent2: "#ff6e40",
  accent3: "#ff3d00",
  accent4: "#dd2c00"
}, J_ = {
  base: "#795548",
  lighten5: "#efebe9",
  lighten4: "#d7ccc8",
  lighten3: "#bcaaa4",
  lighten2: "#a1887f",
  lighten1: "#8d6e63",
  darken1: "#6d4c41",
  darken2: "#5d4037",
  darken3: "#4e342e",
  darken4: "#3e2723"
}, Q_ = {
  base: "#607d8b",
  lighten5: "#eceff1",
  lighten4: "#cfd8dc",
  lighten3: "#b0bec5",
  lighten2: "#90a4ae",
  lighten1: "#78909c",
  darken1: "#546e7a",
  darken2: "#455a64",
  darken3: "#37474f",
  darken4: "#263238"
}, eP = {
  base: "#9e9e9e",
  lighten5: "#fafafa",
  lighten4: "#f5f5f5",
  lighten3: "#eeeeee",
  lighten2: "#e0e0e0",
  lighten1: "#bdbdbd",
  darken1: "#757575",
  darken2: "#616161",
  darken3: "#424242",
  darken4: "#212121"
}, tP = {
  black: "#000000",
  white: "#ffffff",
  transparent: "#ffffff00"
}, aP = {
  red: M_,
  pink: R_,
  purple: N_,
  deepPurple: L_,
  indigo: q_,
  blue: z_,
  lightBlue: B_,
  cyan: F_,
  teal: K_,
  green: H_,
  lightGreen: U_,
  lime: W_,
  yellow: G_,
  amber: Y_,
  orange: X_,
  deepOrange: Z_,
  brown: J_,
  blueGrey: Q_,
  grey: eP,
  shades: tP
}, nP = ee({
  swatches: {
    type: Array,
    default: () => rP(aP)
  },
  disabled: Boolean,
  color: Object,
  maxHeight: [Number, String],
  ...Se()
}, "VColorPickerSwatches");
function rP(e) {
  return Object.keys(e).map((a) => {
    const i = e[a];
    return i.base ? [i.base, i.darken4, i.darken3, i.darken2, i.darken1, i.lighten1, i.lighten2, i.lighten3, i.lighten4, i.lighten5] : [i.black, i.white, i.transparent];
  });
}
const iP = ba({
  name: "VColorPickerSwatches",
  props: nP(),
  emits: {
    "update:color": (e) => !0
  },
  setup(e, a) {
    let {
      emit: i
    } = a;
    function r(n) {
      e.disabled || !n || i("update:color", n);
    }
    return me(() => D("div", {
      class: ue(["v-color-picker-swatches", e.class]),
      style: be([{
        maxHeight: he(e.maxHeight)
      }, e.style])
    }, [D("div", null, [e.swatches.map((n) => D("div", {
      class: "v-color-picker-swatches__swatch"
    }, [n.map((t) => {
      const s = Ia(t), o = Tr(s), l = Yv(s);
      return D("div", {
        class: ue(["v-color-picker-swatches__color", {
          "v-color-picker-swatches__color--disabled": e.disabled
        }]),
        onClick: () => r(o)
      }, [D("div", {
        style: {
          background: l
        }
      }, [e.color && bt(e.color, o) ? C(xe, {
        size: "x-small",
        icon: "$success",
        color: Pw(t, "#FFFFFF") > 2 ? "white" : "black"
      }, null) : void 0])]);
    })]))])])), {};
  }
}), bh = ee({
  canvasHeight: {
    type: [String, Number],
    default: 150
  },
  disabled: Boolean,
  dotSize: {
    type: [Number, String],
    default: 10
  },
  hideCanvas: Boolean,
  hideSliders: Boolean,
  hideInputs: Boolean,
  mode: {
    type: String,
    default: "rgba",
    validator: (e) => Object.keys(nn).includes(e)
  },
  modes: {
    type: Array,
    default: () => Object.keys(nn),
    validator: (e) => Array.isArray(e) && e.every((a) => Object.keys(nn).includes(a))
  },
  showSwatches: Boolean,
  swatches: Array,
  swatchesMaxHeight: {
    type: [Number, String],
    default: 150
  },
  modelValue: {
    type: [Object, String]
  },
  ...Xs({
    hideHeader: !0
  }),
  ...za(gh(), ["hideEyeDropper", "eyeDropperIcon"])
}, "VColorPicker"), Bm = ba({
  name: "VColorPicker",
  props: bh(),
  emits: {
    "update:modelValue": (e) => !0,
    "update:mode": (e) => !0
  },
  setup(e, a) {
    let {
      slots: i
    } = a;
    const r = $e(e, "mode"), n = ie(null), t = $e(e, "modelValue", void 0, (c) => {
      if (c == null || c === "") return null;
      let d;
      try {
        d = Tr(Ia(c));
      } catch (f) {
        return Oa(f), null;
      }
      return d;
    }, (c) => c ? V_(c, e.modelValue) : null), s = I(() => t.value ? {
      ...t.value,
      h: n.value ?? t.value.h
    } : null), {
      rtlClasses: o
    } = St();
    let l = !0;
    ce(t, (c) => {
      if (!l) {
        l = !0;
        return;
      }
      c && (n.value = c.h);
    }, {
      immediate: !0
    });
    const u = (c) => {
      l = !1, n.value = c.h, t.value = c;
    };
    return Cr(() => {
      e.modes.includes(r.value) || (r.value = e.modes[0]);
    }), da({
      VSlider: {
        color: void 0,
        trackColor: void 0,
        trackFillColor: void 0
      }
    }), me(() => {
      const c = Rn.filterProps(e);
      return C(Rn, re(c, {
        class: ["v-color-picker", o.value, e.class],
        style: [{
          "--v-color-picker-color-hsv": Xv({
            ...s.value ?? On,
            a: 1
          })
        }, e.style]
      }), {
        ...i,
        default: () => D(pe, null, [!e.hideCanvas && C(C_, {
          key: "canvas",
          color: s.value,
          "onUpdate:color": u,
          disabled: e.disabled,
          dotSize: e.dotSize,
          width: e.width,
          height: e.canvasHeight
        }, null), (!e.hideSliders || !e.hideInputs) && D("div", {
          key: "controls",
          class: "v-color-picker__controls"
        }, [!e.hideSliders && C(D_, {
          key: "preview",
          color: s.value,
          "onUpdate:color": u,
          hideAlpha: !r.value.endsWith("a"),
          disabled: e.disabled,
          hideEyeDropper: e.hideEyeDropper,
          eyeDropperIcon: e.eyeDropperIcon
        }, null), !e.hideInputs && C(j_, {
          key: "edit",
          modes: e.modes,
          mode: r.value,
          "onUpdate:mode": (d) => r.value = d,
          color: s.value,
          "onUpdate:color": u,
          disabled: e.disabled
        }, null)]), e.showSwatches && C(iP, {
          key: "swatches",
          color: s.value,
          "onUpdate:color": u,
          maxHeight: e.swatchesMaxHeight,
          swatches: e.swatches,
          disabled: e.disabled
        }, null)])
      });
    }), {};
  }
}), kh = ee({
  modelValue: null,
  color: String,
  cancelText: {
    type: String,
    default: "$vuetify.confirmEdit.cancel"
  },
  okText: {
    type: String,
    default: "$vuetify.confirmEdit.ok"
  },
  disabled: {
    type: [Boolean, Array],
    default: void 0
  },
  hideActions: Boolean
}, "VConfirmEdit"), Fm = de()({
  name: "VConfirmEdit",
  props: kh(),
  emits: {
    cancel: () => !0,
    save: (e) => !0,
    "update:modelValue": (e) => !0
  },
  setup(e, a) {
    let {
      emit: i,
      slots: r
    } = a;
    const n = $e(e, "modelValue"), t = ie();
    wt(() => {
      t.value = structuredClone(Rf(n.value));
    });
    const {
      t: s
    } = nt(), o = I(() => bt(n.value, t.value));
    function l(h) {
      return typeof e.disabled == "boolean" ? e.disabled : Array.isArray(e.disabled) ? e.disabled.includes(h) : o.value;
    }
    const u = I(() => l("save")), c = I(() => l("cancel"));
    function d() {
      n.value = t.value, i("save", t.value);
    }
    function f() {
      t.value = structuredClone(Rf(n.value)), i("cancel");
    }
    function v(h) {
      return D(pe, null, [C(Te, re({
        disabled: c.value,
        variant: "text",
        color: e.color,
        onClick: f,
        text: s(e.cancelText)
      }, h), null), C(Te, re({
        disabled: u.value,
        variant: "text",
        color: e.color,
        onClick: d,
        text: s(e.okText)
      }, h), null)]);
    }
    let g = !1;
    return me(() => D(pe, null, [r.default?.({
      model: t,
      save: d,
      cancel: f,
      isPristine: o.value,
      get actions() {
        return g = !0, v;
      }
    }), !e.hideActions && !g && v()])), {
      save: d,
      cancel: f,
      isPristine: o
    };
  }
}), sP = ["prepend", "prepend-inner", "append", "append-inner"], lP = ee({
  hidePip: Boolean,
  colorPip: Boolean,
  pipIcon: {
    type: String,
    default: "$color"
  },
  pipLocation: {
    type: String,
    default: "prepend",
    validator: (e) => sP.includes(e)
  },
  pipVariant: {
    type: String,
    default: "text"
  },
  pickerProps: Object,
  ...Ws(),
  ...kh(),
  ...Zn(),
  ...Le(bh(), ["location", "height", "minHeight", "maxHeight"])
}, "VColorInput"), oP = de()({
  name: "VColorInput",
  props: lP(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, a) {
    let {
      slots: i
    } = a;
    const r = $e(e, "modelValue"), n = fe(!1), t = fe(e.focused), s = I(() => !e.disabled && !e.readonly), o = I(() => r.value || null);
    function l(f) {
      if (f.key !== "Enter") return;
      if (!n.value || !t.value) {
        n.value = !0;
        return;
      }
      const v = f.target;
      r.value = v.value;
    }
    function u(f) {
      f.preventDefault(), f.stopPropagation(), n.value = !0;
    }
    function c() {
      n.value = !1;
    }
    function d() {
      n.value = !1;
    }
    me(() => {
      const f = Fm.filterProps(e), v = {
        ...Bm.filterProps(Le(e, ["active", "bgColor", "color", "rounded", "maxWidth", "minWidth", "width"])),
        ...e.pickerProps
      }, g = Dt.filterProps(e), h = e.hidePip ? void 0 : {
        [e.pipLocation]: (y) => D(pe, null, [C(Yt, {
          class: "v-color-input__pip",
          color: e.colorPip ? r.value : void 0,
          variant: e.pipVariant,
          icon: e.pipIcon
        }, null), i[e.pipLocation]?.(y)])
      };
      return C(Dt, re(g, {
        class: ["v-color-input", e.class],
        style: e.style,
        modelValue: o.value,
        onKeydown: s.value ? l : void 0,
        focused: n.value || t.value,
        "onClick:control": s.value ? u : void 0,
        "onClick:prependInner": s.value ? u : void 0,
        "onUpdate:focused": (y) => t.value = y,
        "onClick:appendInner": s.value ? u : void 0,
        "onUpdate:modelValue": (y) => {
          r.value = y;
        }
      }), {
        ...i,
        ...h,
        default: () => D(pe, null, [C(La, {
          modelValue: n.value,
          "onUpdate:modelValue": (y) => n.value = y,
          activator: "parent",
          minWidth: "0",
          closeOnContentClick: !1,
          openOnClick: !1
        }, {
          default: () => [C(Fm, re(f, {
            modelValue: r.value,
            "onUpdate:modelValue": (y) => r.value = y,
            onSave: c,
            onCancel: d
          }), {
            default: (y) => {
              let {
                actions: m,
                model: p,
                save: b,
                cancel: w,
                isPristine: k
              } = y;
              function S(_) {
                e.hideActions ? r.value = _ : p.value = _;
              }
              return C(Bm, re(v, {
                modelValue: e.hideActions ? r.value : p.value,
                "onUpdate:modelValue": (_) => S(_)
              }), {
                actions: e.hideActions ? void 0 : () => i.actions?.({
                  save: b,
                  cancel: w,
                  isPristine: k
                }) ?? m()
              });
            }
          })]
        }), i.default?.()])
      });
    });
  }
}), uP = dt({
  props: {
    modelValue: {
      /** @type import('vue').PropType<import('../../types.js').VjsfColorPickerNode> */
      type: Object,
      required: !0
    },
    statefulLayout: {
      /** @type import('vue').PropType<import('../../types.js').VjsfStatefulLayout> */
      type: Object,
      required: !0
    }
  },
  setup(e) {
    Ge({}, "VjsfColorPicker");
    const a = vt("VColorInput", { colorPip: !0, hideActions: !0 }), { inputProps: i, localData: r, compSlots: n } = mt(
      W(e, "modelValue"),
      e.statefulLayout,
      { layoutPropsMap: ["placeholder"] }
    ), t = I(() => ({
      ...a.value,
      ...i.value,
      modelValue: r.value
    }));
    return ce(t, () => console.log("colorInputProps", t.value), { immediate: !0 }), () => Oe(oP, t.value, n.value);
  }
}), wh = /* @__PURE__ */ Symbol.for("vuetify:v-chip-group"), cP = ee({
  baseColor: String,
  column: Boolean,
  filter: Boolean,
  valueComparator: {
    type: Function,
    default: bt
  },
  ...Fu({
    scrollToActive: !1
  }),
  ...Se(),
  ...Mr({
    selectedClass: "v-chip--selected"
  }),
  ...Be(),
  ...Qe(),
  ...ja({
    variant: "tonal"
  })
}, "VChipGroup");
de()({
  name: "VChipGroup",
  props: cP(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, a) {
    let {
      slots: i
    } = a;
    const {
      themeClasses: r
    } = ut(e), {
      isSelected: n,
      select: t,
      next: s,
      prev: o,
      selected: l
    } = Hn(e, wh);
    return da({
      VChip: {
        baseColor: W(() => e.baseColor),
        color: W(() => e.color),
        disabled: W(() => e.disabled),
        filter: W(() => e.filter),
        variant: W(() => e.variant)
      }
    }), me(() => {
      const u = _s.filterProps(e);
      return C(_s, re(u, {
        class: ["v-chip-group", {
          "v-chip-group--column": e.column
        }, r.value, e.class],
        style: e.style
      }), {
        default: () => [i.default?.({
          isSelected: n,
          select: t,
          next: s,
          prev: o,
          selected: l.value
        })]
      });
    }), {};
  }
});
const dP = ee({
  activeClass: String,
  appendAvatar: String,
  appendIcon: Pe,
  baseColor: String,
  closable: Boolean,
  closeIcon: {
    type: Pe,
    default: "$delete"
  },
  closeLabel: {
    type: String,
    default: "$vuetify.close"
  },
  draggable: Boolean,
  filter: Boolean,
  filterIcon: {
    type: Pe,
    default: "$complete"
  },
  label: Boolean,
  link: {
    type: Boolean,
    default: void 0
  },
  pill: Boolean,
  prependAvatar: String,
  prependIcon: Pe,
  ripple: {
    type: [Boolean, Object],
    default: !0
  },
  text: {
    type: [String, Number, Boolean],
    default: void 0
  },
  modelValue: {
    type: Boolean,
    default: !0
  },
  onClick: Et(),
  onClickOnce: Et(),
  ...Aa(),
  ...Se(),
  ...Kt(),
  ...ea(),
  ...Rr(),
  ...$t(),
  ...Hs(),
  ...Nr(),
  ...Be({
    tag: "span"
  }),
  ...Qe(),
  ...ja({
    variant: "tonal"
  })
}, "VChip"), vn = de()({
  name: "VChip",
  directives: {
    vRipple: At
  },
  props: dP(),
  emits: {
    "click:close": (e) => !0,
    "update:modelValue": (e) => !0,
    "group:selected": (e) => !0,
    click: (e) => !0
  },
  setup(e, a) {
    let {
      attrs: i,
      emit: r,
      slots: n
    } = a;
    const {
      t
    } = nt(), {
      borderClasses: s
    } = Ta(e), {
      densityClasses: o
    } = Qt(e), {
      elevationClasses: l
    } = ta(e), {
      roundedClasses: u
    } = _t(e), {
      sizeClasses: c
    } = Lr(e), {
      themeClasses: d
    } = ut(e), f = $e(e, "modelValue"), v = jn(e, wh, !1), g = jn(e, ph, !1), h = Ks(e, i), y = W(() => e.link !== !1 && h.isLink.value), m = I(() => !e.disabled && e.link !== !1 && (!!v || e.link || h.isClickable.value)), p = W(() => ({
      "aria-label": t(e.closeLabel),
      disabled: e.disabled,
      onClick(P) {
        P.preventDefault(), P.stopPropagation(), f.value = !1, r("click:close", P);
      }
    }));
    ce(f, (P) => {
      P ? (v?.register(), g?.register()) : (v?.unregister(), g?.unregister());
    });
    const {
      colorClasses: b,
      colorStyles: w,
      variantClasses: k
    } = Kn(() => ({
      color: !v || v.isSelected.value ? e.color ?? e.baseColor : e.baseColor,
      variant: e.variant
    }));
    function S(P) {
      r("click", P), m.value && (h.navigate?.(P), v?.toggle());
    }
    function _(P) {
      (P.key === "Enter" || P.key === " ") && (P.preventDefault(), S(P));
    }
    return () => {
      const P = h.isLink.value ? "a" : e.tag, M = !!(e.appendIcon || e.appendAvatar), q = !!(M || n.append), K = !!(n.close || e.closable), j = !!(n.filter || e.filter) && v, H = !!(e.prependIcon || e.prependAvatar), B = !!(H || n.prepend);
      return f.value && Je(C(P, re(h.linkProps, {
        class: ["v-chip", {
          "v-chip--disabled": e.disabled,
          "v-chip--label": e.label,
          "v-chip--link": m.value,
          "v-chip--filter": j,
          "v-chip--pill": e.pill,
          [`${e.activeClass}`]: e.activeClass && h.isActive?.value
        }, d.value, s.value, b.value, o.value, l.value, u.value, c.value, k.value, v?.selectedClass.value, e.class],
        style: [w.value, e.style],
        disabled: e.disabled || void 0,
        draggable: e.draggable,
        tabindex: m.value ? 0 : void 0,
        onClick: S,
        onKeydown: m.value && !y.value && _
      }), {
        default: () => [yn(m.value, "v-chip"), j && C(Tp, {
          key: "filter"
        }, {
          default: () => [Je(D("div", {
            class: "v-chip__filter"
          }, [n.filter ? C(je, {
            key: "filter-defaults",
            disabled: !e.filterIcon,
            defaults: {
              VIcon: {
                icon: e.filterIcon
              }
            }
          }, n.filter) : C(xe, {
            key: "filter-icon",
            icon: e.filterIcon
          }, null)]), [[ya, v.isSelected.value]])]
        }), B && D("div", {
          key: "prepend",
          class: "v-chip__prepend"
        }, [n.prepend ? C(je, {
          key: "prepend-defaults",
          disabled: !H,
          defaults: {
            VAvatar: {
              image: e.prependAvatar,
              start: !0
            },
            VIcon: {
              icon: e.prependIcon,
              start: !0
            }
          }
        }, n.prepend) : D(pe, null, [e.prependIcon && C(xe, {
          key: "prepend-icon",
          icon: e.prependIcon,
          start: !0
        }, null), e.prependAvatar && C(Yt, {
          key: "prepend-avatar",
          image: e.prependAvatar,
          start: !0
        }, null)])]), D("div", {
          class: "v-chip__content",
          "data-no-activator": ""
        }, [n.default?.({
          isSelected: v?.isSelected.value,
          selectedClass: v?.selectedClass.value,
          select: v?.select,
          toggle: v?.toggle,
          value: v?.value.value,
          disabled: e.disabled
        }) ?? Ue(e.text)]), q && D("div", {
          key: "append",
          class: "v-chip__append"
        }, [n.append ? C(je, {
          key: "append-defaults",
          disabled: !M,
          defaults: {
            VAvatar: {
              end: !0,
              image: e.appendAvatar
            },
            VIcon: {
              end: !0,
              icon: e.appendIcon
            }
          }
        }, n.append) : D(pe, null, [e.appendIcon && C(xe, {
          key: "append-icon",
          end: !0,
          icon: e.appendIcon
        }, null), e.appendAvatar && C(Yt, {
          key: "append-avatar",
          end: !0,
          image: e.appendAvatar
        }, null)])]), K && D("button", re({
          key: "close",
          class: "v-chip__close",
          type: "button",
          "data-testid": "close-chip"
        }, p.value), [n.close ? C(je, {
          key: "close-defaults",
          defaults: {
            VIcon: {
              icon: e.closeIcon,
              size: "x-small"
            }
          }
        }, n.close) : C(xe, {
          key: "close-icon",
          icon: e.closeIcon,
          size: "x-small"
        }, null)])]
      }), [[At, m.value && e.ripple, null]]);
    };
  }
}), zo = /* @__PURE__ */ Symbol.for("vuetify:list");
function Sh() {
  let {
    filterable: e
  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
    filterable: !1
  };
  const a = qe(zo, {
    filterable: !1,
    hasPrepend: fe(!1),
    updateHasPrepend: () => null
  }), i = {
    filterable: a.filterable || e,
    hasPrepend: fe(!1),
    updateHasPrepend: (r) => {
      r && (i.hasPrepend.value = r);
    }
  };
  return ht(zo, i), a;
}
function $h() {
  return qe(zo, null);
}
const Hu = (e) => {
  const a = {
    activate: (i) => {
      let {
        id: r,
        value: n,
        activated: t
      } = i;
      return r = Ye(r), e && !n && t.size === 1 && t.has(r) || (n ? t.add(r) : t.delete(r)), t;
    },
    in: (i, r, n) => {
      let t = /* @__PURE__ */ new Set();
      if (i != null)
        for (const s of Ze(i))
          t = a.activate({
            id: s,
            value: !0,
            activated: new Set(t),
            children: r,
            parents: n
          });
      return t;
    },
    out: (i) => Array.from(i)
  };
  return a;
}, _h = (e) => {
  const a = Hu(e);
  return {
    activate: (r) => {
      let {
        activated: n,
        id: t,
        ...s
      } = r;
      t = Ye(t);
      const o = n.has(t) ? /* @__PURE__ */ new Set([t]) : /* @__PURE__ */ new Set();
      return a.activate({
        ...s,
        id: t,
        activated: o
      });
    },
    in: (r, n, t) => {
      let s = /* @__PURE__ */ new Set();
      if (r != null) {
        const o = Ze(r);
        o.length && (s = a.in(o.slice(0, 1), n, t));
      }
      return s;
    },
    out: (r, n, t) => a.out(r, n, t)
  };
}, fP = (e) => {
  const a = Hu(e);
  return {
    activate: (r) => {
      let {
        id: n,
        activated: t,
        children: s,
        ...o
      } = r;
      return n = Ye(n), s.has(n) ? t : a.activate({
        id: n,
        activated: t,
        children: s,
        ...o
      });
    },
    in: a.in,
    out: a.out
  };
}, mP = (e) => {
  const a = _h(e);
  return {
    activate: (r) => {
      let {
        id: n,
        activated: t,
        children: s,
        ...o
      } = r;
      return n = Ye(n), s.has(n) ? t : a.activate({
        id: n,
        activated: t,
        children: s,
        ...o
      });
    },
    in: a.in,
    out: a.out
  };
}, vP = {
  open: (e) => {
    let {
      id: a,
      value: i,
      opened: r,
      parents: n
    } = e;
    if (i) {
      const t = /* @__PURE__ */ new Set();
      t.add(a);
      let s = n.get(a);
      for (; s != null; )
        t.add(s), s = n.get(s);
      return t;
    } else
      return r.delete(a), r;
  },
  select: () => null
}, Ph = {
  open: (e) => {
    let {
      id: a,
      value: i,
      opened: r,
      parents: n
    } = e;
    if (i) {
      let t = n.get(a);
      for (r.add(a); t != null && t !== a; )
        r.add(t), t = n.get(t);
      return r;
    } else
      r.delete(a);
    return r;
  },
  select: () => null
}, pP = {
  open: Ph.open,
  select: (e) => {
    let {
      id: a,
      value: i,
      opened: r,
      parents: n
    } = e;
    if (!i) return r;
    const t = [];
    let s = n.get(a);
    for (; s != null; )
      t.push(s), s = n.get(s);
    return new Set(t);
  }
}, Uu = (e) => {
  const a = {
    select: (i) => {
      let {
        id: r,
        value: n,
        selected: t
      } = i;
      if (r = Ye(r), e && !n) {
        const s = Array.from(t.entries()).reduce((o, l) => {
          let [u, c] = l;
          return c === "on" && o.push(u), o;
        }, []);
        if (s.length === 1 && s[0] === r) return t;
      }
      return t.set(r, n ? "on" : "off"), t;
    },
    in: (i, r, n, t) => {
      const s = /* @__PURE__ */ new Map();
      for (const o of i || [])
        a.select({
          id: o,
          value: !0,
          selected: s,
          children: r,
          parents: n,
          disabled: t
        });
      return s;
    },
    out: (i) => {
      const r = [];
      for (const [n, t] of i.entries())
        t === "on" && r.push(n);
      return r;
    }
  };
  return a;
}, Ch = (e) => {
  const a = Uu(e);
  return {
    select: (r) => {
      let {
        selected: n,
        id: t,
        ...s
      } = r;
      t = Ye(t);
      const o = n.has(t) ? /* @__PURE__ */ new Map([[t, n.get(t)]]) : /* @__PURE__ */ new Map();
      return a.select({
        ...s,
        id: t,
        selected: o
      });
    },
    in: (r, n, t, s) => r?.length ? a.in(r.slice(0, 1), n, t, s) : /* @__PURE__ */ new Map(),
    out: (r, n, t) => a.out(r, n, t)
  };
}, hP = (e) => {
  const a = Uu(e);
  return {
    select: (r) => {
      let {
        id: n,
        selected: t,
        children: s,
        ...o
      } = r;
      return n = Ye(n), s.has(n) ? t : a.select({
        id: n,
        selected: t,
        children: s,
        ...o
      });
    },
    in: a.in,
    out: a.out
  };
}, yP = (e) => {
  const a = Ch(e);
  return {
    select: (r) => {
      let {
        id: n,
        selected: t,
        children: s,
        ...o
      } = r;
      return n = Ye(n), s.has(n) ? t : a.select({
        id: n,
        selected: t,
        children: s,
        ...o
      });
    },
    in: a.in,
    out: a.out
  };
}, xh = (e) => {
  const a = {
    select: (i) => {
      let {
        id: r,
        value: n,
        selected: t,
        children: s,
        parents: o,
        disabled: l
      } = i;
      r = Ye(r);
      const u = new Map(t), c = [r];
      for (; c.length; ) {
        const f = c.shift();
        l.has(f) || t.set(Ye(f), n ? "on" : "off"), s.has(f) && c.push(...s.get(f));
      }
      let d = Ye(o.get(r));
      for (; d; ) {
        let f = !0, v = !0;
        for (const g of s.get(d)) {
          const h = Ye(g);
          if (!l.has(h) && (t.get(h) !== "on" && (f = !1), t.has(h) && t.get(h) !== "off" && (v = !1), !f && !v))
            break;
        }
        t.set(d, f ? "on" : v ? "off" : "indeterminate"), d = Ye(o.get(d));
      }
      return e && !n && Array.from(t.entries()).reduce((v, g) => {
        let [h, y] = g;
        return y === "on" && v.push(h), v;
      }, []).length === 0 ? u : t;
    },
    in: (i, r, n) => {
      let t = /* @__PURE__ */ new Map();
      for (const s of i || [])
        t = a.select({
          id: s,
          value: !0,
          selected: t,
          children: r,
          parents: n,
          disabled: /* @__PURE__ */ new Set()
        });
      return t;
    },
    out: (i, r) => {
      const n = [];
      for (const [t, s] of i.entries())
        s === "on" && !r.has(t) && n.push(t);
      return n;
    }
  };
  return a;
}, gP = (e) => {
  const a = xh(e);
  return {
    select: a.select,
    in: a.in,
    out: (r, n, t) => {
      const s = [];
      for (const [o, l] of r.entries())
        if (l === "on") {
          if (t.has(o)) {
            const u = t.get(o);
            if (r.get(u) === "on") continue;
          }
          s.push(o);
        }
      return s;
    }
  };
}, qn = /* @__PURE__ */ Symbol.for("vuetify:nested"), Vh = {
  id: fe(),
  root: {
    itemsRegistration: ie("render"),
    register: () => null,
    unregister: () => null,
    updateDisabled: () => null,
    children: ie(/* @__PURE__ */ new Map()),
    parents: ie(/* @__PURE__ */ new Map()),
    disabled: ie(/* @__PURE__ */ new Set()),
    open: () => null,
    openOnSelect: () => null,
    activate: () => null,
    select: () => null,
    activatable: ie(!1),
    selectable: ie(!1),
    opened: ie(/* @__PURE__ */ new Set()),
    activated: ie(/* @__PURE__ */ new Set()),
    selected: ie(/* @__PURE__ */ new Map()),
    selectedValues: ie([]),
    getPath: () => []
  }
}, bP = ee({
  activatable: Boolean,
  selectable: Boolean,
  activeStrategy: [String, Function, Object],
  selectStrategy: [String, Function, Object],
  openStrategy: [String, Object],
  opened: null,
  activated: null,
  selected: null,
  mandatory: Boolean,
  itemsRegistration: {
    type: String,
    default: "render"
  }
}, "nested"), kP = (e, a, i) => {
  let r = !1;
  const n = fe(/* @__PURE__ */ new Map()), t = fe(/* @__PURE__ */ new Map()), s = fe(/* @__PURE__ */ new Set()), o = $e(e, "opened", e.opened, (b) => new Set(Array.isArray(b) ? b.map((w) => Ye(w)) : b), (b) => [...b.values()]), l = I(() => {
    if (typeof e.activeStrategy == "object") return e.activeStrategy;
    if (typeof e.activeStrategy == "function") return e.activeStrategy(e.mandatory);
    switch (e.activeStrategy) {
      case "leaf":
        return fP(e.mandatory);
      case "single-leaf":
        return mP(e.mandatory);
      case "independent":
        return Hu(e.mandatory);
      default:
        return _h(e.mandatory);
    }
  }), u = I(() => {
    if (typeof e.selectStrategy == "object") return e.selectStrategy;
    if (typeof e.selectStrategy == "function") return e.selectStrategy(e.mandatory);
    switch (e.selectStrategy) {
      case "single-leaf":
        return yP(e.mandatory);
      case "leaf":
        return hP(e.mandatory);
      case "independent":
        return Uu(e.mandatory);
      case "single-independent":
        return Ch(e.mandatory);
      case "trunk":
        return gP(e.mandatory);
      default:
        return xh(e.mandatory);
    }
  }), c = I(() => {
    if (typeof e.openStrategy == "object") return e.openStrategy;
    switch (e.openStrategy) {
      case "list":
        return pP;
      case "single":
        return vP;
      default:
        return Ph;
    }
  }), d = $e(e, "activated", e.activated, (b) => l.value.in(b, n.value, t.value), (b) => l.value.out(b, n.value, t.value)), f = $e(e, "selected", e.selected, (b) => u.value.in(b, n.value, t.value, s.value), (b) => u.value.out(b, n.value, t.value));
  ha(() => {
    r = !0;
  });
  function v(b) {
    const w = [];
    let k = Ye(b);
    for (; k !== void 0; )
      w.unshift(k), k = t.value.get(k);
    return w;
  }
  const g = ft("nested"), h = /* @__PURE__ */ new Set(), y = jw(() => {
    Ee(() => {
      n.value = new Map(n.value), t.value = new Map(t.value);
    });
  }, 100);
  ce(() => [a.value, ot(i)], () => {
    e.itemsRegistration === "props" && m();
  }, {
    immediate: !0
  });
  function m() {
    const b = /* @__PURE__ */ new Map(), w = /* @__PURE__ */ new Map(), k = /* @__PURE__ */ new Set(), S = ot(i) ? (M) => Ye(M.raw) : (M) => M.value, _ = [...a.value];
    let P = 0;
    for (; P < _.length; ) {
      const M = _[P++], q = S(M);
      if (M.children) {
        const K = [];
        for (const j of M.children) {
          const H = S(j);
          b.set(H, q), K.push(H), _.push(j);
        }
        w.set(q, K);
      }
      M.props.disabled && k.add(q);
    }
    n.value = w, t.value = b, s.value = k;
  }
  const p = {
    id: fe(),
    root: {
      opened: o,
      activatable: W(() => e.activatable),
      selectable: W(() => e.selectable),
      activated: d,
      selected: f,
      selectedValues: I(() => {
        const b = [];
        for (const [w, k] of f.value.entries())
          k === "on" && b.push(w);
        return b;
      }),
      itemsRegistration: W(() => e.itemsRegistration),
      register: (b, w, k, S) => {
        if (h.has(b)) {
          const _ = v(b).map(String).join(" -> "), P = v(w).concat(b).map(String).join(" -> ");
          fu(`Multiple nodes with the same ID
	${_}
	${P}`);
          return;
        } else
          h.add(b);
        w && b !== w && t.value.set(b, w), k && s.value.add(b), S && n.value.set(b, []), w != null && n.value.set(w, [...n.value.get(w) || [], b]), y();
      },
      unregister: (b) => {
        if (r) return;
        h.delete(b), n.value.delete(b), s.value.delete(b);
        const w = t.value.get(b);
        if (w) {
          const k = n.value.get(w) ?? [];
          n.value.set(w, k.filter((S) => S !== b));
        }
        t.value.delete(b), y();
      },
      updateDisabled: (b, w) => {
        w ? s.value.add(b) : s.value.delete(b);
      },
      open: (b, w, k) => {
        g.emit("click:open", {
          id: b,
          value: w,
          path: v(b),
          event: k
        });
        const S = c.value.open({
          id: b,
          value: w,
          opened: new Set(o.value),
          children: n.value,
          parents: t.value,
          event: k
        });
        S && (o.value = S);
      },
      openOnSelect: (b, w, k) => {
        const S = c.value.select({
          id: b,
          value: w,
          selected: new Map(f.value),
          opened: new Set(o.value),
          children: n.value,
          parents: t.value,
          event: k
        });
        S && (o.value = S);
      },
      select: (b, w, k) => {
        g.emit("click:select", {
          id: b,
          value: w,
          path: v(b),
          event: k
        });
        const S = u.value.select({
          id: b,
          value: w,
          selected: new Map(f.value),
          children: n.value,
          parents: t.value,
          disabled: s.value,
          event: k
        });
        S && (f.value = S), p.root.openOnSelect(b, w, k);
      },
      activate: (b, w, k) => {
        if (!e.activatable)
          return p.root.select(b, !0, k);
        g.emit("click:activate", {
          id: b,
          value: w,
          path: v(b),
          event: k
        });
        const S = l.value.activate({
          id: b,
          value: w,
          activated: new Set(d.value),
          children: n.value,
          parents: t.value,
          event: k
        });
        if (S.size !== d.value.size)
          d.value = S;
        else {
          for (const _ of S)
            if (!d.value.has(_)) {
              d.value = S;
              return;
            }
          for (const _ of d.value)
            if (!S.has(_)) {
              d.value = S;
              return;
            }
        }
      },
      children: n,
      parents: t,
      disabled: s,
      getPath: v
    }
  };
  return ht(qn, p), p.root;
}, Ih = (e, a, i) => {
  const r = qe(qn, Vh), n = /* @__PURE__ */ Symbol("nested item"), t = I(() => {
    const o = Ye(ot(e));
    return o !== void 0 ? o : n;
  }), s = {
    ...r,
    id: t,
    open: (o, l) => r.root.open(t.value, o, l),
    openOnSelect: (o, l) => r.root.openOnSelect(t.value, o, l),
    isOpen: I(() => r.root.opened.value.has(t.value)),
    parent: I(() => r.root.parents.value.get(t.value)),
    activate: (o, l) => r.root.activate(t.value, o, l),
    isActivated: I(() => r.root.activated.value.has(t.value)),
    select: (o, l) => r.root.select(t.value, o, l),
    isSelected: I(() => r.root.selected.value.get(t.value) === "on"),
    isIndeterminate: I(() => r.root.selected.value.get(t.value) === "indeterminate"),
    isLeaf: I(() => !r.root.children.value.get(t.value)),
    isGroupActivator: r.isGroupActivator
  };
  return Cr(() => {
    r.isGroupActivator || r.root.itemsRegistration.value === "props" || Ee(() => {
      r.root.register(t.value, r.id.value, ot(a), i);
    });
  }), ha(() => {
    r.isGroupActivator || r.root.itemsRegistration.value === "props" || r.root.unregister(t.value);
  }), ce(t, (o, l) => {
    r.isGroupActivator || r.root.itemsRegistration.value === "props" || (r.root.unregister(l), Ee(() => {
      r.root.register(o, r.id.value, ot(a), i);
    }));
  }), ce(() => ot(a), (o) => {
    r.root.updateDisabled(t.value, o);
  }), i && ht(qn, s), s;
}, wP = () => {
  const e = qe(qn, Vh);
  ht(qn, {
    ...e,
    isGroupActivator: !0
  });
}, SP = ba({
  name: "VListGroupActivator",
  setup(e, a) {
    let {
      slots: i
    } = a;
    return wP(), () => i.default?.();
  }
}), $P = ee({
  /* @deprecated */
  activeColor: String,
  baseColor: String,
  color: String,
  collapseIcon: {
    type: Pe,
    default: "$collapse"
  },
  disabled: Boolean,
  expandIcon: {
    type: Pe,
    default: "$expand"
  },
  rawId: [String, Number],
  prependIcon: Pe,
  appendIcon: Pe,
  fluid: Boolean,
  subgroup: Boolean,
  title: String,
  value: null,
  ...Se(),
  ...Be()
}, "VListGroup"), Km = de()({
  name: "VListGroup",
  props: $P(),
  setup(e, a) {
    let {
      slots: i
    } = a;
    const {
      isOpen: r,
      open: n,
      id: t
    } = Ih(() => e.value, () => e.disabled, !0), s = I(() => `v-list-group--id-${String(e.rawId ?? t.value)}`), o = $h(), {
      isBooted: l
    } = fh(), u = qe(qn), c = W(() => u?.root?.itemsRegistration.value === "render");
    function d(h) {
      ["INPUT", "TEXTAREA"].includes(h.target?.tagName) || n(!r.value, h);
    }
    const f = I(() => ({
      onClick: d,
      class: "v-list-group__header",
      id: s.value
    })), v = I(() => r.value ? e.collapseIcon : e.expandIcon), g = I(() => ({
      VListItem: {
        activeColor: e.activeColor,
        baseColor: e.baseColor,
        color: e.color,
        prependIcon: e.prependIcon || e.subgroup && v.value,
        appendIcon: e.appendIcon || !e.subgroup && v.value,
        title: e.title,
        value: e.value
      }
    }));
    return me(() => C(e.tag, {
      class: ue(["v-list-group", {
        "v-list-group--prepend": o?.hasPrepend.value,
        "v-list-group--fluid": e.fluid,
        "v-list-group--subgroup": e.subgroup,
        "v-list-group--open": r.value
      }, e.class]),
      style: be(e.style)
    }, {
      default: () => [i.activator && C(je, {
        defaults: g.value
      }, {
        default: () => [C(SP, null, {
          default: () => [i.activator({
            props: f.value,
            isOpen: r.value
          })]
        })]
      }), C(Wt, {
        transition: {
          component: xu
        },
        disabled: !l.value
      }, {
        default: () => [c.value ? Je(D("div", {
          class: "v-list-group__items",
          role: "group",
          "aria-labelledby": s.value
        }, [i.default?.()]), [[ya, r.value]]) : r.value && D("div", {
          class: "v-list-group__items",
          role: "group",
          "aria-labelledby": s.value
        }, [i.default?.()])]
      })]
    })), {
      isOpen: r
    };
  }
}), _P = ee({
  opacity: [Number, String],
  ...Se(),
  ...Be()
}, "VListItemSubtitle"), Oh = de()({
  name: "VListItemSubtitle",
  props: _P(),
  setup(e, a) {
    let {
      slots: i
    } = a;
    return me(() => C(e.tag, {
      class: ue(["v-list-item-subtitle", e.class]),
      style: be([{
        "--v-list-item-subtitle-opacity": e.opacity
      }, e.style])
    }, i)), {};
  }
}), Bo = Fn("v-list-item-title"), PP = ee({
  active: {
    type: Boolean,
    default: void 0
  },
  activeClass: String,
  /* @deprecated */
  activeColor: String,
  appendAvatar: String,
  appendIcon: Pe,
  baseColor: String,
  disabled: Boolean,
  lines: [Boolean, String],
  link: {
    type: Boolean,
    default: void 0
  },
  nav: Boolean,
  prependAvatar: String,
  prependIcon: Pe,
  ripple: {
    type: [Boolean, Object],
    default: !0
  },
  slim: Boolean,
  prependGap: [Number, String],
  subtitle: {
    type: [String, Number, Boolean],
    default: void 0
  },
  title: {
    type: [String, Number, Boolean],
    default: void 0
  },
  value: null,
  onClick: Et(),
  onClickOnce: Et(),
  ...Aa(),
  ...Se(),
  ...Kt(),
  ...Mt(),
  ...ea(),
  ...$t(),
  ...Hs(),
  ...Be(),
  ...Qe(),
  ...ja({
    variant: "text"
  })
}, "VListItem"), it = de()({
  name: "VListItem",
  directives: {
    vRipple: At
  },
  props: PP(),
  emits: {
    click: (e) => !0
  },
  setup(e, a) {
    let {
      attrs: i,
      slots: r,
      emit: n
    } = a;
    const t = Ks(e, i), s = I(() => e.value === void 0 ? t.href.value : e.value), {
      activate: o,
      isActivated: l,
      select: u,
      isOpen: c,
      isSelected: d,
      isIndeterminate: f,
      isGroupActivator: v,
      root: g,
      parent: h,
      openOnSelect: y,
      id: m
    } = Ih(s, () => e.disabled, !1), p = $h(), b = I(() => e.active !== !1 && (e.active || t.isActive?.value || (g.activatable.value ? l.value : d.value))), w = W(() => e.link !== !1 && t.isLink.value), k = I(() => !!p && (g.selectable.value || g.activatable.value || e.value != null)), S = I(() => !e.disabled && e.link !== !1 && (e.link || t.isClickable.value || k.value)), _ = I(() => p ? w.value ? "link" : k.value ? "option" : "listitem" : void 0), P = I(() => {
      if (k.value)
        return g.activatable.value ? l.value : g.selectable.value ? d.value : b.value;
    }), M = W(() => e.rounded || e.nav), q = W(() => e.color ?? e.activeColor), K = W(() => ({
      color: b.value ? q.value ?? e.baseColor : e.baseColor,
      variant: e.variant
    }));
    ce(() => t.isActive?.value, (z) => {
      z && j();
    }), Cr(() => {
      t.isActive?.value && Ee(() => j());
    });
    function j() {
      h.value != null && g.open(h.value, !0), y(!0);
    }
    const {
      themeClasses: H
    } = ut(e), {
      borderClasses: B
    } = Ta(e), {
      colorClasses: L,
      colorStyles: O,
      variantClasses: U
    } = Kn(K), {
      densityClasses: Z
    } = Qt(e), {
      dimensionStyles: J
    } = Rt(e), {
      elevationClasses: A
    } = ta(e), {
      roundedClasses: T
    } = _t(M), E = W(() => e.lines ? `v-list-item--${e.lines}-line` : void 0), x = W(() => e.ripple !== void 0 && e.ripple && p?.filterable ? {
      keys: ["Enter"]
    } : e.ripple), $ = I(() => ({
      isActive: b.value,
      select: u,
      isOpen: c.value,
      isSelected: d.value,
      isIndeterminate: f.value
    }));
    function V(z) {
      n("click", z), !["INPUT", "TEXTAREA"].includes(z.target?.tagName) && S.value && (t.navigate?.(z), !v && (g.activatable.value ? o(!l.value, z) : (g.selectable.value || e.value != null && !w.value) && u(!d.value, z)));
    }
    function F(z) {
      const X = z.target;
      ["INPUT", "TEXTAREA"].includes(X.tagName) || (z.key === "Enter" || z.key === " " && !p?.filterable) && (z.preventDefault(), z.stopPropagation(), z.target.dispatchEvent(new MouseEvent("click", z)));
    }
    return me(() => {
      const z = w.value ? "a" : e.tag, X = r.title || e.title != null, Q = r.subtitle || e.subtitle != null, te = !!(e.appendAvatar || e.appendIcon), N = !!(te || r.append), R = !!(e.prependAvatar || e.prependIcon), G = !!(R || r.prepend);
      return p?.updateHasPrepend(G), e.activeColor && H0("active-color", ["color", "base-color"]), Je(C(z, re(t.linkProps, {
        class: ["v-list-item", {
          "v-list-item--active": b.value,
          "v-list-item--disabled": e.disabled,
          "v-list-item--link": S.value,
          "v-list-item--nav": e.nav,
          "v-list-item--slim": e.slim,
          [`${e.activeClass}`]: e.activeClass && b.value
        }, H.value, B.value, L.value, Z.value, A.value, E.value, T.value, U.value, e.class],
        style: [{
          "--v-list-prepend-gap": he(e.prependGap)
        }, O.value, J.value, e.style],
        tabindex: S.value ? p ? -2 : 0 : void 0,
        "aria-selected": P.value,
        role: _.value,
        onClick: V,
        onKeydown: S.value && !w.value && F
      }), {
        default: () => [yn(S.value || b.value, "v-list-item"), G && D("div", {
          key: "prepend",
          class: "v-list-item__prepend"
        }, [r.prepend ? C(je, {
          key: "prepend-defaults",
          disabled: !R,
          defaults: {
            VAvatar: {
              density: e.density,
              image: e.prependAvatar
            },
            VIcon: {
              density: e.density,
              icon: e.prependIcon
            },
            VListItemAction: {
              start: !0
            }
          }
        }, {
          default: () => [r.prepend?.($.value)]
        }) : D(pe, null, [e.prependAvatar && C(Yt, {
          key: "prepend-avatar",
          density: e.density,
          image: e.prependAvatar
        }, null), e.prependIcon && C(xe, {
          key: "prepend-icon",
          density: e.density,
          icon: e.prependIcon
        }, null)]), D("div", {
          class: "v-list-item__spacer"
        }, null)]), D("div", {
          class: "v-list-item__content",
          "data-no-activator": ""
        }, [X && C(Bo, {
          key: "title"
        }, {
          default: () => [r.title?.({
            title: e.title
          }) ?? Ue(e.title)]
        }), Q && C(Oh, {
          key: "subtitle"
        }, {
          default: () => [r.subtitle?.({
            subtitle: e.subtitle
          }) ?? Ue(e.subtitle)]
        }), r.default?.($.value)]), N && D("div", {
          key: "append",
          class: "v-list-item__append"
        }, [r.append ? C(je, {
          key: "append-defaults",
          disabled: !te,
          defaults: {
            VAvatar: {
              density: e.density,
              image: e.appendAvatar
            },
            VIcon: {
              density: e.density,
              icon: e.appendIcon
            },
            VListItemAction: {
              end: !0
            }
          }
        }, {
          default: () => [r.append?.($.value)]
        }) : D(pe, null, [e.appendIcon && C(xe, {
          key: "append-icon",
          density: e.density,
          icon: e.appendIcon
        }, null), e.appendAvatar && C(Yt, {
          key: "append-avatar",
          density: e.density,
          image: e.appendAvatar
        }, null)]), D("div", {
          class: "v-list-item__spacer"
        }, null)])]
      }), [[At, S.value && x.value]]);
    }), {
      activate: o,
      isActivated: l,
      isGroupActivator: v,
      isSelected: d,
      list: p,
      select: u,
      root: g,
      id: m,
      link: t
    };
  }
}), CP = ee({
  color: String,
  inset: Boolean,
  sticky: Boolean,
  title: String,
  ...Se(),
  ...Be()
}, "VListSubheader"), kn = de()({
  name: "VListSubheader",
  props: CP(),
  setup(e, a) {
    let {
      slots: i
    } = a;
    const {
      textColorClasses: r,
      textColorStyles: n
    } = kt(() => e.color);
    return me(() => {
      const t = !!(i.default || e.title);
      return C(e.tag, {
        class: ue(["v-list-subheader", {
          "v-list-subheader--inset": e.inset,
          "v-list-subheader--sticky": e.sticky
        }, r.value, e.class]),
        style: be([{
          textColorStyles: n
        }, e.style])
      }, {
        default: () => [t && D("div", {
          class: "v-list-subheader__text"
        }, [i.default?.() ?? e.title])]
      });
    }), {};
  }
}), xP = ee({
  items: Array,
  returnObject: Boolean
}, "VListChildren"), Eh = de()({
  name: "VListChildren",
  props: xP(),
  setup(e, a) {
    let {
      slots: i
    } = a;
    return Sh(), () => i.default?.() ?? e.items?.map((r) => {
      let {
        children: n,
        props: t,
        type: s,
        raw: o
      } = r;
      if (s === "divider")
        return i.divider?.({
          props: t
        }) ?? C(ia, t, null);
      if (s === "subheader")
        return i.subheader?.({
          props: t
        }) ?? C(kn, t, null);
      const l = {
        subtitle: i.subtitle ? (c) => i.subtitle?.({
          ...c,
          item: o
        }) : void 0,
        prepend: i.prepend ? (c) => i.prepend?.({
          ...c,
          item: o
        }) : void 0,
        append: i.append ? (c) => i.append?.({
          ...c,
          item: o
        }) : void 0,
        title: i.title ? (c) => i.title?.({
          ...c,
          item: o
        }) : void 0
      }, u = Km.filterProps(t);
      return n ? C(Km, re(u, {
        value: e.returnObject ? o : t?.value,
        rawId: t?.value
      }), {
        activator: (c) => {
          let {
            props: d
          } = c;
          const f = re(t, d, {
            value: e.returnObject ? o : t.value
          });
          return i.header ? i.header({
            props: f
          }) : C(it, f, l);
        },
        default: () => C(Eh, {
          items: n,
          returnObject: e.returnObject
        }, i)
      }) : i.item ? i.item({
        props: t
      }) : C(it, re(t, {
        value: e.returnObject ? o : t.value
      }), l);
    });
  }
}), Ah = ee({
  items: {
    type: Array,
    default: () => []
  },
  itemTitle: {
    type: [String, Array, Function],
    default: "title"
  },
  itemValue: {
    type: [String, Array, Function],
    default: "value"
  },
  itemChildren: {
    type: [Boolean, String, Array, Function],
    default: "children"
  },
  itemProps: {
    type: [Boolean, String, Array, Function],
    default: "props"
  },
  itemType: {
    type: [Boolean, String, Array, Function],
    default: "type"
  },
  returnObject: Boolean,
  valueComparator: Function
}, "list-items"), VP = /* @__PURE__ */ new Set(["item", "divider", "subheader"]);
function ra(e, a) {
  const i = It(a, e.itemTitle, a), r = It(a, e.itemValue, i), n = It(a, e.itemChildren), t = e.itemProps === !0 ? typeof a == "object" && a != null && !Array.isArray(a) ? "children" in a ? Le(a, ["children"]) : a : void 0 : It(a, e.itemProps);
  let s = It(a, e.itemType, "item");
  VP.has(s) || (s = "item");
  const o = {
    title: i,
    value: r,
    ...t
  };
  return {
    type: s,
    title: String(o.title ?? ""),
    value: o.value,
    props: o,
    children: s === "item" && Array.isArray(n) ? Th(e, n) : void 0,
    raw: a
  };
}
ra.neededProps = ["itemTitle", "itemValue", "itemChildren", "itemProps", "itemType"];
function Th(e, a) {
  const i = za(e, ra.neededProps), r = [];
  for (const n of a)
    r.push(ra(i, n));
  return r;
}
function Wu(e) {
  const a = I(() => Th(e, e.items)), i = I(() => a.value.some((o) => o.value === null)), r = fe(/* @__PURE__ */ new Map()), n = fe([]);
  wt(() => {
    const o = a.value, l = /* @__PURE__ */ new Map(), u = [];
    for (let c = 0; c < o.length; c++) {
      const d = o[c];
      if (dn(d.value) || d.value === null) {
        let f = l.get(d.value);
        f || (f = [], l.set(d.value, f)), f.push(d);
      } else
        u.push(d);
    }
    r.value = l, n.value = u;
  });
  function t(o) {
    const l = r.value, u = a.value, c = n.value, d = i.value, f = e.returnObject, v = !!e.valueComparator, g = e.valueComparator || bt, h = za(e, ra.neededProps), y = [];
    e: for (const m of o) {
      if (!d && m === null) continue;
      if (f && typeof m == "string") {
        y.push(ra(h, m));
        continue;
      }
      const p = l.get(m);
      if (v || !p) {
        for (const b of v ? u : c)
          if (g(m, b.value)) {
            y.push(b);
            continue e;
          }
        y.push(ra(h, m));
        continue;
      }
      y.push(...p);
    }
    return y;
  }
  function s(o) {
    return e.returnObject ? o.map((l) => {
      let {
        raw: u
      } = l;
      return u;
    }) : o.map((l) => {
      let {
        value: u
      } = l;
      return u;
    });
  }
  return {
    items: a,
    transformIn: t,
    transformOut: s
  };
}
const IP = /* @__PURE__ */ new Set(["item", "divider", "subheader"]);
function OP(e, a) {
  const i = dn(a) ? a : It(a, e.itemTitle), r = dn(a) ? a : It(a, e.itemValue, void 0), n = It(a, e.itemChildren), t = e.itemProps === !0 ? Le(a, ["children"]) : It(a, e.itemProps);
  let s = It(a, e.itemType, "item");
  IP.has(s) || (s = "item");
  const o = {
    title: i,
    value: r,
    ...t
  };
  return {
    type: s,
    title: o.title,
    value: o.value,
    props: o,
    children: s === "item" && n ? jh(e, n) : void 0,
    raw: a
  };
}
function jh(e, a) {
  const i = [];
  for (const r of a)
    i.push(OP(e, r));
  return i;
}
function EP(e) {
  return {
    items: I(() => jh(e, e.items))
  };
}
const AP = ee({
  baseColor: String,
  /* @deprecated */
  activeColor: String,
  activeClass: String,
  bgColor: String,
  disabled: Boolean,
  filterable: Boolean,
  expandIcon: Pe,
  collapseIcon: Pe,
  lines: {
    type: [Boolean, String],
    default: "one"
  },
  slim: Boolean,
  prependGap: [Number, String],
  indent: [Number, String],
  nav: Boolean,
  "onClick:open": Et(),
  "onClick:select": Et(),
  "onUpdate:opened": Et(),
  ...bP({
    selectStrategy: "single-leaf",
    openStrategy: "list"
  }),
  ...Aa(),
  ...Se(),
  ...Kt(),
  ...Mt(),
  ...ea(),
  ...Ah(),
  ...$t(),
  ...Be(),
  ...Qe(),
  ...ja({
    variant: "text"
  })
}, "VList"), Sr = de()({
  name: "VList",
  props: AP(),
  emits: {
    "update:selected": (e) => !0,
    "update:activated": (e) => !0,
    "update:opened": (e) => !0,
    "click:open": (e) => !0,
    "click:activate": (e) => !0,
    "click:select": (e) => !0
  },
  setup(e, a) {
    let {
      slots: i
    } = a;
    const {
      items: r
    } = EP(e), {
      themeClasses: n
    } = ut(e), {
      backgroundColorClasses: t,
      backgroundColorStyles: s
    } = at(() => e.bgColor), {
      borderClasses: o
    } = Ta(e), {
      densityClasses: l
    } = Qt(e), {
      dimensionStyles: u
    } = Rt(e), {
      elevationClasses: c
    } = ta(e), {
      roundedClasses: d
    } = _t(e), {
      children: f,
      open: v,
      parents: g,
      select: h,
      getPath: y
    } = kP(e, r, () => e.returnObject), m = W(() => e.lines ? `v-list--${e.lines}-line` : void 0), p = W(() => e.activeColor), b = W(() => e.baseColor), w = W(() => e.color), k = W(() => e.selectable || e.activatable);
    Sh({
      filterable: e.filterable
    }), da({
      VListGroup: {
        activeColor: p,
        baseColor: b,
        color: w,
        expandIcon: W(() => e.expandIcon),
        collapseIcon: W(() => e.collapseIcon)
      },
      VListItem: {
        activeClass: W(() => e.activeClass),
        activeColor: p,
        baseColor: b,
        color: w,
        density: W(() => e.density),
        disabled: W(() => e.disabled),
        lines: W(() => e.lines),
        nav: W(() => e.nav),
        slim: W(() => e.slim),
        variant: W(() => e.variant)
      }
    });
    const S = fe(!1), _ = ie();
    function P(B) {
      S.value = !0;
    }
    function M(B) {
      S.value = !1;
    }
    function q(B) {
      !S.value && !(B.relatedTarget && _.value?.contains(B.relatedTarget)) && H();
    }
    function K(B) {
      const L = B.target;
      if (!(!_.value || L.tagName === "INPUT" && ["Home", "End"].includes(B.key) || L.tagName === "TEXTAREA")) {
        if (B.key === "ArrowDown")
          H("next");
        else if (B.key === "ArrowUp")
          H("prev");
        else if (B.key === "Home")
          H("first");
        else if (B.key === "End")
          H("last");
        else
          return;
        B.preventDefault();
      }
    }
    function j(B) {
      S.value = !0;
    }
    function H(B) {
      if (_.value)
        return cr(_.value, B);
    }
    return me(() => {
      const B = e.indent ?? (e.prependGap ? Number(e.prependGap) + 24 : void 0);
      return C(e.tag, {
        ref: _,
        class: ue(["v-list", {
          "v-list--disabled": e.disabled,
          "v-list--nav": e.nav,
          "v-list--slim": e.slim
        }, n.value, t.value, o.value, l.value, c.value, m.value, d.value, e.class]),
        style: be([{
          "--v-list-indent": he(B),
          "--v-list-group-prepend": B ? "0px" : void 0,
          "--v-list-prepend-gap": he(e.prependGap)
        }, s.value, u.value, e.style]),
        tabindex: e.disabled ? -1 : 0,
        role: k.value ? "listbox" : "list",
        "aria-activedescendant": void 0,
        onFocusin: P,
        onFocusout: M,
        onFocus: q,
        onKeydown: K,
        onMousedown: j
      }, {
        default: () => [C(Eh, {
          items: r.value,
          returnObject: e.returnObject
        }, i)]
      });
    }), {
      open: v,
      select: h,
      focus: H,
      children: f,
      parents: g,
      getPath: y
    };
  }
}), TP = ee({
  start: Boolean,
  end: Boolean,
  ...Se(),
  ...Be()
}, "VListItemAction"), Zi = de()({
  name: "VListItemAction",
  props: TP(),
  setup(e, a) {
    let {
      slots: i
    } = a;
    return me(() => C(e.tag, {
      class: ue(["v-list-item-action", {
        "v-list-item-action--start": e.start,
        "v-list-item-action--end": e.end
      }, e.class]),
      style: be(e.style)
    }, i)), {};
  }
}), jP = ee({
  renderless: Boolean,
  ...Se()
}, "VVirtualScrollItem"), DP = de()({
  name: "VVirtualScrollItem",
  inheritAttrs: !1,
  props: jP(),
  emits: {
    "update:height": (e) => !0
  },
  setup(e, a) {
    let {
      attrs: i,
      emit: r,
      slots: n
    } = a;
    const {
      resizeRef: t,
      contentRect: s
    } = fn(void 0, "border");
    ce(() => s.value?.height, (o) => {
      o != null && r("update:height", o);
    }), me(() => e.renderless ? D(pe, null, [n.default?.({
      itemRef: t
    })]) : D("div", re({
      ref: t,
      class: ["v-virtual-scroll__item", e.class],
      style: e.style
    }, i), [n.default?.()]));
  }
}), MP = -1, RP = 1, ao = 100, NP = ee({
  itemHeight: {
    type: [Number, String],
    default: null
  },
  itemKey: {
    type: [String, Array, Function],
    default: null
  },
  height: [Number, String]
}, "virtual");
function LP(e, a) {
  const i = Dr(), r = fe(0);
  wt(() => {
    r.value = parseFloat(e.itemHeight || 0);
  });
  const n = fe(0), t = fe(Math.ceil(
    // Assume 16px items filling the entire screen height if
    // not provided. This is probably incorrect but it minimises
    // the chance of ending up with empty space at the bottom.
    // The default value is set here to avoid poisoning getSize()
    (parseInt(e.height) || i.height.value) / (r.value || 16)
  ) || 1), s = fe(0), o = fe(0), l = ie(), u = ie();
  let c = 0;
  const {
    resizeRef: d,
    contentRect: f
  } = fn();
  wt(() => {
    d.value = l.value;
  });
  const v = I(() => l.value === document.documentElement ? i.height.value : f.value?.height || parseInt(e.height) || 0), g = I(() => !!(l.value && u.value && v.value && r.value));
  let h = Array.from({
    length: a.value.length
  }), y = Array.from({
    length: a.value.length
  });
  const m = fe(0);
  let p = -1;
  function b(A) {
    return h[A] || r.value;
  }
  const w = Bv(() => {
    const A = performance.now();
    y[0] = 0;
    const T = a.value.length;
    for (let E = 1; E <= T; E++)
      y[E] = (y[E - 1] || 0) + b(E - 1);
    m.value = Math.max(m.value, performance.now() - A);
  }, m), k = ce(g, (A) => {
    A && (k(), c = u.value.offsetTop, w.immediate(), O(), ~p && Ee(() => {
      et && window.requestAnimationFrame(() => {
        Z(p), p = -1;
      });
    }));
  });
  st(() => {
    w.clear();
  });
  function S(A, T) {
    const E = h[A], x = r.value;
    r.value = x ? Math.min(r.value, T) : T, (E !== T || x !== r.value) && (h[A] = T, w());
  }
  function _(A) {
    A = Xe(A, 0, a.value.length);
    const T = Math.floor(A), E = A % 1, x = T + 1, $ = y[T] || 0, V = y[x] || $;
    return $ + (V - $) * E;
  }
  function P(A) {
    return qP(y, A);
  }
  let M = 0, q = 0, K = 0;
  ce(v, (A, T) => {
    O(), A < T && requestAnimationFrame(() => {
      q = 0, O();
    });
  });
  let j = -1;
  function H() {
    if (!l.value || !u.value) return;
    const A = l.value.scrollTop, T = performance.now();
    T - K > 500 ? (q = Math.sign(A - M), c = u.value.offsetTop) : q = A - M, M = A, K = T, window.clearTimeout(j), j = window.setTimeout(B, 500), O();
  }
  function B() {
    !l.value || !u.value || (q = 0, K = 0, window.clearTimeout(j), O());
  }
  let L = -1;
  function O() {
    cancelAnimationFrame(L), L = requestAnimationFrame(U);
  }
  function U() {
    if (!l.value || !v.value || !r.value) return;
    const A = M - c, T = Math.sign(q), E = Math.max(0, A - ao), x = Xe(P(E), 0, a.value.length), $ = A + v.value + ao, V = Xe(P($) + 1, x + 1, a.value.length);
    if (
      // Only update the side we're scrolling towards,
      // the other side will be updated incidentally
      (T !== MP || x < n.value) && (T !== RP || V > t.value)
    ) {
      const F = _(n.value) - _(x), z = _(V) - _(t.value);
      Math.max(F, z) > ao ? (n.value = x, t.value = V) : (x <= 0 && (n.value = x), V >= a.value.length && (t.value = V));
    }
    s.value = _(n.value), o.value = _(a.value.length) - _(t.value);
  }
  function Z(A) {
    const T = _(A);
    !l.value || A && !T ? p = A : l.value.scrollTop = T;
  }
  const J = I(() => a.value.slice(n.value, t.value).map((A, T) => {
    const E = T + n.value;
    return {
      raw: A,
      index: E,
      key: It(A, e.itemKey, E)
    };
  }));
  return ce(a, () => {
    h = Array.from({
      length: a.value.length
    }), y = Array.from({
      length: a.value.length
    }), w.immediate(), O();
  }, {
    deep: 1
  }), {
    calculateVisibleItems: O,
    containerRef: l,
    markerRef: u,
    computedItems: J,
    paddingTop: s,
    paddingBottom: o,
    scrollToIndex: Z,
    handleScroll: H,
    handleScrollend: B,
    handleItemResize: S
  };
}
function qP(e, a) {
  let i = e.length - 1, r = 0, n = 0, t = null, s = -1;
  if (e[i] < a)
    return i;
  for (; r <= i; )
    if (n = r + i >> 1, t = e[n], t > a)
      i = n - 1;
    else if (t < a)
      s = n, r = n + 1;
    else return t === a ? n : r;
  return s;
}
const zP = ee({
  items: {
    type: Array,
    default: () => []
  },
  renderless: Boolean,
  ...NP(),
  ...Se(),
  ...Mt()
}, "VVirtualScroll"), Gu = de()({
  name: "VVirtualScroll",
  props: zP(),
  setup(e, a) {
    let {
      slots: i
    } = a;
    const r = ft("VVirtualScroll"), {
      dimensionStyles: n
    } = Rt(e), {
      calculateVisibleItems: t,
      containerRef: s,
      markerRef: o,
      handleScroll: l,
      handleScrollend: u,
      handleItemResize: c,
      scrollToIndex: d,
      paddingTop: f,
      paddingBottom: v,
      computedItems: g
    } = LP(e, W(() => e.items));
    return Na(() => e.renderless, () => {
      function h() {
        const m = (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1) ? "addEventListener" : "removeEventListener";
        s.value === document.documentElement ? (document[m]("scroll", l, {
          passive: !0
        }), document[m]("scrollend", u)) : (s.value?.[m]("scroll", l, {
          passive: !0
        }), s.value?.[m]("scrollend", u));
      }
      ua(() => {
        s.value = gu(r.vnode.el, !0), h(!0);
      }), st(h);
    }), me(() => {
      const h = g.value.map((y) => C(DP, {
        key: y.key,
        renderless: e.renderless,
        "onUpdate:height": (m) => c(y.index, m)
      }, {
        default: (m) => i.default?.({
          item: y.raw,
          index: y.index,
          ...m
        })
      }));
      return e.renderless ? D(pe, null, [D("div", {
        ref: o,
        class: "v-virtual-scroll__spacer",
        style: {
          paddingTop: he(f.value)
        }
      }, null), h, D("div", {
        class: "v-virtual-scroll__spacer",
        style: {
          paddingBottom: he(v.value)
        }
      }, null)]) : D("div", {
        ref: s,
        class: ue(["v-virtual-scroll", e.class]),
        onScrollPassive: l,
        onScrollend: u,
        style: be([n.value, e.style])
      }, [D("div", {
        ref: o,
        class: "v-virtual-scroll__container",
        style: {
          paddingTop: he(f.value),
          paddingBottom: he(v.value)
        }
      }, [h])]);
    }), {
      calculateVisibleItems: t,
      scrollToIndex: d
    };
  }
});
function Yu(e, a) {
  const i = fe(!1);
  let r;
  function n(o) {
    cancelAnimationFrame(r), i.value = !0, r = requestAnimationFrame(() => {
      r = requestAnimationFrame(() => {
        i.value = !1;
      });
    });
  }
  async function t() {
    await new Promise((o) => requestAnimationFrame(o)), await new Promise((o) => requestAnimationFrame(o)), await new Promise((o) => requestAnimationFrame(o)), await new Promise((o) => {
      if (i.value) {
        const l = ce(i, () => {
          l(), o();
        });
      } else o();
    });
  }
  async function s(o) {
    if (o.key === "Tab" && a.value?.focus(), !["PageDown", "PageUp", "Home", "End"].includes(o.key)) return;
    const l = e.value?.$el;
    if (!l) return;
    (o.key === "Home" || o.key === "End") && l.scrollTo({
      top: o.key === "Home" ? 0 : l.scrollHeight,
      behavior: "smooth"
    }), await t();
    const u = l.querySelectorAll(":scope > :not(.v-virtual-scroll__spacer)");
    if (o.key === "PageDown" || o.key === "Home") {
      const c = l.getBoundingClientRect().top;
      for (const d of u)
        if (d.getBoundingClientRect().top >= c) {
          d.focus();
          break;
        }
    } else {
      const c = l.getBoundingClientRect().bottom;
      for (const d of [...u].reverse())
        if (d.getBoundingClientRect().bottom <= c) {
          d.focus();
          break;
        }
    }
  }
  return {
    onScrollPassive: n,
    onKeydown: s
  };
}
const BP = ee({
  closeText: {
    type: String,
    default: "$vuetify.close"
  },
  openText: {
    type: String,
    default: "$vuetify.open"
  }
}, "autocomplete");
function Xu(e, a) {
  const i = Xt(), r = I(() => `menu-${i}`), n = W(() => ot(a)), t = W(() => r.value);
  return {
    menuId: r,
    ariaExpanded: n,
    ariaControls: t
  };
}
const Zu = ee({
  chips: Boolean,
  closableChips: Boolean,
  eager: Boolean,
  hideNoData: Boolean,
  hideSelected: Boolean,
  listProps: {
    type: Object
  },
  menu: Boolean,
  menuIcon: {
    type: Pe,
    default: "$dropdown"
  },
  menuProps: {
    type: Object
  },
  multiple: Boolean,
  noDataText: {
    type: String,
    default: "$vuetify.noDataText"
  },
  openOnClear: Boolean,
  itemColor: String,
  noAutoScroll: Boolean,
  ...BP(),
  ...Ah({
    itemChildren: !1
  })
}, "Select"), FP = ee({
  ...Zu(),
  ...Le(Zn({
    modelValue: null,
    role: "combobox"
  }), ["validationValue", "dirty"]),
  ...Gn({
    transition: {
      component: Cu
    }
  })
}, "VSelect"), Ju = de()({
  name: "VSelect",
  props: FP(),
  emits: {
    "update:focused": (e) => !0,
    "update:modelValue": (e) => !0,
    "update:menu": (e) => !0
  },
  setup(e, a) {
    let {
      slots: i
    } = a;
    const {
      t: r
    } = nt(), n = ie(), t = ie(), s = ie(), {
      items: o,
      transformIn: l,
      transformOut: u
    } = Wu(e), c = $e(e, "modelValue", [], (V) => l(V === null ? [null] : Ze(V)), (V) => {
      const F = u(V);
      return e.multiple ? F : F[0] ?? null;
    }), d = I(() => typeof e.counterValue == "function" ? e.counterValue(c.value) : typeof e.counterValue == "number" ? e.counterValue : c.value.length), f = Xn(e), v = ju(e), g = I(() => c.value.map((V) => V.value)), h = fe(!1), y = W(() => e.closableChips && !f.isReadonly.value && !f.isDisabled.value), {
      InputIcon: m
    } = zr(e);
    let p = "", b = 0, w;
    const k = I(() => e.hideSelected ? o.value.filter((V) => !c.value.some((F) => (e.valueComparator || bt)(F, V))) : o.value), S = I(() => e.hideNoData && !k.value.length || f.isReadonly.value || f.isDisabled.value), _ = $e(e, "menu"), P = I({
      get: () => _.value,
      set: (V) => {
        _.value && !V && t.value?.ΨopenChildren.size || V && S.value || (_.value = V);
      }
    }), {
      menuId: M,
      ariaExpanded: q,
      ariaControls: K
    } = Xu(e, P), j = I(() => ({
      ...e.menuProps,
      activatorProps: {
        ...e.menuProps?.activatorProps || {},
        "aria-haspopup": "listbox"
        // Set aria-haspopup to 'listbox'
      }
    })), H = ie(), B = Yu(H, n);
    function L(V) {
      e.openOnClear && (P.value = !0);
    }
    function O() {
      S.value || (P.value = !P.value);
    }
    function U(V) {
      Tn(V) && Z(V);
    }
    function Z(V) {
      if (!V.key || f.isReadonly.value) return;
      if (["Enter", " ", "ArrowDown", "ArrowUp", "Home", "End"].includes(V.key) && V.preventDefault(), ["Enter", "ArrowDown", " "].includes(V.key) && (P.value = !0), ["Escape", "Tab"].includes(V.key) && (P.value = !1), e.clearable && V.key === "Backspace") {
        V.preventDefault(), c.value = [], L();
        return;
      }
      V.key === "Home" ? H.value?.focus("first") : V.key === "End" && H.value?.focus("last");
      const F = 1e3;
      if (!Tn(V)) return;
      const z = performance.now();
      z - w > F && (p = "", b = 0), p += V.key.toLowerCase(), w = z;
      const X = k.value;
      function Q() {
        let ae = te();
        return ae || p.at(-1) === p.at(-2) && (p = p.slice(0, -1), b++, ae = te(), ae) || (b = 0, ae = te(), ae) ? ae : (p = V.key.toLowerCase(), te());
      }
      function te() {
        for (let ae = b; ae < X.length; ae++) {
          const ve = X[ae];
          if (ve.title.toLowerCase().startsWith(p))
            return [ve, ae];
        }
      }
      const N = Q();
      if (!N) return;
      const [R, G] = N;
      b = G, H.value?.focus(G), e.multiple || (c.value = [R]);
    }
    function J(V) {
      let F = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
      if (!V.props.disabled)
        if (e.multiple) {
          const z = c.value.findIndex((Q) => (e.valueComparator || bt)(Q.value, V.value)), X = F ?? !~z;
          if (~z) {
            const Q = X ? [...c.value, V] : [...c.value];
            Q.splice(z, 1), c.value = Q;
          } else X && (c.value = [...c.value, V]);
        } else {
          const z = F !== !1;
          c.value = z ? [V] : [], Ee(() => {
            P.value = !1;
          });
        }
    }
    function A(V) {
      H.value?.$el.contains(V.relatedTarget) || (P.value = !1);
    }
    function T() {
      e.eager && s.value?.calculateVisibleItems();
    }
    function E() {
      h.value && n.value?.focus();
    }
    function x(V) {
      h.value = !0;
    }
    function $(V) {
      if (V == null) c.value = [];
      else if (An(n.value, ":autofill") || An(n.value, ":-webkit-autofill")) {
        const F = o.value.find((z) => z.title === V);
        F && J(F);
      } else n.value && (n.value.value = "");
    }
    return ce(P, () => {
      if (!e.hideSelected && P.value && c.value.length) {
        const V = k.value.findIndex((F) => c.value.some((z) => (e.valueComparator || bt)(z.value, F.value)));
        et && !e.noAutoScroll && window.requestAnimationFrame(() => {
          V >= 0 && s.value?.scrollToIndex(V);
        });
      }
    }), ce(o, (V, F) => {
      P.value || h.value && e.hideNoData && !F.length && V.length && (P.value = !0);
    }), me(() => {
      const V = !!(e.chips || i.chip), F = !!(!e.hideNoData || k.value.length || i["prepend-item"] || i["append-item"] || i["no-data"]), z = c.value.length > 0, X = Dt.filterProps(e), Q = z || !h.value && e.label && !e.persistentPlaceholder ? void 0 : e.placeholder;
      return C(Dt, re({
        ref: n
      }, X, {
        modelValue: c.value.map((te) => te.props.title).join(", "),
        name: void 0,
        "onUpdate:modelValue": $,
        focused: h.value,
        "onUpdate:focused": (te) => h.value = te,
        validationValue: c.externalValue,
        counterValue: d.value,
        dirty: z,
        class: ["v-select", {
          "v-select--active-menu": P.value,
          "v-select--chips": !!e.chips,
          [`v-select--${e.multiple ? "multiple" : "single"}`]: !0,
          "v-select--selected": c.value.length,
          "v-select--selection-slot": !!i.selection
        }, e.class],
        style: e.style,
        inputmode: "none",
        placeholder: Q,
        "onClick:clear": L,
        "onMousedown:control": O,
        onBlur: A,
        onKeydown: Z,
        "aria-expanded": q.value,
        "aria-controls": K.value
      }), {
        ...i,
        default: (te) => {
          let {
            id: N
          } = te;
          return D(pe, null, [D("select", {
            hidden: !0,
            multiple: e.multiple,
            name: v.fieldName.value
          }, [o.value.map((R) => D("option", {
            key: R.value,
            value: R.value,
            selected: g.value.includes(R.value)
          }, null))]), C(La, re({
            id: M.value,
            ref: t,
            modelValue: P.value,
            "onUpdate:modelValue": (R) => P.value = R,
            activator: "parent",
            contentClass: "v-select__content",
            disabled: S.value,
            eager: e.eager,
            maxHeight: 310,
            openOnClick: !1,
            closeOnContentClick: !1,
            transition: e.transition,
            onAfterEnter: T,
            onAfterLeave: E
          }, j.value), {
            default: () => [F && C(Sr, re({
              ref: H,
              selected: g.value,
              selectStrategy: e.multiple ? "independent" : "single-independent",
              onMousedown: (R) => R.preventDefault(),
              onKeydown: U,
              onFocusin: x,
              tabindex: "-1",
              selectable: !!k.value.length,
              "aria-live": "polite",
              "aria-labelledby": `${N.value}-label`,
              "aria-multiselectable": e.multiple,
              color: e.itemColor ?? e.color
            }, B, e.listProps), {
              default: () => [i["prepend-item"]?.(), !k.value.length && !e.hideNoData && (i["no-data"]?.() ?? C(it, {
                key: "no-data",
                title: r(e.noDataText)
              }, null)), C(Gu, {
                ref: s,
                renderless: !0,
                items: k.value,
                itemKey: "value"
              }, {
                default: (R) => {
                  let {
                    item: G,
                    index: ae,
                    itemRef: ve
                  } = R;
                  const ne = rw(G.props), _e = re(G.props, {
                    ref: ve,
                    key: G.value,
                    onClick: () => J(G, null),
                    "aria-posinset": ae + 1,
                    "aria-setsize": k.value.length
                  });
                  return G.type === "divider" ? i.divider?.({
                    props: G.raw,
                    index: ae
                  }) ?? C(ia, re(G.props, {
                    key: `divider-${ae}`
                  }), null) : G.type === "subheader" ? i.subheader?.({
                    props: G.raw,
                    index: ae
                  }) ?? C(kn, re(G.props, {
                    key: `subheader-${ae}`
                  }), null) : i.item?.({
                    item: G,
                    index: ae,
                    props: _e
                  }) ?? C(it, re(_e, {
                    role: "option"
                  }), {
                    prepend: (Ce) => {
                      let {
                        isSelected: se
                      } = Ce;
                      return D(pe, null, [e.multiple && !e.hideSelected ? C(Mn, {
                        key: G.value,
                        modelValue: se,
                        ripple: !1,
                        tabindex: "-1",
                        "aria-hidden": !0,
                        onClick: (ge) => ge.preventDefault()
                      }, null) : void 0, ne.prependAvatar && C(Yt, {
                        image: ne.prependAvatar
                      }, null), ne.prependIcon && C(xe, {
                        icon: ne.prependIcon
                      }, null)]);
                    }
                  });
                }
              }), i["append-item"]?.()]
            })]
          }), c.value.map((R, G) => {
            function ae(Ce) {
              Ce.stopPropagation(), Ce.preventDefault(), J(R, !1);
            }
            const ve = re(vn.filterProps(R.props), {
              "onClick:close": ae,
              onKeydown(Ce) {
                Ce.key !== "Enter" && Ce.key !== " " || (Ce.preventDefault(), Ce.stopPropagation(), ae(Ce));
              },
              onMousedown(Ce) {
                Ce.preventDefault(), Ce.stopPropagation();
              },
              modelValue: !0,
              "onUpdate:modelValue": void 0
            }), ne = V ? !!i.chip : !!i.selection, _e = ne ? Rs(V ? i.chip({
              item: R,
              index: G,
              props: ve
            }) : i.selection({
              item: R,
              index: G
            })) : void 0;
            if (!(ne && !_e))
              return D("div", {
                key: R.value,
                class: "v-select__selection"
              }, [V ? i.chip ? C(je, {
                key: "chip-defaults",
                defaults: {
                  VChip: {
                    closable: y.value,
                    size: "small",
                    text: R.title
                  }
                }
              }, {
                default: () => [_e]
              }) : C(vn, re({
                key: "chip",
                closable: y.value,
                size: "small",
                text: R.title,
                disabled: R.props.disabled
              }, ve), null) : _e ?? D("span", {
                class: "v-select__selection-text"
              }, [R.title, e.multiple && G < c.value.length - 1 && D("span", {
                class: "v-select__selection-comma"
              }, [Fe(",")])])]);
          })]);
        },
        "append-inner": function() {
          for (var te = arguments.length, N = new Array(te), R = 0; R < te; R++)
            N[R] = arguments[R];
          return D(pe, null, [i["append-inner"]?.(...N), e.menuIcon ? C(xe, {
            class: "v-select__menu-icon",
            color: n.value?.fieldIconColor,
            icon: e.menuIcon,
            "aria-hidden": !0
          }, null) : void 0, e.appendInnerIcon && C(m, {
            key: "append-icon",
            name: "appendInner",
            color: N[0].iconColor.value
          }, null)]);
        }
      });
    }), Pt({
      isFocused: h,
      menu: P,
      select: J
    }, n);
  }
});
function Br(e, a) {
  const i = fe([]), r = ie(!1), n = ie(""), t = I(() => !!(e.value.layout.items || e.value.layout.getItems)), s = async () => {
    r.value = !0;
    try {
      i.value = await a.getItems(e.value, n.value);
    } finally {
      r.value = !1;
    }
  };
  return ce(() => e.value.itemsCacheKey, (l, u) => {
    l !== u && s();
  }, { immediate: !0 }), ce(n, () => {
    s();
  }), { hasItems: t, items: i, loading: r, search: n, prepareSelectedItem: (l, u) => {
    let c = l;
    if (l === u)
      try {
        c = a.prepareSelectItem(e.value, l), c.value === void 0 && (c.value = u);
      } catch {
        c = { value: u };
      }
    return c;
  } };
}
const KP = ee({
  text: String,
  ...Se(),
  ...Be()
}, "VToolbarTitle"), HP = de()({
  name: "VToolbarTitle",
  props: KP(),
  setup(e, a) {
    let {
      slots: i
    } = a;
    return me(() => {
      const r = !!(i.default || i.text || e.text);
      return C(e.tag, {
        class: ue(["v-toolbar-title", e.class]),
        style: be(e.style)
      }, {
        default: () => [r && D("div", {
          class: "v-toolbar-title__placeholder"
        }, [i.text ? i.text() : e.text, i.default?.()])]
      });
    }), {};
  }
}), UP = [null, "prominent", "default", "comfortable", "compact"], WP = ee({
  absolute: Boolean,
  collapse: Boolean,
  collapsePosition: {
    type: String,
    default: "start"
  },
  color: String,
  density: {
    type: String,
    default: "default",
    validator: (e) => UP.includes(e)
  },
  extended: {
    type: Boolean,
    default: null
  },
  extensionHeight: {
    type: [Number, String],
    default: 48
  },
  flat: Boolean,
  floating: Boolean,
  height: {
    type: [Number, String],
    default: 64
  },
  image: String,
  title: String,
  ...Aa(),
  ...Se(),
  ...ea(),
  ...$t(),
  ...Be({
    tag: "header"
  }),
  ...Qe()
}, "VToolbar"), GP = de()({
  name: "VToolbar",
  props: WP(),
  setup(e, a) {
    let {
      slots: i
    } = a;
    const {
      backgroundColorClasses: r,
      backgroundColorStyles: n
    } = at(() => e.color), {
      borderClasses: t
    } = Ta(e), {
      elevationClasses: s
    } = ta(e), {
      roundedClasses: o
    } = _t(e), {
      themeClasses: l
    } = ut(e), {
      rtlClasses: u
    } = St(), c = fe(e.extended === null ? !!i.extension?.() : e.extended), d = I(() => parseInt(Number(e.height) + (e.density === "prominent" ? Number(e.height) : 0) - (e.density === "comfortable" ? 8 : 0) - (e.density === "compact" ? 16 : 0), 10)), f = I(() => c.value ? parseInt(Number(e.extensionHeight) + (e.density === "prominent" ? Number(e.extensionHeight) : 0) - (e.density === "comfortable" ? 4 : 0) - (e.density === "compact" ? 8 : 0), 10) : 0);
    return da({
      VBtn: {
        variant: "text"
      }
    }), me(() => {
      const v = !!(e.title || i.title), g = !!(i.image || e.image), h = i.extension?.();
      return c.value = e.extended === null ? !!h : e.extended, C(e.tag, {
        class: ue(["v-toolbar", `v-toolbar--collapse-${e.collapsePosition}`, {
          "v-toolbar--absolute": e.absolute,
          "v-toolbar--collapse": e.collapse,
          "v-toolbar--flat": e.flat,
          "v-toolbar--floating": e.floating,
          [`v-toolbar--density-${e.density}`]: !0
        }, r.value, t.value, s.value, o.value, l.value, u.value, e.class]),
        style: be([n.value, e.style])
      }, {
        default: () => [g && D("div", {
          key: "image",
          class: "v-toolbar__image"
        }, [i.image ? C(je, {
          key: "image-defaults",
          disabled: !e.image,
          defaults: {
            VImg: {
              cover: !0,
              src: e.image
            }
          }
        }, i.image) : C(Zs, {
          key: "image-img",
          cover: !0,
          src: e.image
        }, null)]), C(je, {
          defaults: {
            VTabs: {
              height: he(d.value)
            }
          }
        }, {
          default: () => [D("div", {
            class: "v-toolbar__content",
            style: {
              height: he(d.value)
            }
          }, [i.prepend && D("div", {
            class: "v-toolbar__prepend"
          }, [i.prepend?.()]), v && C(HP, {
            key: "title",
            text: e.title
          }, {
            text: i.title
          }), i.default?.(), i.append && D("div", {
            class: "v-toolbar__append"
          }, [i.append?.()])])]
        }), C(je, {
          defaults: {
            VTabs: {
              height: he(f.value)
            }
          }
        }, {
          default: () => [C(xu, null, {
            default: () => [c.value && D("div", {
              class: "v-toolbar__extension",
              style: {
                height: he(f.value)
              }
            }, [h])]
          })]
        })]
      });
    }), {
      contentHeight: d,
      extensionHeight: f
    };
  }
}), YP = (e, a, i) => {
  if (e == null || a == null) return -1;
  if (!a.length) return 0;
  e = e.toString().toLocaleLowerCase(), a = a.toString().toLocaleLowerCase();
  const r = [];
  let n = e.indexOf(a);
  for (; ~n; )
    r.push([n, n + a.length]), n = e.indexOf(a, n + a.length);
  return r.length ? r : -1;
};
function no(e, a) {
  if (!(e == null || typeof e == "boolean" || e === -1))
    return typeof e == "number" ? [[e, e + a.length]] : Array.isArray(e[0]) ? e : [e];
}
const Dh = ee({
  customFilter: Function,
  customKeyFilter: Object,
  filterKeys: [Array, String],
  filterMode: {
    type: String,
    default: "intersection"
  },
  noFilter: Boolean
}, "filter");
function XP(e, a, i) {
  const r = [], n = i?.default ?? YP, t = i?.filterKeys ? Ze(i.filterKeys) : !1, s = Object.keys(i?.customKeyFilter ?? {}).length;
  if (!e?.length) return r;
  let o = null;
  e: for (let l = 0; l < e.length; l++) {
    const [u, c = u] = Ze(e[l]), d = {}, f = {};
    let v = -1;
    if ((a || s > 0) && !i?.noFilter) {
      let g = !1;
      if (typeof u == "object") {
        if (u.type === "divider" || u.type === "subheader") {
          o?.type === "divider" && u.type === "subheader" && r.push(o), o = {
            index: l,
            matches: {},
            type: u.type
          };
          continue;
        }
        const m = t || Object.keys(c);
        g = m.length === s;
        for (const p of m) {
          const b = It(c, p), w = i?.customKeyFilter?.[p];
          if (v = w ? w(b, a, u) : n(b, a, u), v !== -1 && v !== !1)
            w ? d[p] = no(v, a) : f[p] = no(v, a);
          else if (i?.filterMode === "every")
            continue e;
        }
      } else
        v = n(u, a, u), v !== -1 && v !== !1 && (f.title = no(v, a));
      const h = Object.keys(f).length, y = Object.keys(d).length;
      if (!h && !y || i?.filterMode === "union" && y !== s && !h || i?.filterMode === "intersection" && (y !== s || !h && s > 0 && !g)) continue;
    }
    o && (r.push(o), o = null), r.push({
      index: l,
      matches: {
        ...f,
        ...d
      }
    });
  }
  return r;
}
function Mh(e, a, i, r) {
  const n = fe([]), t = fe(/* @__PURE__ */ new Map()), s = I(() => Y(a));
  wt(() => {
    const l = typeof i == "function" ? i() : Y(i), u = typeof l != "string" && typeof l != "number" ? "" : String(l), c = XP(s.value, u, {
      customKeyFilter: {
        ...e.customKeyFilter,
        ...Y(r?.customKeyFilter)
      },
      default: e.customFilter,
      filterKeys: e.filterKeys,
      filterMode: e.filterMode,
      noFilter: e.noFilter
    }), d = Y(a), f = [], v = /* @__PURE__ */ new Map();
    c.forEach((g) => {
      let {
        index: h,
        matches: y
      } = g;
      const m = d[h];
      f.push(m), v.set(m.value, y);
    }), n.value = f, t.value = v;
  });
  function o(l) {
    return t.value.get(l.value);
  }
  return {
    filteredItems: n,
    filteredMatches: t,
    getMatches: o
  };
}
function Rh(e, a, i) {
  return i == null || !i.length ? a : i.map((r, n) => {
    const t = n === 0 ? 0 : i[n - 1][1], s = [D("span", {
      class: ue(`${e}__unmask`)
    }, [a.slice(t, r[0])]), D("span", {
      class: ue(`${e}__mask`)
    }, [a.slice(r[0], r[1])])];
    return n === i.length - 1 && s.push(D("span", {
      class: ue(`${e}__unmask`)
    }, [a.slice(r[1])])), D(pe, null, [s]);
  });
}
const ZP = ee({
  autoSelectFirst: {
    type: [Boolean, String]
  },
  clearOnSelect: Boolean,
  search: String,
  ...Dh({
    filterKeys: ["title"]
  }),
  ...Zu(),
  ...Le(Zn({
    modelValue: null,
    role: "combobox"
  }), ["validationValue", "dirty"])
}, "VAutocomplete"), Nh = de()({
  name: "VAutocomplete",
  props: ZP(),
  emits: {
    "update:focused": (e) => !0,
    "update:search": (e) => !0,
    "update:modelValue": (e) => !0,
    "update:menu": (e) => !0
  },
  setup(e, a) {
    let {
      slots: i
    } = a;
    const {
      t: r
    } = nt(), n = ie(), t = fe(!1), s = fe(!0), o = fe(!1), l = ie(), u = ie(), c = fe(-1), d = fe(null), {
      items: f,
      transformIn: v,
      transformOut: g
    } = Wu(e), {
      textColorClasses: h,
      textColorStyles: y
    } = kt(() => n.value?.color), {
      InputIcon: m
    } = zr(e), p = $e(e, "search", ""), b = $e(e, "modelValue", [], (ne) => v(ne === null ? [null] : Ze(ne)), (ne) => {
      const _e = g(ne);
      return e.multiple ? _e : _e[0] ?? null;
    }), w = I(() => typeof e.counterValue == "function" ? e.counterValue(b.value) : typeof e.counterValue == "number" ? e.counterValue : b.value.length), k = Xn(e), {
      filteredItems: S,
      getMatches: _
    } = Mh(e, f, () => d.value ?? (s.value ? "" : p.value)), P = I(() => e.hideSelected && d.value === null ? S.value.filter((ne) => !b.value.some((_e) => _e.value === ne.value)) : S.value), M = W(() => e.closableChips && !k.isReadonly.value && !k.isDisabled.value), q = I(() => !!(e.chips || i.chip)), K = I(() => q.value || !!i.selection), j = I(() => b.value.map((ne) => ne.props.value)), H = I(() => P.value.find((ne) => ne.type === "item" && !ne.props.disabled)), B = I(() => (e.autoSelectFirst === !0 || e.autoSelectFirst === "exact" && p.value === H.value?.title) && P.value.length > 0 && !s.value && !o.value), L = I(() => e.hideNoData && !P.value.length || k.isReadonly.value || k.isDisabled.value), O = $e(e, "menu"), U = I({
      get: () => O.value,
      set: (ne) => {
        O.value && !ne && l.value?.ΨopenChildren.size || ne && L.value || (O.value = ne);
      }
    }), {
      menuId: Z,
      ariaExpanded: J,
      ariaControls: A
    } = Xu(e, U), T = ie(), E = Yu(T, n);
    function x(ne) {
      e.openOnClear && (U.value = !0), p.value = "";
    }
    function $() {
      L.value || (U.value = !0);
    }
    function V(ne) {
      L.value || (t.value && (ne.preventDefault(), ne.stopPropagation()), U.value = !U.value);
    }
    function F(ne) {
      (Tn(ne) || ne.key === "Backspace") && n.value?.focus();
    }
    function z(ne) {
      if (k.isReadonly.value) return;
      const _e = n.value?.selectionStart, Ce = b.value.length;
      if (["Enter", "ArrowDown", "ArrowUp"].includes(ne.key) && ne.preventDefault(), ["Enter", "ArrowDown"].includes(ne.key) && (U.value = !0), ["Escape"].includes(ne.key) && (U.value = !1), B.value && ["Enter", "Tab"].includes(ne.key) && H.value && !b.value.some((se) => {
        let {
          value: ge
        } = se;
        return ge === H.value.value;
      }) && ve(H.value), ne.key === "ArrowDown" && B.value && T.value?.focus("next"), ["Backspace", "Delete"].includes(ne.key)) {
        if (!e.multiple && K.value && b.value.length > 0 && !p.value) return ve(b.value[0], !1);
        if (~c.value) {
          ne.preventDefault();
          const se = c.value;
          ve(b.value[c.value], !1), c.value = se >= Ce - 1 ? Ce - 2 : se;
        } else ne.key === "Backspace" && !p.value && (c.value = Ce - 1);
        return;
      }
      if (e.multiple)
        if (ne.key === "ArrowLeft") {
          if (c.value < 0 && _e && _e > 0) return;
          const se = c.value > -1 ? c.value - 1 : Ce - 1;
          if (b.value[se])
            c.value = se;
          else {
            const ge = p.value?.length ?? null;
            c.value = -1, n.value?.setSelectionRange(ge, ge);
          }
        } else if (ne.key === "ArrowRight") {
          if (c.value < 0) return;
          const se = c.value + 1;
          b.value[se] ? c.value = se : (c.value = -1, n.value?.setSelectionRange(0, 0));
        } else ~c.value && Tn(ne) && (c.value = -1);
    }
    function X(ne) {
      if (An(n.value, ":autofill") || An(n.value, ":-webkit-autofill")) {
        const _e = f.value.find((Ce) => Ce.title === ne.target.value);
        _e && ve(_e);
      }
    }
    function Q() {
      e.eager && u.value?.calculateVisibleItems();
    }
    function te() {
      t.value && (s.value = !0, n.value?.focus()), d.value = null;
    }
    function N(ne) {
      t.value = !0, setTimeout(() => {
        o.value = !0;
      });
    }
    function R(ne) {
      o.value = !1;
    }
    function G(ne) {
      (ne == null || ne === "" && !e.multiple && !K.value) && (b.value = []);
    }
    const ae = fe(!1);
    function ve(ne) {
      let _e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
      if (!(!ne || ne.props.disabled))
        if (e.multiple) {
          const Ce = b.value.findIndex((ge) => (e.valueComparator || bt)(ge.value, ne.value)), se = _e ?? !~Ce;
          if (~Ce) {
            const ge = se ? [...b.value, ne] : [...b.value];
            ge.splice(Ce, 1), b.value = ge;
          } else se && (b.value = [...b.value, ne]);
          e.clearOnSelect && (p.value = "");
        } else {
          const Ce = _e !== !1;
          b.value = Ce ? [ne] : [], d.value = s.value ? "" : p.value ?? "", p.value = Ce && !K.value ? ne.title : "", Ee(() => {
            U.value = !1, s.value = !0;
          });
        }
    }
    return ce(t, (ne, _e) => {
      ne !== _e && (ne ? (ae.value = !0, p.value = e.multiple || K.value ? "" : String(b.value.at(-1)?.props.title ?? ""), s.value = !0, Ee(() => ae.value = !1)) : (!e.multiple && p.value == null && (b.value = []), U.value = !1, !s.value && p.value && (d.value = p.value), p.value = "", c.value = -1));
    }), ce(p, (ne) => {
      !t.value || ae.value || (ne && (U.value = !0), s.value = !ne);
    }), ce(U, (ne) => {
      if (!e.hideSelected && ne && b.value.length && s.value) {
        const _e = P.value.findIndex((Ce) => b.value.some((se) => Ce.value === se.value));
        et && window.requestAnimationFrame(() => {
          _e >= 0 && u.value?.scrollToIndex(_e);
        });
      }
      ne && (d.value = null);
    }), ce(f, (ne, _e) => {
      U.value || t.value && !_e.length && ne.length && (U.value = !0);
    }), me(() => {
      const ne = !!(!e.hideNoData || P.value.length || i["prepend-item"] || i["append-item"] || i["no-data"]), _e = b.value.length > 0, Ce = Dt.filterProps(e);
      return C(Dt, re({
        ref: n
      }, Ce, {
        modelValue: p.value,
        "onUpdate:modelValue": [(se) => p.value = se, G],
        focused: t.value,
        "onUpdate:focused": (se) => t.value = se,
        validationValue: b.externalValue,
        counterValue: w.value,
        dirty: _e,
        onChange: X,
        class: ["v-autocomplete", `v-autocomplete--${e.multiple ? "multiple" : "single"}`, {
          "v-autocomplete--active-menu": U.value,
          "v-autocomplete--chips": !!e.chips,
          "v-autocomplete--selection-slot": !!K.value,
          "v-autocomplete--selecting-index": c.value > -1
        }, e.class],
        style: e.style,
        readonly: k.isReadonly.value,
        placeholder: _e ? void 0 : e.placeholder,
        "onClick:clear": x,
        "onMousedown:control": $,
        onKeydown: z,
        "aria-expanded": J.value,
        "aria-controls": A.value
      }), {
        ...i,
        default: (se) => {
          let {
            id: ge
          } = se;
          return D(pe, null, [C(La, re({
            id: Z.value,
            ref: l,
            modelValue: U.value,
            "onUpdate:modelValue": (we) => U.value = we,
            activator: "parent",
            contentClass: "v-autocomplete__content",
            disabled: L.value,
            eager: e.eager,
            maxHeight: 310,
            openOnClick: !1,
            closeOnContentClick: !1,
            onAfterEnter: Q,
            onAfterLeave: te
          }, e.menuProps), {
            default: () => [ne && C(Sr, re({
              ref: T,
              filterable: !0,
              selected: j.value,
              selectStrategy: e.multiple ? "independent" : "single-independent",
              onMousedown: (we) => we.preventDefault(),
              onKeydown: F,
              onFocusin: N,
              onFocusout: R,
              tabindex: "-1",
              selectable: !!P.value.length,
              "aria-live": "polite",
              "aria-labelledby": `${ge.value}-label`,
              "aria-multiselectable": e.multiple,
              color: e.itemColor ?? e.color
            }, E, e.listProps), {
              default: () => [i["prepend-item"]?.(), !P.value.length && !e.hideNoData && (i["no-data"]?.() ?? C(it, {
                key: "no-data",
                title: r(e.noDataText)
              }, null)), C(Gu, {
                ref: u,
                renderless: !0,
                items: P.value,
                itemKey: "value"
              }, {
                default: (we) => {
                  let {
                    item: ke,
                    index: ze,
                    itemRef: Ne
                  } = we;
                  const Re = re(ke.props, {
                    ref: Ne,
                    key: ke.value,
                    active: B.value && ke === H.value ? !0 : void 0,
                    onClick: () => ve(ke, null),
                    "aria-posinset": ze + 1,
                    "aria-setsize": P.value.length
                  });
                  return ke.type === "divider" ? i.divider?.({
                    props: ke.raw,
                    index: ze
                  }) ?? C(ia, re(ke.props, {
                    key: `divider-${ze}`
                  }), null) : ke.type === "subheader" ? i.subheader?.({
                    props: ke.raw,
                    index: ze
                  }) ?? C(kn, re(ke.props, {
                    key: `subheader-${ze}`
                  }), null) : i.item?.({
                    item: ke,
                    index: ze,
                    props: Re
                  }) ?? C(it, re(Re, {
                    role: "option"
                  }), {
                    prepend: (rt) => {
                      let {
                        isSelected: tt
                      } = rt;
                      return D(pe, null, [e.multiple && !e.hideSelected ? C(Mn, {
                        key: ke.value,
                        modelValue: tt,
                        ripple: !1,
                        tabindex: "-1",
                        "aria-hidden": !0,
                        onClick: (fa) => fa.preventDefault()
                      }, null) : void 0, ke.props.prependAvatar && C(Yt, {
                        image: ke.props.prependAvatar
                      }, null), ke.props.prependIcon && C(xe, {
                        icon: ke.props.prependIcon
                      }, null)]);
                    },
                    title: () => s.value ? ke.title : Rh("v-autocomplete", ke.title, _(ke)?.title)
                  });
                }
              }), i["append-item"]?.()]
            })]
          }), b.value.map((we, ke) => {
            function ze(tt) {
              tt.stopPropagation(), tt.preventDefault(), ve(we, !1);
            }
            const Ne = re(vn.filterProps(we.props), {
              "onClick:close": ze,
              onKeydown(tt) {
                tt.key !== "Enter" && tt.key !== " " || (tt.preventDefault(), tt.stopPropagation(), ze(tt));
              },
              onMousedown(tt) {
                tt.preventDefault(), tt.stopPropagation();
              },
              modelValue: !0,
              "onUpdate:modelValue": void 0
            }), Re = q.value ? !!i.chip : !!i.selection, rt = Re ? Rs(q.value ? i.chip({
              item: we,
              index: ke,
              props: Ne
            }) : i.selection({
              item: we,
              index: ke
            })) : void 0;
            if (!(Re && !rt))
              return D("div", {
                key: we.value,
                class: ue(["v-autocomplete__selection", ke === c.value && ["v-autocomplete__selection--selected", h.value]]),
                style: be(ke === c.value ? y.value : {})
              }, [q.value ? i.chip ? C(je, {
                key: "chip-defaults",
                defaults: {
                  VChip: {
                    closable: M.value,
                    size: "small",
                    text: we.title
                  }
                }
              }, {
                default: () => [rt]
              }) : C(vn, re({
                key: "chip",
                closable: M.value,
                size: "small",
                text: we.title,
                disabled: we.props.disabled
              }, Ne), null) : rt ?? D("span", {
                class: "v-autocomplete__selection-text"
              }, [we.title, e.multiple && ke < b.value.length - 1 && D("span", {
                class: "v-autocomplete__selection-comma"
              }, [Fe(",")])])]);
          })]);
        },
        "append-inner": function() {
          for (var se = arguments.length, ge = new Array(se), we = 0; we < se; we++)
            ge[we] = arguments[we];
          return D(pe, null, [i["append-inner"]?.(...ge), e.menuIcon ? C(xe, {
            class: "v-autocomplete__menu-icon",
            color: n.value?.fieldIconColor,
            icon: e.menuIcon,
            onMousedown: V,
            onClick: Uv,
            "aria-hidden": !0,
            tabindex: "-1"
          }, null) : void 0, e.appendInnerIcon && C(m, {
            key: "append-icon",
            name: "appendInner",
            color: ge[0].iconColor.value
          }, null)]);
        }
      });
    }), Pt({
      isFocused: t,
      isPristine: s,
      menu: U,
      search: p,
      filteredItems: S,
      select: ve
    }, n);
  }
}), JP = ee({
  fullscreen: Boolean,
  scrollable: Boolean,
  ...Le(Eu({
    captureFocus: !0,
    origin: "center center",
    scrollStrategy: "block",
    transition: {
      component: Cu
    },
    zIndex: 2400,
    retainFocus: !0
  }), ["disableInitialFocus"])
}, "VDialog"), QP = de()({
  name: "VDialog",
  props: JP(),
  emits: {
    "update:modelValue": (e) => !0,
    afterEnter: () => !0,
    afterLeave: () => !0
  },
  setup(e, a) {
    let {
      emit: i,
      slots: r
    } = a;
    const n = $e(e, "modelValue"), {
      scopeId: t
    } = Us(), s = ie();
    function o() {
      i("afterEnter"), (e.scrim || e.retainFocus) && s.value?.contentEl && !s.value.contentEl.contains(document.activeElement) && s.value.contentEl.focus({
        preventScroll: !0
      });
    }
    function l() {
      i("afterLeave");
    }
    return ce(n, async (u) => {
      u || (await Ee(), s.value.activatorEl?.focus({
        preventScroll: !0
      }));
    }), me(() => {
      const u = Ss.filterProps(e), c = re({
        "aria-haspopup": "dialog"
      }, e.activatorProps), d = re({
        tabindex: -1
      }, e.contentProps);
      return C(Ss, re({
        ref: s,
        class: ["v-dialog", {
          "v-dialog--fullscreen": e.fullscreen,
          "v-dialog--scrollable": e.scrollable
        }, e.class],
        style: e.style
      }, u, {
        modelValue: n.value,
        "onUpdate:modelValue": (f) => n.value = f,
        "aria-modal": "true",
        activatorProps: c,
        contentProps: d,
        height: e.fullscreen ? void 0 : e.height,
        width: e.fullscreen ? void 0 : e.width,
        maxHeight: e.fullscreen ? void 0 : e.maxHeight,
        maxWidth: e.fullscreen ? void 0 : e.maxWidth,
        role: "dialog",
        onAfterEnter: o,
        onAfterLeave: l
      }, t), {
        activator: r.activator,
        default: function() {
          for (var f = arguments.length, v = new Array(f), g = 0; g < f; g++)
            v[g] = arguments[g];
          return C(je, {
            root: "VDialog"
          }, {
            default: () => [r.default?.(...v)]
          });
        }
      });
    }), Pt({}, s);
  }
}), eC = ee({
  ...Se(),
  ...Be()
}, "VCardActions"), tC = de()({
  name: "VCardActions",
  props: eC(),
  setup(e, a) {
    let {
      slots: i
    } = a;
    return da({
      VBtn: {
        slim: !0,
        variant: "text"
      }
    }), me(() => C(e.tag, {
      class: ue(["v-card-actions", e.class]),
      style: be(e.style)
    }, i)), {};
  }
}), aC = ee({
  opacity: [Number, String],
  ...Se(),
  ...Be()
}, "VCardSubtitle"), nC = de()({
  name: "VCardSubtitle",
  props: aC(),
  setup(e, a) {
    let {
      slots: i
    } = a;
    return me(() => C(e.tag, {
      class: ue(["v-card-subtitle", e.class]),
      style: be([{
        "--v-card-subtitle-opacity": e.opacity
      }, e.style])
    }, i)), {};
  }
}), rC = Fn("v-card-title"), iC = ee({
  appendAvatar: String,
  appendIcon: Pe,
  prependAvatar: String,
  prependIcon: Pe,
  subtitle: {
    type: [String, Number, Boolean],
    default: void 0
  },
  title: {
    type: [String, Number, Boolean],
    default: void 0
  },
  ...Se(),
  ...Kt(),
  ...Be()
}, "VCardItem"), sC = de()({
  name: "VCardItem",
  props: iC(),
  setup(e, a) {
    let {
      slots: i
    } = a;
    return me(() => {
      const r = !!(e.prependAvatar || e.prependIcon), n = !!(r || i.prepend), t = !!(e.appendAvatar || e.appendIcon), s = !!(t || i.append), o = !!(e.title != null || i.title), l = !!(e.subtitle != null || i.subtitle);
      return C(e.tag, {
        class: ue(["v-card-item", e.class]),
        style: be(e.style)
      }, {
        default: () => [n && D("div", {
          key: "prepend",
          class: "v-card-item__prepend"
        }, [i.prepend ? C(je, {
          key: "prepend-defaults",
          disabled: !r,
          defaults: {
            VAvatar: {
              density: e.density,
              image: e.prependAvatar
            },
            VIcon: {
              density: e.density,
              icon: e.prependIcon
            }
          }
        }, i.prepend) : D(pe, null, [e.prependAvatar && C(Yt, {
          key: "prepend-avatar",
          density: e.density,
          image: e.prependAvatar
        }, null), e.prependIcon && C(xe, {
          key: "prepend-icon",
          density: e.density,
          icon: e.prependIcon
        }, null)])]), D("div", {
          class: "v-card-item__content"
        }, [o && C(rC, {
          key: "title"
        }, {
          default: () => [i.title?.() ?? Ue(e.title)]
        }), l && C(nC, {
          key: "subtitle"
        }, {
          default: () => [i.subtitle?.() ?? Ue(e.subtitle)]
        }), i.default?.()]), s && D("div", {
          key: "append",
          class: "v-card-item__append"
        }, [i.append ? C(je, {
          key: "append-defaults",
          disabled: !t,
          defaults: {
            VAvatar: {
              density: e.density,
              image: e.appendAvatar
            },
            VIcon: {
              density: e.density,
              icon: e.appendIcon
            }
          }
        }, i.append) : D(pe, null, [e.appendIcon && C(xe, {
          key: "append-icon",
          density: e.density,
          icon: e.appendIcon
        }, null), e.appendAvatar && C(Yt, {
          key: "append-avatar",
          density: e.density,
          image: e.appendAvatar
        }, null)])])]
      });
    }), {};
  }
}), lC = ee({
  opacity: [Number, String],
  ...Se(),
  ...Be()
}, "VCardText"), oC = de()({
  name: "VCardText",
  props: lC(),
  setup(e, a) {
    let {
      slots: i
    } = a;
    return me(() => C(e.tag, {
      class: ue(["v-card-text", e.class]),
      style: be([{
        "--v-card-text-opacity": e.opacity
      }, e.style])
    }, i)), {};
  }
}), uC = ee({
  appendAvatar: String,
  appendIcon: Pe,
  disabled: Boolean,
  flat: Boolean,
  hover: Boolean,
  image: String,
  link: {
    type: Boolean,
    default: void 0
  },
  prependAvatar: String,
  prependIcon: Pe,
  ripple: {
    type: [Boolean, Object],
    default: !0
  },
  subtitle: {
    type: [String, Number, Boolean],
    default: void 0
  },
  text: {
    type: [String, Number, Boolean],
    default: void 0
  },
  title: {
    type: [String, Number, Boolean],
    default: void 0
  },
  ...Aa(),
  ...Se(),
  ...Kt(),
  ...Mt(),
  ...ea(),
  ..._u(),
  ...Un(),
  ...Bs(),
  ...$t(),
  ...Hs(),
  ...Be(),
  ...Qe(),
  ...ja({
    variant: "elevated"
  })
}, "VCard"), Lh = de()({
  name: "VCard",
  directives: {
    vRipple: At
  },
  props: uC(),
  setup(e, a) {
    let {
      attrs: i,
      slots: r
    } = a;
    const {
      themeClasses: n
    } = ut(e), {
      borderClasses: t
    } = Ta(e), {
      colorClasses: s,
      colorStyles: o,
      variantClasses: l
    } = Kn(e), {
      densityClasses: u
    } = Qt(e), {
      dimensionStyles: c
    } = Rt(e), {
      elevationClasses: d
    } = ta(e), {
      loaderClasses: f
    } = zs(e), {
      locationStyles: v
    } = Wn(e), {
      positionClasses: g
    } = Fs(e), {
      roundedClasses: h
    } = _t(e), y = Ks(e, i), m = fe(void 0);
    return ce(() => e.loading, (p, b) => {
      m.value = !p && typeof b == "string" ? b : typeof p == "boolean" ? void 0 : p;
    }, {
      immediate: !0
    }), me(() => {
      const p = e.link !== !1 && y.isLink.value, b = !e.disabled && e.link !== !1 && (e.link || y.isClickable.value), w = p ? "a" : e.tag, k = !!(r.title || e.title != null), S = !!(r.subtitle || e.subtitle != null), _ = k || S, P = !!(r.append || e.appendAvatar || e.appendIcon), M = !!(r.prepend || e.prependAvatar || e.prependIcon), q = !!(r.image || e.image), K = _ || M || P, j = !!(r.text || e.text != null);
      return Je(C(w, re(y.linkProps, {
        class: ["v-card", {
          "v-card--disabled": e.disabled,
          "v-card--flat": e.flat,
          "v-card--hover": e.hover && !(e.disabled || e.flat),
          "v-card--link": b
        }, n.value, t.value, s.value, u.value, d.value, f.value, g.value, h.value, l.value, e.class],
        style: [o.value, c.value, v.value, e.style],
        onClick: b && y.navigate,
        tabindex: e.disabled ? -1 : void 0
      }), {
        default: () => [q && D("div", {
          key: "image",
          class: "v-card__image"
        }, [r.image ? C(je, {
          key: "image-defaults",
          disabled: !e.image,
          defaults: {
            VImg: {
              cover: !0,
              src: e.image
            }
          }
        }, r.image) : C(Zs, {
          key: "image-img",
          cover: !0,
          src: e.image
        }, null)]), C(Pu, {
          name: "v-card",
          active: !!e.loading,
          color: m.value
        }, {
          default: r.loader
        }), K && C(sC, {
          key: "item",
          prependAvatar: e.prependAvatar,
          prependIcon: e.prependIcon,
          title: e.title,
          subtitle: e.subtitle,
          appendAvatar: e.appendAvatar,
          appendIcon: e.appendIcon
        }, {
          default: r.item,
          prepend: r.prepend,
          title: r.title,
          subtitle: r.subtitle,
          append: r.append
        }), j && C(oC, {
          key: "text"
        }, {
          default: () => [r.text?.() ?? e.text]
        }), r.default?.(), r.actions && C(tC, null, {
          default: r.actions
        }), yn(b, "v-card")]
      }), [[At, b && e.ripple]]);
    }), {};
  }
}), cC = ee({
  alwaysFilter: Boolean,
  autoSelectFirst: {
    type: [Boolean, String]
  },
  clearOnSelect: {
    type: Boolean,
    default: !0
  },
  delimiters: Array,
  ...Dh({
    filterKeys: ["title"]
  }),
  ...Zu({
    hideNoData: !0,
    returnObject: !0
  }),
  ...Le(Zn({
    modelValue: null,
    role: "combobox"
  }), ["validationValue", "dirty"])
}, "VCombobox"), qh = de()({
  name: "VCombobox",
  props: cC(),
  emits: {
    "update:focused": (e) => !0,
    "update:modelValue": (e) => !0,
    "update:search": (e) => !0,
    "update:menu": (e) => !0
  },
  setup(e, a) {
    let {
      emit: i,
      slots: r
    } = a;
    const {
      t: n
    } = nt(), t = ie(), s = fe(!1), o = fe(!0), l = fe(!1), u = ie(), c = ie(), d = fe(-1);
    let f = !1;
    const {
      items: v,
      transformIn: g,
      transformOut: h
    } = Wu(e), {
      textColorClasses: y,
      textColorStyles: m
    } = kt(() => t.value?.color), {
      InputIcon: p
    } = zr(e), b = $e(e, "modelValue", [], (se) => g(Ze(se)), (se) => {
      const ge = h(se);
      return e.multiple ? ge : ge[0] ?? null;
    }), w = Xn(e), k = W(() => e.closableChips && !w.isReadonly.value && !w.isDisabled.value), S = I(() => !!(e.chips || r.chip)), _ = I(() => S.value || !!r.selection), P = fe(!e.multiple && !_.value ? b.value[0]?.title ?? "" : ""), M = fe(null), q = I({
      get: () => P.value,
      set: async (se) => {
        if (P.value = se ?? "", se === null || se === "" && !e.multiple && !_.value ? b.value = [] : !e.multiple && !_.value && (b.value = [ra(e, se)], Ee(() => c.value?.scrollToIndex(0))), se && e.multiple && e.delimiters?.length) {
          const ge = ve(se);
          ge.length > 1 && (ne(ge), P.value = "");
        }
        se || (d.value = -1), o.value = !se;
      }
    }), K = I(() => typeof e.counterValue == "function" ? e.counterValue(b.value) : typeof e.counterValue == "number" ? e.counterValue : e.multiple ? b.value.length : q.value.length), {
      filteredItems: j,
      getMatches: H
    } = Mh(e, v, () => M.value ?? (e.alwaysFilter || !o.value ? q.value : "")), B = I(() => e.hideSelected && M.value === null ? j.value.filter((se) => !b.value.some((ge) => ge.value === se.value)) : j.value), L = I(() => e.hideNoData && !B.value.length || w.isReadonly.value || w.isDisabled.value), O = $e(e, "menu"), U = I({
      get: () => O.value,
      set: (se) => {
        O.value && !se && u.value?.ΨopenChildren.size || se && L.value || (O.value = se);
      }
    }), {
      menuId: Z,
      ariaExpanded: J,
      ariaControls: A
    } = Xu(e, U);
    ce(P, (se) => {
      f ? Ee(() => f = !1) : s.value && !U.value && (U.value = !0), i("update:search", se);
    }), ce(b, (se) => {
      !e.multiple && !_.value && (P.value = se[0]?.title ?? "");
    });
    const T = I(() => b.value.map((se) => se.value)), E = I(() => B.value.find((se) => se.type === "item" && !se.props.disabled)), x = I(() => (e.autoSelectFirst === !0 || e.autoSelectFirst === "exact" && q.value === E.value?.title) && B.value.length > 0 && !o.value && !l.value), $ = ie(), V = Yu($, t);
    function F(se) {
      f = !0, Ee(() => f = !1), e.openOnClear && (U.value = !0);
    }
    function z() {
      L.value || (U.value = !0);
    }
    function X(se) {
      L.value || (s.value && (se.preventDefault(), se.stopPropagation()), U.value = !U.value);
    }
    function Q(se) {
      (Tn(se) || se.key === "Backspace") && t.value?.focus();
    }
    function te(se) {
      if (Z0(se) || w.isReadonly.value) return;
      const ge = t.value?.selectionStart, we = b.value.length;
      if (["Enter", "ArrowDown", "ArrowUp"].includes(se.key) && se.preventDefault(), ["Enter", "ArrowDown"].includes(se.key) && (U.value = !0), ["Escape"].includes(se.key) && (U.value = !1), x.value && ["Enter", "Tab"].includes(se.key) && E.value && !b.value.some((ke) => {
        let {
          value: ze
        } = ke;
        return ze === E.value.value;
      }) && ae(E.value), se.key === "ArrowDown" && x.value && $.value?.focus("next"), se.key === "Enter" && q.value && (ae(ra(e, q.value), !0, !0), _.value && (P.value = "")), ["Backspace", "Delete"].includes(se.key)) {
        if (!e.multiple && _.value && b.value.length > 0 && !q.value) return ae(b.value[0], !1);
        if (~d.value) {
          se.preventDefault();
          const ke = d.value;
          ae(b.value[d.value], !1), d.value = ke >= we - 1 ? we - 2 : ke;
        } else se.key === "Backspace" && !q.value && (d.value = we - 1);
        return;
      }
      if (e.multiple)
        if (se.key === "ArrowLeft") {
          if (d.value < 0 && ge && ge > 0) return;
          const ke = d.value > -1 ? d.value - 1 : we - 1;
          b.value[ke] ? d.value = ke : (d.value = -1, t.value?.setSelectionRange(q.value.length, q.value.length));
        } else if (se.key === "ArrowRight") {
          if (d.value < 0) return;
          const ke = d.value + 1;
          b.value[ke] ? d.value = ke : (d.value = -1, t.value?.setSelectionRange(0, 0));
        } else ~d.value && Tn(se) && (d.value = -1);
    }
    function N(se) {
      const ge = se?.clipboardData?.getData("Text") ?? "", we = ve(ge);
      we.length > 1 && e.multiple && (se.preventDefault(), ne(we));
    }
    function R() {
      e.eager && c.value?.calculateVisibleItems();
    }
    function G() {
      s.value && t.value?.focus(), o.value = !0, M.value = null;
    }
    function ae(se) {
      let ge = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0, we = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
      if (!(!se || se.props.disabled))
        if (e.multiple) {
          const ke = b.value.findIndex((Ne) => (e.valueComparator || bt)(Ne.value, se.value)), ze = ge ?? !~ke;
          if (~ke) {
            const Ne = ze ? [...b.value, se] : [...b.value];
            Ne.splice(ke, 1), b.value = Ne;
          } else ze && (b.value = [...b.value, se]);
          e.clearOnSelect && (q.value = "");
        } else {
          const ke = ge !== !1;
          b.value = ke ? [se] : [], (!o.value || e.alwaysFilter) && P.value && (M.value = P.value), P.value = ke && !_.value ? se.title : "", Ee(() => {
            U.value = we, o.value = !0;
          });
        }
    }
    function ve(se) {
      const we = [`
`, ...e.delimiters ?? []].map(hs).join("|");
      return se.split(new RegExp(`(?:${we})+`));
    }
    async function ne(se) {
      for (let ge of se)
        ge = ge.trim(), ge && (ae(ra(e, ge)), await Ee());
    }
    function _e(se) {
      s.value = !0, setTimeout(() => {
        l.value = !0;
      });
    }
    function Ce(se) {
      l.value = !1;
    }
    return ce(s, (se, ge) => {
      if (!(se || se === ge) && (d.value = -1, U.value = !1, q.value)) {
        if (e.multiple) {
          ae(ra(e, q.value));
          return;
        }
        if (!_.value) return;
        b.value.some((we) => {
          let {
            title: ke
          } = we;
          return ke === q.value;
        }) ? P.value = "" : ae(ra(e, q.value));
      }
    }), ce(U, (se) => {
      if (!e.hideSelected && se && b.value.length && o.value) {
        const ge = B.value.findIndex((we) => b.value.some((ke) => (e.valueComparator || bt)(ke.value, we.value)));
        et && window.requestAnimationFrame(() => {
          ge >= 0 && c.value?.scrollToIndex(ge);
        });
      }
      se && (M.value = null);
    }), ce(v, (se, ge) => {
      U.value || s.value && !ge.length && se.length && (U.value = !0);
    }), me(() => {
      const se = !!(!e.hideNoData || B.value.length || r["prepend-item"] || r["append-item"] || r["no-data"]), ge = b.value.length > 0, we = Dt.filterProps(e);
      return C(Dt, re({
        ref: t
      }, we, {
        modelValue: q.value,
        "onUpdate:modelValue": (ke) => q.value = ke,
        focused: s.value,
        "onUpdate:focused": (ke) => s.value = ke,
        validationValue: b.externalValue,
        counterValue: K.value,
        dirty: ge,
        class: ["v-combobox", {
          "v-combobox--active-menu": U.value,
          "v-combobox--chips": !!e.chips,
          "v-combobox--selection-slot": !!_.value,
          "v-combobox--selecting-index": d.value > -1,
          [`v-combobox--${e.multiple ? "multiple" : "single"}`]: !0
        }, e.class],
        style: e.style,
        readonly: w.isReadonly.value,
        placeholder: ge ? void 0 : e.placeholder,
        "onClick:clear": F,
        "onMousedown:control": z,
        onKeydown: te,
        onPaste: N,
        "aria-expanded": J.value,
        "aria-controls": A.value
      }), {
        ...r,
        default: (ke) => {
          let {
            id: ze
          } = ke;
          return D(pe, null, [C(La, re({
            id: Z.value,
            ref: u,
            modelValue: U.value,
            "onUpdate:modelValue": (Ne) => U.value = Ne,
            activator: "parent",
            contentClass: "v-combobox__content",
            disabled: L.value,
            eager: e.eager,
            maxHeight: 310,
            openOnClick: !1,
            closeOnContentClick: !1,
            onAfterEnter: R,
            onAfterLeave: G
          }, e.menuProps), {
            default: () => [se && C(Sr, re({
              ref: $,
              filterable: !0,
              selected: T.value,
              selectStrategy: e.multiple ? "independent" : "single-independent",
              onMousedown: (Ne) => Ne.preventDefault(),
              selectable: !!B.value.length,
              onKeydown: Q,
              onFocusin: _e,
              onFocusout: Ce,
              tabindex: "-1",
              "aria-live": "polite",
              "aria-labelledby": `${ze.value}-label`,
              "aria-multiselectable": e.multiple,
              color: e.itemColor ?? e.color
            }, V, e.listProps), {
              default: () => [r["prepend-item"]?.(), !B.value.length && !e.hideNoData && (r["no-data"]?.() ?? C(it, {
                key: "no-data",
                title: n(e.noDataText)
              }, null)), C(Gu, {
                ref: c,
                renderless: !0,
                items: B.value,
                itemKey: "value"
              }, {
                default: (Ne) => {
                  let {
                    item: Re,
                    index: rt,
                    itemRef: tt
                  } = Ne;
                  const fa = re(Re.props, {
                    ref: tt,
                    key: Re.value,
                    active: x.value && Re === E.value ? !0 : void 0,
                    onClick: () => ae(Re, null),
                    "aria-posinset": rt + 1,
                    "aria-setsize": B.value.length
                  });
                  return Re.type === "divider" ? r.divider?.({
                    props: Re.raw,
                    index: rt
                  }) ?? C(ia, re(Re.props, {
                    key: `divider-${rt}`
                  }), null) : Re.type === "subheader" ? r.subheader?.({
                    props: Re.raw,
                    index: rt
                  }) ?? C(kn, re(Re.props, {
                    key: `subheader-${rt}`
                  }), null) : r.item?.({
                    item: Re,
                    index: rt,
                    props: fa
                  }) ?? C(it, re(fa, {
                    role: "option"
                  }), {
                    prepend: (Da) => {
                      let {
                        isSelected: Ct
                      } = Da;
                      return D(pe, null, [e.multiple && !e.hideSelected ? C(Mn, {
                        key: Re.value,
                        modelValue: Ct,
                        ripple: !1,
                        tabindex: "-1",
                        "aria-hidden": !0,
                        onClick: (ty) => ty.preventDefault()
                      }, null) : void 0, Re.props.prependAvatar && C(Yt, {
                        image: Re.props.prependAvatar
                      }, null), Re.props.prependIcon && C(xe, {
                        icon: Re.props.prependIcon
                      }, null)]);
                    },
                    title: () => o.value ? Re.title : Rh("v-combobox", Re.title, H(Re)?.title)
                  });
                }
              }), r["append-item"]?.()]
            })]
          }), b.value.map((Ne, Re) => {
            function rt(Ct) {
              Ct.stopPropagation(), Ct.preventDefault(), ae(Ne, !1);
            }
            const tt = re(vn.filterProps(Ne.props), {
              "onClick:close": rt,
              onKeydown(Ct) {
                Ct.key !== "Enter" && Ct.key !== " " || (Ct.preventDefault(), Ct.stopPropagation(), rt(Ct));
              },
              onMousedown(Ct) {
                Ct.preventDefault(), Ct.stopPropagation();
              },
              modelValue: !0,
              "onUpdate:modelValue": void 0
            }), fa = S.value ? !!r.chip : !!r.selection, Da = fa ? Rs(S.value ? r.chip({
              item: Ne,
              index: Re,
              props: tt
            }) : r.selection({
              item: Ne,
              index: Re
            })) : void 0;
            if (!(fa && !Da))
              return D("div", {
                key: Ne.value,
                class: ue(["v-combobox__selection", Re === d.value && ["v-combobox__selection--selected", y.value]]),
                style: be(Re === d.value ? m.value : {})
              }, [S.value ? r.chip ? C(je, {
                key: "chip-defaults",
                defaults: {
                  VChip: {
                    closable: k.value,
                    size: "small",
                    text: Ne.title
                  }
                }
              }, {
                default: () => [Da]
              }) : C(vn, re({
                key: "chip",
                closable: k.value,
                size: "small",
                text: Ne.title,
                disabled: Ne.props.disabled
              }, tt), null) : Da ?? D("span", {
                class: "v-combobox__selection-text"
              }, [Ne.title, e.multiple && Re < b.value.length - 1 && D("span", {
                class: "v-combobox__selection-comma"
              }, [Fe(",")])])]);
          })]);
        },
        "append-inner": function() {
          for (var ke = arguments.length, ze = new Array(ke), Ne = 0; Ne < ke; Ne++)
            ze[Ne] = arguments[Ne];
          return D(pe, null, [r["append-inner"]?.(...ze), (!e.hideNoData || e.items.length) && e.menuIcon ? C(xe, {
            class: "v-combobox__menu-icon",
            color: t.value?.fieldIconColor,
            icon: e.menuIcon,
            onMousedown: X,
            onClick: Uv,
            "aria-hidden": !0,
            tabindex: "-1"
          }, null) : void 0, e.appendInnerIcon && C(p, {
            key: "append-icon",
            name: "appendInner",
            color: ze[0].iconColor.value
          }, null)]);
        }
      });
    }), Pt({
      isFocused: s,
      isPristine: o,
      menu: U,
      search: q,
      selectionIndex: d,
      filteredItems: j,
      select: ae
    }, t);
  }
}), $r = /* @__PURE__ */ Symbol.for("vuetify:v-expansion-panel"), zh = ee({
  ...Se(),
  ...Iu()
}, "VExpansionPanelText"), Fo = de()({
  name: "VExpansionPanelText",
  props: zh(),
  setup(e, a) {
    let {
      slots: i
    } = a;
    const r = qe($r);
    if (!r) throw new Error("[Vuetify] v-expansion-panel-text needs to be placed inside v-expansion-panel");
    const {
      hasContent: n,
      onAfterLeave: t
    } = Ou(e, r.isSelected);
    return me(() => C(xu, {
      onAfterLeave: t
    }, {
      default: () => [Je(D("div", {
        class: ue(["v-expansion-panel-text", e.class]),
        style: be(e.style)
      }, [i.default && n.value && D("div", {
        class: "v-expansion-panel-text__wrapper"
      }, [i.default?.()])]), [[ya, r.isSelected.value]])]
    })), {};
  }
}), Bh = ee({
  color: String,
  expandIcon: {
    type: Pe,
    default: "$expand"
  },
  collapseIcon: {
    type: Pe,
    default: "$collapse"
  },
  hideActions: Boolean,
  focusable: Boolean,
  static: Boolean,
  ripple: {
    type: [Boolean, Object],
    default: !1
  },
  readonly: Boolean,
  ...Se(),
  ...Mt()
}, "VExpansionPanelTitle"), Ko = de()({
  name: "VExpansionPanelTitle",
  directives: {
    vRipple: At
  },
  props: Bh(),
  setup(e, a) {
    let {
      slots: i
    } = a;
    const r = qe($r);
    if (!r) throw new Error("[Vuetify] v-expansion-panel-title needs to be placed inside v-expansion-panel");
    const {
      backgroundColorClasses: n,
      backgroundColorStyles: t
    } = at(() => e.color), {
      dimensionStyles: s
    } = Rt(e), o = I(() => ({
      collapseIcon: e.collapseIcon,
      disabled: r.disabled.value,
      expanded: r.isSelected.value,
      expandIcon: e.expandIcon,
      readonly: e.readonly
    })), l = W(() => r.isSelected.value ? e.collapseIcon : e.expandIcon);
    return me(() => Je(D("button", {
      class: ue(["v-expansion-panel-title", {
        "v-expansion-panel-title--active": r.isSelected.value,
        "v-expansion-panel-title--focusable": e.focusable,
        "v-expansion-panel-title--static": e.static
      }, n.value, e.class]),
      style: be([t.value, s.value, e.style]),
      type: "button",
      tabindex: r.disabled.value ? -1 : void 0,
      disabled: r.disabled.value,
      "aria-expanded": r.isSelected.value,
      onClick: e.readonly ? void 0 : r.toggle
    }, [D("span", {
      class: "v-expansion-panel-title__overlay"
    }, null), i.default?.(o.value), !e.hideActions && C(je, {
      defaults: {
        VIcon: {
          icon: l.value
        }
      }
    }, {
      default: () => [D("span", {
        class: "v-expansion-panel-title__icon"
      }, [i.actions?.(o.value) ?? C(xe, null, null)])]
    })]), [[At, e.ripple]])), {};
  }
}), Fh = ee({
  title: String,
  text: String,
  bgColor: String,
  ...ea(),
  ...Rr(),
  ...$t(),
  ...Be(),
  ...Bh(),
  ...zh()
}, "VExpansionPanel"), dC = de()({
  name: "VExpansionPanel",
  props: Fh(),
  emits: {
    "group:selected": (e) => !0
  },
  setup(e, a) {
    let {
      slots: i
    } = a;
    const r = jn(e, $r), {
      backgroundColorClasses: n,
      backgroundColorStyles: t
    } = at(() => e.bgColor), {
      elevationClasses: s
    } = ta(e), {
      roundedClasses: o
    } = _t(e), l = W(() => r?.disabled.value || e.disabled), u = I(() => r.group.items.value.reduce((f, v, g) => (r.group.selected.value.includes(v.id) && f.push(g), f), [])), c = I(() => {
      const f = r.group.items.value.findIndex((v) => v.id === r.id);
      return !r.isSelected.value && u.value.some((v) => v - f === 1);
    }), d = I(() => {
      const f = r.group.items.value.findIndex((v) => v.id === r.id);
      return !r.isSelected.value && u.value.some((v) => v - f === -1);
    });
    return ht($r, r), me(() => {
      const f = !!(i.text || e.text), v = !!(i.title || e.title), g = Ko.filterProps(e), h = Fo.filterProps(e);
      return C(e.tag, {
        class: ue(["v-expansion-panel", {
          "v-expansion-panel--active": r.isSelected.value,
          "v-expansion-panel--before-active": c.value,
          "v-expansion-panel--after-active": d.value,
          "v-expansion-panel--disabled": l.value
        }, o.value, n.value, e.class]),
        style: be([t.value, e.style])
      }, {
        default: () => [D("div", {
          class: ue(["v-expansion-panel__shadow", ...s.value])
        }, null), C(je, {
          defaults: {
            VExpansionPanelTitle: {
              ...g
            },
            VExpansionPanelText: {
              ...h
            }
          }
        }, {
          default: () => [v && C(Ko, {
            key: "title"
          }, {
            default: () => [i.title ? i.title() : e.title]
          }), f && C(Fo, {
            key: "text"
          }, {
            default: () => [i.text ? i.text() : e.text]
          }), i.default?.()]
        })]
      });
    }), {
      groupItem: r
    };
  }
}), fC = ["default", "accordion", "inset", "popout"], mC = ee({
  flat: Boolean,
  ...Mr(),
  ...za(Fh(), ["bgColor", "collapseIcon", "color", "eager", "elevation", "expandIcon", "focusable", "hideActions", "readonly", "ripple", "rounded", "tile", "static"]),
  ...Qe(),
  ...Se(),
  ...Be(),
  variant: {
    type: String,
    default: "default",
    validator: (e) => fC.includes(e)
  }
}, "VExpansionPanels"), vC = de()({
  name: "VExpansionPanels",
  props: mC(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, a) {
    let {
      slots: i
    } = a;
    const {
      next: r,
      prev: n
    } = Hn(e, $r), {
      themeClasses: t
    } = ut(e), s = W(() => e.variant && `v-expansion-panels--variant-${e.variant}`);
    return da({
      VExpansionPanel: {
        bgColor: W(() => e.bgColor),
        collapseIcon: W(() => e.collapseIcon),
        color: W(() => e.color),
        eager: W(() => e.eager),
        elevation: W(() => e.elevation),
        expandIcon: W(() => e.expandIcon),
        focusable: W(() => e.focusable),
        hideActions: W(() => e.hideActions),
        readonly: W(() => e.readonly),
        ripple: W(() => e.ripple),
        rounded: W(() => e.rounded),
        static: W(() => e.static)
      }
    }), me(() => C(e.tag, {
      class: ue(["v-expansion-panels", {
        "v-expansion-panels--flat": e.flat,
        "v-expansion-panels--tile": e.tile
      }, t.value, s.value, e.class]),
      style: be(e.style)
    }, {
      default: () => [i.default?.({
        prev: n,
        next: r
      })]
    })), {
      next: r,
      prev: n
    };
  }
});
function pC() {
  function e(i) {
    return [...i.dataTransfer?.items ?? []].filter((n) => n.kind === "file").map((n) => n.webkitGetAsEntry()).filter(Boolean).length > 0 || [...i.dataTransfer?.files ?? []].length > 0;
  }
  async function a(i) {
    const r = [], n = [...i.dataTransfer?.items ?? []].filter((t) => t.kind === "file").map((t) => t.webkitGetAsEntry()).filter(Boolean);
    if (n.length)
      for (const t of n) {
        const s = await Kh(t, Hh(".", t));
        r.push(...s.map((o) => o.file));
      }
    else
      r.push(...i.dataTransfer?.files ?? []);
    return r;
  }
  return {
    handleDrop: a,
    hasFilesOrFolders: e
  };
}
function Kh(e) {
  let a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
  return new Promise((i, r) => {
    e.isFile ? e.file((t) => i([{
      file: t,
      path: a
    }]), r) : e.isDirectory && e.createReader().readEntries(async (t) => {
      const s = [];
      for (const o of t)
        s.push(...await Kh(o, Hh(a, o)));
      i(s);
    });
  });
}
function Hh(e, a) {
  return a.isDirectory ? `${e}/${a.name}` : e;
}
const hC = ee({
  filterByType: String
}, "file-accept");
function yC(e) {
  const a = I(() => e.filterByType ? gC(e.filterByType) : null);
  function i(r) {
    if (a.value) {
      const n = r.filter(a.value);
      return {
        accepted: n,
        rejected: r.filter((t) => !n.includes(t))
      };
    }
    return {
      accepted: r,
      rejected: []
    };
  }
  return {
    filterAccepted: i
  };
}
function gC(e) {
  const a = e.split(",").map((t) => t.trim().toLowerCase()), i = a.filter((t) => t.startsWith(".")), r = a.filter((t) => t.endsWith("/*")), n = a.filter((t) => !i.includes(t) && !r.includes(t));
  return (t) => {
    const s = t.name.split(".").at(-1)?.toLowerCase() ?? "", o = t.type.split("/").at(0)?.toLowerCase() ?? "";
    return n.includes(t.type) || i.includes(`.${s}`) || r.includes(`${o}/*`);
  };
}
const bC = ee({
  chips: Boolean,
  counter: Boolean,
  counterSizeString: {
    type: String,
    default: "$vuetify.fileInput.counterSize"
  },
  counterString: {
    type: String,
    default: "$vuetify.fileInput.counter"
  },
  hideInput: Boolean,
  multiple: Boolean,
  showSize: {
    type: [Boolean, Number, String],
    default: !1,
    validator: (e) => typeof e == "boolean" || [1e3, 1024].includes(Number(e))
  },
  truncateLength: {
    type: [Number, String],
    default: 22
  },
  ...Le(Ka({
    prependIcon: "$file"
  }), ["direction"]),
  modelValue: {
    type: [Array, Object],
    default: (e) => e.multiple ? [] : null,
    validator: (e) => Ze(e).every((a) => a != null && typeof a == "object")
  },
  ...hC(),
  ...Gs({
    clearable: !0
  })
}, "VFileInput"), kC = de()({
  name: "VFileInput",
  inheritAttrs: !1,
  props: bC(),
  emits: {
    "click:control": (e) => !0,
    "mousedown:control": (e) => !0,
    "update:focused": (e) => !0,
    "update:modelValue": (e) => !0,
    rejected: (e) => !0
  },
  setup(e, a) {
    let {
      attrs: i,
      emit: r,
      slots: n
    } = a;
    const {
      t
    } = nt(), {
      filterAccepted: s
    } = yC(e), o = $e(e, "modelValue", e.modelValue, (J) => Ze(J), (J) => !e.multiple && Array.isArray(J) ? J[0] : J), {
      isFocused: l,
      focus: u,
      blur: c
    } = bn(e), d = I(() => typeof e.showSize != "boolean" ? e.showSize : void 0), f = I(() => (o.value ?? []).reduce((J, A) => {
      let {
        size: T = 0
      } = A;
      return J + T;
    }, 0)), v = I(() => Df(f.value, d.value)), g = I(() => (o.value ?? []).map((J) => {
      const {
        name: A = "",
        size: T = 0
      } = J, E = H(A);
      return e.showSize ? `${E} (${Df(T, d.value)})` : E;
    })), h = I(() => {
      const J = o.value?.length ?? 0;
      return e.showSize ? t(e.counterSizeString, J, v.value) : t(e.counterString, J);
    }), y = ie(), m = ie(), p = ie(), b = W(() => l.value || e.active), w = I(() => ["plain", "underlined"].includes(e.variant)), k = fe(!1), {
      handleDrop: S,
      hasFilesOrFolders: _
    } = pC();
    function P() {
      p.value !== document.activeElement && p.value?.focus(), l.value || u();
    }
    function M(J) {
      p.value?.click();
    }
    function q(J) {
      r("mousedown:control", J);
    }
    function K(J) {
      p.value?.click(), r("click:control", J);
    }
    function j(J) {
      J.stopPropagation(), P(), Ee(() => {
        o.value = [], Ms(e["onClick:clear"], J);
      });
    }
    function H(J) {
      if (J.length < Number(e.truncateLength)) return J;
      const A = Math.floor((Number(e.truncateLength) - 1) / 2);
      return `${J.slice(0, A)}…${J.slice(J.length - A)}`;
    }
    function B(J) {
      J.preventDefault(), J.stopImmediatePropagation(), k.value = !0;
    }
    function L(J) {
      J.preventDefault(), k.value = !1;
    }
    async function O(J) {
      if (J.preventDefault(), J.stopImmediatePropagation(), k.value = !1, !p.value || !_(J)) return;
      const A = await S(J);
      Z(A);
    }
    function U(J) {
      if (!(!J.target || J.repack))
        if (e.filterByType)
          Z([...J.target.files]);
        else {
          const A = J.target;
          o.value = [...A.files ?? []];
        }
    }
    function Z(J) {
      const A = new DataTransfer(), {
        accepted: T,
        rejected: E
      } = s(J);
      E.length && r("rejected", E);
      for (const $ of T)
        A.items.add($);
      p.value.files = A.files, o.value = [...A.files];
      const x = new Event("change", {
        bubbles: !0
      });
      x.repack = !0, p.value.dispatchEvent(x);
    }
    return ce(o, (J) => {
      (!Array.isArray(J) || !J.length) && p.value && (p.value.value = "");
    }), me(() => {
      const J = !!(n.counter || e.counter), A = !!(J || n.details), [T, E] = Ba(i), {
        modelValue: x,
        ...$
      } = Tt.filterProps(e), V = {
        ...Dn.filterProps(e),
        "onClick:clear": j
      }, F = i.webkitdirectory !== void 0 && i.webkitdirectory !== !1, z = i.accept ? String(i.accept) : void 0, X = F ? void 0 : e.filterByType ?? z;
      return C(Tt, re({
        ref: y,
        modelValue: e.multiple ? o.value : o.value[0],
        class: ["v-file-input", {
          "v-file-input--chips": !!e.chips,
          "v-file-input--dragging": k.value,
          "v-file-input--hide": e.hideInput,
          "v-input--plain-underlined": w.value
        }, e.class],
        style: e.style,
        "onClick:prepend": M
      }, T, $, {
        centerAffix: !w.value,
        focused: l.value
      }), {
        ...n,
        default: (Q) => {
          let {
            id: te,
            isDisabled: N,
            isDirty: R,
            isReadonly: G,
            isValid: ae,
            hasDetails: ve
          } = Q;
          return C(Dn, re({
            ref: m,
            prependIcon: e.prependIcon,
            onMousedown: q,
            onClick: K,
            "onClick:prependInner": e["onClick:prependInner"],
            "onClick:appendInner": e["onClick:appendInner"]
          }, V, {
            id: te.value,
            active: b.value || R.value,
            dirty: R.value || e.dirty,
            disabled: N.value,
            focused: l.value,
            details: ve.value,
            error: ae.value === !1,
            onDragover: B,
            onDrop: O
          }), {
            ...n,
            default: (ne) => {
              let {
                props: {
                  class: _e,
                  ...Ce
                },
                controlRef: se
              } = ne;
              return D(pe, null, [D("input", re({
                ref: (ge) => p.value = se.value = ge,
                type: "file",
                accept: X,
                readonly: G.value,
                disabled: N.value,
                multiple: e.multiple,
                name: e.name,
                onClick: (ge) => {
                  ge.stopPropagation(), G.value && ge.preventDefault(), P();
                },
                onChange: U,
                onDragleave: L,
                onFocus: P,
                onBlur: c
              }, Ce, E), null), D("div", {
                class: ue(_e)
              }, [!!o.value?.length && !e.hideInput && (n.selection ? n.selection({
                fileNames: g.value,
                totalBytes: f.value,
                totalBytesReadable: v.value
              }) : e.chips ? g.value.map((ge) => C(vn, {
                key: ge,
                size: "small",
                text: ge
              }, null)) : g.value.join(", "))])]);
            }
          });
        },
        details: A ? (Q) => D(pe, null, [n.details?.(Q), J && D(pe, null, [D("span", null, null), C(Tu, {
          active: !!o.value?.length,
          value: h.value,
          disabled: e.disabled
        }, n.counter)])]) : void 0
      });
    }), Pt({}, y, m, p);
  }
}), wC = ee({
  ...Se(),
  ...i1()
}, "VForm"), SC = de()({
  name: "VForm",
  props: wC(),
  emits: {
    "update:modelValue": (e) => !0,
    submit: (e) => !0
  },
  setup(e, a) {
    let {
      slots: i,
      emit: r
    } = a;
    const n = s1(e), t = ie();
    function s(l) {
      l.preventDefault(), n.reset();
    }
    function o(l) {
      const u = l, c = n.validate();
      u.then = c.then.bind(c), u.catch = c.catch.bind(c), u.finally = c.finally.bind(c), r("submit", u), u.defaultPrevented || c.then((d) => {
        let {
          valid: f
        } = d;
        f && t.value?.submit();
      }), u.preventDefault();
    }
    return me(() => D("form", {
      ref: t,
      class: ue(["v-form", e.class]),
      style: be(e.style),
      novalidate: !0,
      onReset: s,
      onSubmit: o
    }, [i.default?.(n)])), Pt(n, t);
  }
}), $C = ee({
  ...Ys({
    falseIcon: "$radioOff",
    trueIcon: "$radioOn"
  })
}, "VRadio"), _C = de()({
  name: "VRadio",
  props: $C(),
  setup(e, a) {
    let {
      slots: i
    } = a;
    return me(() => {
      const r = mn.filterProps(e);
      return C(mn, re(r, {
        class: ["v-radio", e.class],
        style: e.style,
        type: "radio"
      }), i);
    }), {};
  }
}), PC = ee({
  height: {
    type: [Number, String],
    default: "auto"
  },
  ...Le(Ka(), ["direction"]),
  ...Le(Du(), ["multiple"]),
  trueIcon: {
    type: Pe,
    default: "$radioOn"
  },
  falseIcon: {
    type: Pe,
    default: "$radioOff"
  },
  type: {
    type: String,
    default: "radio"
  }
}, "VRadioGroup"), CC = de()({
  name: "VRadioGroup",
  inheritAttrs: !1,
  props: PC(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, a) {
    let {
      attrs: i,
      slots: r
    } = a;
    const n = Xt(), t = I(() => e.id || `radio-group-${n}`), s = $e(e, "modelValue"), o = ie();
    return me(() => {
      const [l, u] = Ba(i), c = Tt.filterProps(e), d = mn.filterProps(e), f = r.label ? r.label({
        label: e.label,
        props: {
          for: t.value
        }
      }) : e.label;
      return C(Tt, re({
        ref: o,
        class: ["v-radio-group", e.class],
        style: e.style
      }, l, c, {
        modelValue: s.value,
        "onUpdate:modelValue": (v) => s.value = v,
        id: t.value
      }), {
        ...r,
        default: (v) => {
          let {
            id: g,
            messagesId: h,
            isDisabled: y,
            isReadonly: m
          } = v;
          return D(pe, null, [f && C(qr, {
            id: g.value
          }, {
            default: () => [f]
          }), C(g1, re(d, {
            id: g.value,
            "aria-describedby": h.value,
            defaultsTarget: "VRadio",
            trueIcon: e.trueIcon,
            falseIcon: e.falseIcon,
            type: e.type,
            disabled: y.value,
            readonly: m.value,
            "aria-labelledby": f ? g.value : void 0,
            multiple: !1
          }, u, {
            modelValue: s.value,
            "onUpdate:modelValue": (p) => s.value = p
          }), r)]);
        }
      });
    }), Pt({}, o);
  }
}), xC = {
  actions: "button@2",
  article: "heading, paragraph",
  avatar: "avatar",
  button: "button",
  card: "image, heading",
  "card-avatar": "image, list-item-avatar",
  chip: "chip",
  "date-picker": "list-item, heading, divider, date-picker-options, date-picker-days, actions",
  "date-picker-options": "text, avatar@2",
  "date-picker-days": "avatar@28",
  divider: "divider",
  heading: "heading",
  image: "image",
  "list-item": "text",
  "list-item-avatar": "avatar, text",
  "list-item-two-line": "sentences",
  "list-item-avatar-two-line": "avatar, sentences",
  "list-item-three-line": "paragraph",
  "list-item-avatar-three-line": "avatar, paragraph",
  ossein: "ossein",
  paragraph: "text@3",
  sentences: "text@2",
  subtitle: "text",
  table: "table-heading, table-thead, table-tbody, table-tfoot",
  "table-heading": "chip, text",
  "table-thead": "heading@6",
  "table-tbody": "table-row-divider@6",
  "table-row-divider": "table-row, divider",
  "table-row": "text@6",
  "table-tfoot": "text@2, avatar@2",
  text: "text"
};
function VC(e) {
  let a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  return D("div", {
    class: ue(["v-skeleton-loader__bone", `v-skeleton-loader__${e}`])
  }, [a]);
}
function Hm(e) {
  const [a, i] = e.split("@");
  return Array.from({
    length: i
  }).map(() => Js(a));
}
function Js(e) {
  let a = [];
  if (!e) return a;
  const i = xC[e];
  if (e !== i) {
    if (e.includes(",")) return Um(e);
    if (e.includes("@")) return Hm(e);
    i.includes(",") ? a = Um(i) : i.includes("@") ? a = Hm(i) : i && a.push(Js(i));
  }
  return [VC(e, a)];
}
function Um(e) {
  return e.replace(/\s/g, "").split(",").map(Js);
}
const IC = ee({
  boilerplate: Boolean,
  color: String,
  loading: Boolean,
  loadingText: {
    type: String,
    default: "$vuetify.loading"
  },
  type: {
    type: [String, Array],
    default: "ossein"
  },
  ...Mt(),
  ...ea(),
  ...Qe()
}, "VSkeletonLoader"), Uh = de()({
  name: "VSkeletonLoader",
  inheritAttrs: !1,
  props: IC(),
  setup(e, a) {
    let {
      attrs: i,
      slots: r
    } = a;
    const {
      backgroundColorClasses: n,
      backgroundColorStyles: t
    } = at(() => e.color), {
      dimensionStyles: s
    } = Rt(e), {
      elevationClasses: o
    } = ta(e), {
      themeClasses: l
    } = ut(e), {
      t: u
    } = nt(), c = I(() => Js(Ze(e.type).join(",")));
    return me(() => {
      const d = !r.default || e.loading, f = e.boilerplate || !d ? {} : {
        ariaLive: "polite",
        ariaLabel: u(e.loadingText),
        role: "alert"
      };
      return d ? D("div", re({
        class: ["v-skeleton-loader", {
          "v-skeleton-loader--boilerplate": e.boilerplate
        }, l.value, n.value, o.value],
        style: [t.value, s.value]
      }, f, i), [c.value]) : D(pe, null, [r.default?.()]);
    }), {};
  }
}), Qu = /* @__PURE__ */ Symbol.for("vuetify:v-stepper"), Wh = ee({
  color: String,
  disabled: {
    type: [Boolean, String],
    default: !1
  },
  prevText: {
    type: String,
    default: "$vuetify.stepper.prev"
  },
  nextText: {
    type: String,
    default: "$vuetify.stepper.next"
  }
}, "VStepperActions"), Gh = de()({
  name: "VStepperActions",
  props: Wh(),
  emits: {
    "click:prev": () => !0,
    "click:next": () => !0
  },
  setup(e, a) {
    let {
      emit: i,
      slots: r
    } = a;
    const {
      t: n
    } = nt();
    function t() {
      i("click:prev");
    }
    function s() {
      i("click:next");
    }
    return me(() => {
      const o = {
        onClick: t
      }, l = {
        onClick: s
      };
      return D("div", {
        class: "v-stepper-actions"
      }, [C(je, {
        defaults: {
          VBtn: {
            disabled: ["prev", !0].includes(e.disabled),
            text: n(e.prevText),
            variant: "text"
          }
        }
      }, {
        default: () => [r.prev?.({
          props: o
        }) ?? C(Te, o, null)]
      }), C(je, {
        defaults: {
          VBtn: {
            color: e.color,
            disabled: ["next", !0].includes(e.disabled),
            text: n(e.nextText),
            variant: "tonal"
          }
        }
      }, {
        default: () => [r.next?.({
          props: l
        }) ?? C(Te, l, null)]
      })]);
    }), {};
  }
}), Yh = Fn("v-stepper-header"), OC = ee({
  color: String,
  title: String,
  subtitle: String,
  complete: Boolean,
  completeIcon: {
    type: Pe,
    default: "$complete"
  },
  editable: Boolean,
  editIcon: {
    type: Pe,
    default: "$edit"
  },
  error: Boolean,
  errorIcon: {
    type: Pe,
    default: "$error"
  },
  icon: Pe,
  ripple: {
    type: [Boolean, Object],
    default: !0
  },
  rules: {
    type: Array,
    default: () => []
  }
}, "StepperItem"), EC = ee({
  ...OC(),
  ...Rr()
}, "VStepperItem"), Xh = de()({
  name: "VStepperItem",
  directives: {
    vRipple: At
  },
  props: EC(),
  emits: {
    "group:selected": (e) => !0
  },
  setup(e, a) {
    let {
      slots: i
    } = a;
    const r = jn(e, Qu, !0), n = I(() => r?.value.value ?? e.value), t = I(() => e.rules.every((f) => f() === !0)), s = I(() => !e.disabled && e.editable), o = I(() => !e.disabled && e.editable), l = I(() => e.error || !t.value), u = I(() => e.complete || e.rules.length > 0 && t.value), c = I(() => l.value ? e.errorIcon : u.value ? e.completeIcon : r.isSelected.value && e.editable ? e.editIcon : e.icon), d = I(() => ({
      canEdit: o.value,
      hasError: l.value,
      hasCompleted: u.value,
      title: e.title,
      subtitle: e.subtitle,
      step: n.value,
      value: e.value
    }));
    return me(() => {
      const f = (!r || r.isSelected.value || u.value || o.value) && !l.value && !e.disabled, v = !!(e.title != null || i.title), g = !!(e.subtitle != null || i.subtitle);
      function h() {
        r?.toggle();
      }
      return Je(D("button", {
        class: ue(["v-stepper-item", {
          "v-stepper-item--complete": u.value,
          "v-stepper-item--disabled": e.disabled,
          "v-stepper-item--error": l.value
        }, r?.selectedClass.value]),
        disabled: !e.editable,
        type: "button",
        onClick: h
      }, [s.value && yn(!0, "v-stepper-item"), C(Yt, {
        key: "stepper-avatar",
        class: "v-stepper-item__avatar",
        color: f ? e.color : void 0,
        size: 24
      }, {
        default: () => [i.icon?.(d.value) ?? (c.value ? C(xe, {
          icon: c.value
        }, null) : n.value)]
      }), D("div", {
        class: "v-stepper-item__content"
      }, [v && D("div", {
        key: "title",
        class: "v-stepper-item__title"
      }, [i.title?.(d.value) ?? e.title]), g && D("div", {
        key: "subtitle",
        class: "v-stepper-item__subtitle"
      }, [i.subtitle?.(d.value) ?? e.subtitle]), i.default?.(d.value)])]), [[At, e.editable && e.ripple, null]]);
    }), {};
  }
}), AC = ee({
  ...Le(zu(), ["continuous", "nextIcon", "prevIcon", "showArrows", "touch", "mandatory"])
}, "VStepperWindow"), Zh = de()({
  name: "VStepperWindow",
  props: AC(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, a) {
    let {
      slots: i
    } = a;
    const r = qe(Qu, null), n = $e(e, "modelValue"), t = I({
      get() {
        return n.value != null || !r ? n.value : r.items.value.find((s) => r.selected.value.includes(s.id))?.value;
      },
      set(s) {
        n.value = s;
      }
    });
    return me(() => {
      const s = Nn.filterProps(e);
      return C(Nn, re({
        _as: "VStepperWindow"
      }, s, {
        modelValue: t.value,
        "onUpdate:modelValue": (o) => t.value = o,
        class: ["v-stepper-window", e.class],
        style: e.style,
        mandatory: !1,
        touch: !1
      }), i);
    }), {};
  }
}), TC = ee({
  ...Bu()
}, "VStepperWindowItem"), Jh = de()({
  name: "VStepperWindowItem",
  props: TC(),
  setup(e, a) {
    let {
      slots: i
    } = a;
    return me(() => {
      const r = Ln.filterProps(e);
      return C(Ln, re({
        _as: "VStepperWindowItem"
      }, r, {
        class: ["v-stepper-window-item", e.class],
        style: e.style
      }), i);
    }), {};
  }
}), jC = ee({
  altLabels: Boolean,
  bgColor: String,
  completeIcon: Pe,
  editIcon: Pe,
  editable: Boolean,
  errorIcon: Pe,
  hideActions: Boolean,
  items: {
    type: Array,
    default: () => []
  },
  itemTitle: {
    type: [String, Array, Function],
    default: "title"
  },
  itemValue: {
    type: [String, Array, Function],
    default: "value"
  },
  itemProps: {
    type: [Boolean, String, Array, Function],
    default: "props"
  },
  nonLinear: Boolean,
  flat: Boolean,
  ...ap()
}, "Stepper"), DC = ee({
  ...jC(),
  ...Mr({
    mandatory: "force",
    selectedClass: "v-stepper-item--selected"
  }),
  ...Nu(),
  ...za(Wh(), ["prevText", "nextText"])
}, "VStepper"), MC = de()({
  name: "VStepper",
  props: DC(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, a) {
    let {
      slots: i
    } = a;
    const {
      items: r,
      next: n,
      prev: t,
      selected: s
    } = Hn(e, Qu), {
      displayClasses: o,
      mobile: l
    } = Dr(e), {
      completeIcon: u,
      editIcon: c,
      errorIcon: d,
      color: f,
      editable: v,
      prevText: g,
      nextText: h
    } = Gm(e), y = I(() => e.items.map((b, w) => {
      const k = It(b, e.itemTitle, b), S = It(b, e.itemValue, w + 1), _ = e.itemProps === !0 ? b : It(b, e.itemProps), P = {
        title: k,
        value: S,
        ..._
      };
      return {
        title: P.title,
        value: P.value,
        props: P,
        raw: b
      };
    })), m = I(() => r.value.findIndex((b) => s.value.includes(b.id))), p = I(() => e.disabled ? e.disabled : m.value === 0 ? "prev" : m.value === r.value.length - 1 ? "next" : !1);
    return da({
      VStepperItem: {
        editable: v,
        errorIcon: d,
        completeIcon: u,
        editIcon: c,
        prevText: g,
        nextText: h
      },
      VStepperActions: {
        color: f,
        disabled: p,
        prevText: g,
        nextText: h
      }
    }), me(() => {
      const b = pa.filterProps(e), w = !!(i.header || e.items.length), k = e.items.length > 0, S = !e.hideActions && !!(k || i.actions);
      return C(pa, re(b, {
        color: e.bgColor,
        class: ["v-stepper", {
          "v-stepper--alt-labels": e.altLabels,
          "v-stepper--flat": e.flat,
          "v-stepper--non-linear": e.nonLinear,
          "v-stepper--mobile": l.value
        }, o.value, e.class],
        style: e.style
      }), {
        default: () => [w && C(Yh, {
          key: "stepper-header"
        }, {
          default: () => [y.value.map((_, P) => {
            let {
              raw: M,
              ...q
            } = _;
            return D(pe, null, [!!P && C(ia, null, null), C(Xh, q.props, {
              default: i[`header-item.${q.value}`] ?? i.header,
              icon: i.icon,
              title: i.title,
              subtitle: i.subtitle
            })]);
          })]
        }), k && C(Zh, {
          key: "stepper-window"
        }, {
          default: () => [y.value.map((_) => C(Jh, {
            value: _.value
          }, {
            default: () => i[`item.${_.value}`]?.(_) ?? i.item?.(_)
          }))]
        }), i.default?.({
          prev: t,
          next: n
        }), S && (i.actions?.({
          next: n,
          prev: t
        }) ?? C(Gh, {
          key: "stepper-actions",
          "onClick:prev": t,
          "onClick:next": n
        }, i))]
      });
    }), {
      prev: t,
      next: n
    };
  }
}), _r = dt({
  props: {
    icon: {
      type: String,
      required: !0
    },
    avatarProps: {
      type: Object,
      required: !0
    }
  },
  setup(e) {
    const a = I(() => e.icon.startsWith("http://") || e.icon.startsWith("https://")), i = I(() => e.icon.startsWith("<?xml") || e.icon.startsWith("<svg"));
    return () => a.value ? Oe(Yt, e.avatarProps, () => Oe(Zs, { src: e.icon })) : i.value ? Oe("div", { innerHTML: e.icon.replace("<svg ", '<svg class="v-icon__svg" '), class: "v-icon" }) : Oe(xe, null, () => e.icon);
  }
}), RC = {
  __name: "select-item",
  props: {
    multiple: {
      type: Boolean,
      default: !1
    },
    itemProps: {
      type: Object,
      required: !0
    },
    item: {
      /** @type import('vue').PropType<import('@json-layout/vocabulary').SelectItem> */
      type: Object,
      required: !0
    },
    avatarProps: {
      type: Object,
      required: !0
    }
  },
  setup(e) {
    return (a, i) => (oe(), ye(Y(it), Gt(oa(e.itemProps)), Yo({ _: 2 }, [
      e.item.icon || e.multiple ? {
        name: "prepend",
        fn: le(({ isSelected: r }) => [
          e.multiple ? (oe(), ye(Y(Mn), {
            key: e.item.key,
            ripple: !1,
            tabindex: "-1",
            "model-value": r
          }, null, 8, ["model-value"])) : Ve("", !0),
          typeof e.item.icon == "string" ? (oe(), ye(_r, {
            key: 1,
            icon: e.item.icon,
            "avatar-props": e.avatarProps
          }, null, 8, ["icon", "avatar-props"])) : Ve("", !0)
        ]),
        key: "0"
      } : void 0
    ]), 1040));
  }
}, NC = {
  __name: "select-item-header",
  props: {
    item: {
      /** @type import('vue').PropType<import('@json-layout/vocabulary').SelectItemHeader> */
      type: Object,
      required: !0
    },
    avatarProps: {
      type: Object,
      required: !0
    }
  },
  setup(e) {
    return (a, i) => (oe(), ye(Y(kn), null, {
      default: le(() => [
        typeof e.item.icon == "string" ? (oe(), ye(_r, {
          key: 0,
          icon: e.item.icon,
          "avatar-props": e.avatarProps
        }, null, 8, ["icon", "avatar-props"])) : Ve("", !0),
        Fe(" " + Ue(e.item.title), 1)
      ]),
      _: 1
    }));
  }
}, LC = {
  __name: "select-selection",
  props: {
    multiple: {
      type: Boolean,
      default: !1
    },
    last: {
      type: Boolean,
      default: !1
    },
    item: {
      /** @type import('vue').PropType<import('@json-layout/vocabulary').SelectItem> */
      type: Object,
      required: !0
    },
    avatarProps: {
      type: Object,
      required: !0
    },
    cssPrefix: {
      type: String,
      required: !0
    }
  },
  setup(e) {
    return (a, i) => (oe(), De("span", {
      class: ue(e.cssPrefix + "__selection-text")
    }, [
      typeof e.item.icon == "string" ? (oe(), ye(_r, {
        key: 0,
        icon: e.item.icon,
        "avatar-props": e.avatarProps
      }, null, 8, ["icon", "avatar-props"])) : Ve("", !0),
      Fe(" " + Ue(e.item.title ?? e.item.key ?? e.item.value) + " ", 1),
      e.multiple && !e.last ? (oe(), De("span", {
        key: 1,
        class: ue(e.cssPrefix + "__selection-comma")
      }, ",", 2)) : Ve("", !0)
    ], 2));
  }
};
function ec(e, a, i, r) {
  const n = I(() => e.value.layout), { inputProps: t, options: s, skeleton: o, localData: l, compSlots: u } = mt(e, a, { layoutPropsMap: ["multiple", "placeholder"], bindData: !1 }), c = Br(e, a), d = gn(e.value.fullKey), f = I(() => {
    const g = { ...t.value };
    return s.value.readOnly ? g.menuProps = { modelValue: !1 } : g.menuProps = { zIndex: d }, g.clearable = g.clearable ?? !o.value.required, g.valueComparator = (h, y) => {
      const m = typeof h == "object" ? a.prepareSelectItem(e.value, h).key : h, p = typeof y == "object" ? a.prepareSelectItem(e.value, y).key : y;
      return m === p;
    }, g["onUpdate:modelValue"] = (h) => {
      if (Array.isArray(h) && Array.isArray(e.value.data))
        for (let m = 0; m < e.value.data.length; m++)
          typeof e.value.data[m] == "object" && typeof h[m] == "string" && (h[m] = e.value.data[m]);
      const y = Array.isArray(h) && e.value.layout.separator ? h.join(
        /** @type {string} */
        e.value.layout.separator
      ) : h;
      return l.value = y, a.input(e.value, y);
    }, g.onBlur = () => a.blur(e.value), g;
  }), v = I(() => {
    const g = { ...u.value };
    return g.item || (g.item = (h) => h.item.raw.header ? Oe(NC, {
      item: h.item.raw,
      avatarProps: i
    }) : Oe(RC, {
      multiple: n.value.multiple,
      itemProps: h.props,
      item: h.item.raw,
      avatarProps: i
    })), g.selection || (g.selection = (h) => Oe(LC, {
      multiple: n.value.multiple,
      last: n.value.multiple && h.index === e.value.data.length - 1,
      item: c.prepareSelectedItem(h.item.raw, h.item.value),
      avatarProps: i,
      cssPrefix: r
    })), g;
  });
  return { localData: l, inputProps: t, selectProps: f, compSlots: u, selectSlots: v, getItems: c };
}
const qC = dt({
  props: {
    modelValue: {
      /** @type import('vue').PropType<import('../../types.js').VjsfSelectNode> */
      type: Object,
      required: !0
    },
    statefulLayout: {
      /** @type import('vue').PropType<import('../../types.js').VjsfStatefulLayout> */
      type: Object,
      required: !0
    }
  },
  setup(e) {
    Ge({}, "VjsfSelect");
    const a = vt("VjsfSelectItem-VAvatar", { rounded: !1, size: "small" }), { getItems: i, selectProps: r, selectSlots: n, localData: t } = ec(W(e, "modelValue"), e.statefulLayout, a.value, "v-select"), s = I(() => {
      const o = { ...r.value };
      return o.loading = i.loading.value, o.items = i.items.value, o.modelValue = t.value, o;
    });
    return () => Oe(Ju, s.value, n.value);
  }
}), zC = dt({
  props: {
    modelValue: {
      /** @type import('vue').PropType<import('../../types.js').VjsfSelectNode> */
      type: Object,
      required: !0
    },
    statefulLayout: {
      /** @type import('vue').PropType<import('../../types.js').VjsfStatefulLayout> */
      type: Object,
      required: !0
    }
  },
  setup(e) {
    Ge({}, "VjsfAutocomplete");
    const a = vt("VjsfSelectItem-VAvatar", { rounded: !1, size: "small" }), { getItems: i, selectProps: r, selectSlots: n, localData: t } = ec(W(e, "modelValue"), e.statefulLayout, a.value, "v-autocomplete"), s = I(() => {
      const o = { ...r.value };
      return o.noFilter = !0, o["onUpdate:search"] = (l) => {
        i.search.value = l;
      }, o.items = i.items.value, o.loading = i.loading.value, o.modelValue = t.value, o;
    });
    return () => Oe(Nh, s.value, n.value);
  }
}), BC = dt({
  props: {
    modelValue: {
      /** @type import('vue').PropType<import('../../types.js').VjsfRadioGroupNode> */
      type: Object,
      required: !0
    },
    statefulLayout: {
      /** @type import('vue').PropType<import('../../types.js').VjsfStatefulLayout> */
      type: Object,
      required: !0
    }
  },
  setup(e) {
    Ge({}, "VjsfRadioGroup");
    const a = W(e, "modelValue"), i = Br(a, e.statefulLayout), { inputProps: r, compSlots: n, localData: t } = mt(a, e.statefulLayout), s = I(() => {
      const l = { ...r.value };
      return l.modelValue = t.value, l;
    }), o = I(() => {
      const l = { ...n.value }, u = [];
      if (i.loading.value)
        u.push(Oe(Uh, { type: "chip" }));
      else
        for (const c of i.items.value)
          u.push(Oe(_C, { label: c.title, value: c.value }));
      return l.default = () => u, l;
    });
    return () => Oe(CC, s.value, o.value);
  }
}), Qh = dt({
  props: {
    modelValue: {
      /** @type import('vue').PropType<import('../../types.js').VjsfCheckboxGroupNode> */
      type: Object,
      required: !0
    },
    statefulLayout: {
      /** @type import('vue').PropType<import('../../types.js').VjsfStatefulLayout> */
      type: Object,
      required: !0
    },
    type: {
      type: String,
      required: !0
    }
  },
  setup(e) {
    const a = W(e, "modelValue"), i = Br(a, e.statefulLayout), { inputProps: r, compSlots: n, localData: t, layout: s } = mt(a, e.statefulLayout, { bindData: !1 }), o = I(() => {
      const u = { ...r.value };
      return u.class.push("v-radio-group"), u.class.push("vjsf-selection-group"), u;
    }), l = I(() => {
      const u = { ...n.value };
      return u.default || (u.default = () => {
        const c = [Oe(qr, { text: o.value.label })];
        if (i.loading.value)
          c.push(Oe(Uh, { type: "chip" }));
        else {
          const d = [];
          for (const f of i.items.value) {
            let v = !1;
            s.value.multiple ? v = t.value?.includes(f.value) : v = t.value === f.value, d.push(Oe(
              /** @type {import('vue').Component} */
              e.type === "switch" ? Xp : Yp,
              {
                label: f.title,
                hideDetails: !0,
                key: f.key,
                modelValue: v,
                onClick: () => {
                  let g;
                  s.value.multiple ? (g = e.modelValue.data ? [...e.modelValue.data] : [], g.includes(f.value) ? g = g.filter((h) => h !== f.value) : g.push(f.value)) : e.modelValue.data === f.value ? g = void 0 : g = f.value, e.statefulLayout.input(e.modelValue, g);
                }
              }
            ));
          }
          c.push(Oe("div", { class: "v-selection-control-group" }, d));
        }
        return c;
      }), u;
    });
    return () => Oe(Tt, o.value, l.value);
  }
}), FC = dt({
  props: {
    modelValue: {
      /** @type import('vue').PropType<import('../../types.js').VjsfCheckboxGroupNode> */
      type: Object,
      required: !0
    },
    statefulLayout: {
      /** @type import('vue').PropType<import('../../types.js').VjsfStatefulLayout> */
      type: Object,
      required: !0
    }
  },
  setup(e) {
    return Ge({}, "VjsfCheckboxGroup"), () => Oe(Qh, {
      modelValue: e.modelValue,
      statefulLayout: e.statefulLayout,
      type: "checkbox"
    });
  }
}), KC = dt({
  props: {
    modelValue: {
      /** @type import('vue').PropType<import('../../types.js').VjsfCheckboxGroupNode> */
      type: Object,
      required: !0
    },
    statefulLayout: {
      /** @type import('vue').PropType<import('../../types.js').VjsfStatefulLayout> */
      type: Object,
      required: !0
    }
  },
  setup(e) {
    return Ge({}, "VjsfSwitchGroup"), () => Oe(Qh, {
      modelValue: e.modelValue,
      statefulLayout: e.statefulLayout,
      type: "switch"
    });
  }
}), HC = {
  __name: "one-of-select",
  props: {
    modelValue: {
      /** @type import('vue').PropType<import('../../types.js').VjsfOneOfSelectNode> */
      type: Object,
      required: !0
    },
    statefulLayout: {
      /** @type import('vue').PropType<import('../../types.js').VjsfStatefulLayout> */
      type: Object,
      required: !0
    }
  },
  setup(e) {
    Ge({}, "VjsfOneOfSelect");
    const a = vt("VjsfOneOfSelect-VAvatar", { rounded: !1, size: "small" }), i = e, { inputProps: r, localData: n, skeleton: t, children: s } = mt(
      W(i, "modelValue"),
      i.statefulLayout,
      { bindData: !1 }
    ), o = gn(i.modelValue.fullKey), l = ie(void 0);
    ce(() => s.value?.[0]?.key, () => {
      i.modelValue.children?.length === 1 ? typeof i.modelValue.children[0].key == "number" && (l.value = t.value.childrenTrees?.[i.modelValue.children[0].key]) : l.value = void 0;
    }, { immediate: !0 });
    const u = (d) => {
      t.value.childrenTrees && i.statefulLayout.activateItem(i.modelValue, t.value.childrenTrees.indexOf(d));
    }, c = I(() => {
      const d = { ...r.value };
      d["onUpdate:modelValue"] = u, i.modelValue.options.readOnly || (d.menuProps = { zIndex: o });
      const f = [];
      for (const v of i.modelValue.layout.oneOfItems)
        if (ig(v))
          f.push(v);
        else if (sg(v)) {
          const g = (t.value.childrenTrees || [])[v.key], h = i.statefulLayout.compiledLayout.skeletonTrees[g], y = i.statefulLayout.compiledLayout.normalizedLayouts[h.root];
          (!eg(y) || !y.if || i.statefulLayout.evalNodeExpression(i.modelValue, y.if, n.value)) && f.push({ ...v, value: h });
        }
      return d.items = f, d.itemValue = (v) => v.value?.root, d;
    });
    return (d, f) => (oe(), ye(Y(sa), null, {
      default: le(() => [
        e.modelValue.skeleton.childrenTrees ? (oe(), ye(Y(sp), {
          key: 0,
          cols: "12"
        }, {
          default: le(() => [
            C(Y(Ju), re(c.value, { "model-value": l.value }), {
              item: le((v) => [
                v.item.raw.header ? (oe(), ye(Y(kn), { key: 0 }, {
                  default: le(() => [
                    typeof v.item.raw.icon == "string" ? (oe(), ye(_r, {
                      key: 0,
                      icon: v.item.raw.icon,
                      "avatar-props": Y(a)
                    }, null, 8, ["icon", "avatar-props"])) : Ve("", !0),
                    Fe(" " + Ue(v.item.raw.title), 1)
                  ]),
                  _: 2
                }, 1024)) : (oe(), ye(Y(it), Gt(re({ key: 1 }, v.props)), Yo({ _: 2 }, [
                  v.item.raw.icon ? {
                    name: "prepend",
                    fn: le(() => [
                      typeof v.item.raw.icon == "string" ? (oe(), ye(_r, {
                        key: 0,
                        icon: v.item.raw.icon,
                        "avatar-props": Y(a)
                      }, null, 8, ["icon", "avatar-props"])) : Ve("", !0)
                    ]),
                    key: "0"
                  } : void 0
                ]), 1040))
              ]),
              _: 1
            }, 16, ["model-value"])
          ]),
          _: 1
        })) : Ve("", !0),
        e.modelValue.children?.[0] ? (oe(!0), De(pe, { key: 1 }, pt(Y(Ea)(e.modelValue.children?.[0]) ? e.modelValue.children?.[0].children : e.modelValue.children, (v) => (oe(), ye(la, {
          key: v.fullKey,
          "model-value": (
            /** @type import('../../types.js').VjsfNode */
            v
          ),
          "stateful-layout": e.statefulLayout
        }, null, 8, ["model-value", "stateful-layout"]))), 128)) : Ve("", !0)
      ]),
      _: 1
    }));
  }
}, UC = ["innerHTML"], Qs = {
  __name: "child-subtitle",
  props: {
    modelValue: {
      /** @type import('vue').PropType<import('@json-layout/core').StateNode> */
      type: Object,
      required: !0
    }
  },
  setup(e) {
    const a = I(() => e.modelValue.options.density === "default" ? "mt-1 mb-5" : e.modelValue.options.density === "comfortable" ? "mb-4" : "mb-3");
    return (i, r) => Y(Ea)(e.modelValue) && e.modelValue.layout.subtitle ? (oe(), De("p", {
      key: 0,
      class: ue(`text-subtitle ${a.value}`),
      innerHTML: e.modelValue.layout.subtitle
    }, null, 10, UC)) : Ve("", !0);
  }
}, WC = {
  __name: "tabs",
  props: {
    modelValue: {
      /** @type import('vue').PropType<import('../../types.js').VjsfTabsNode> */
      type: Object,
      required: !0
    },
    statefulLayout: {
      /** @type import('vue').PropType<import('../../types.js').VjsfStatefulLayout> */
      type: Object,
      required: !0
    }
  },
  setup(e) {
    Ge({}, "VjsfTabs");
    const a = vt("VjsfTabs-VSheet", { border: !0 }), i = I(() => ({
      ...e.modelValue.props,
      direction: (
        /** @type {'horizontal'} */
        "horizontal"
      )
    })), r = ie(0);
    return (n, t) => (oe(), De(pe, null, [
      C(Yn, { node: e.modelValue }, null, 8, ["node"]),
      C(Y(pa), Gt(oa(Y(a))), {
        default: le(() => [
          C(Y(Ku), re({
            modelValue: r.value,
            "onUpdate:modelValue": t[0] || (t[0] = (s) => r.value = s)
          }, i.value), {
            default: le(() => [
              (oe(!0), De(pe, null, pt(e.modelValue.children, (s, o) => (oe(), ye(Y(kr), {
                key: s.key,
                value: o,
                color: s.validated && (s.error || s.childError) ? "error" : void 0
              }, {
                default: le(() => [
                  s.validated && (s.error || s.childError) ? (oe(), ye(Y(xe), {
                    key: 0,
                    color: "error",
                    icon: e.statefulLayout.options.icons.alert
                  }, null, 8, ["icon"])) : Ve("", !0),
                  Fe(" " + Ue(s.layout.title ?? s.layout.label), 1)
                ]),
                _: 2
              }, 1032, ["value", "color"]))), 128))
            ]),
            _: 1
          }, 16, ["modelValue"]),
          C(Y(Nn), {
            modelValue: r.value,
            "onUpdate:modelValue": t[1] || (t[1] = (s) => r.value = s)
          }, {
            default: le(() => [
              (oe(!0), De(pe, null, pt(e.modelValue.children, (s, o) => (oe(), ye(Y(Ln), {
                key: s.key,
                value: o
              }, {
                default: le(() => [
                  C(Y(jr), { fluid: "" }, {
                    default: le(() => [
                      C(Qs, { "model-value": s }, null, 8, ["model-value"]),
                      C(Y(sa), {
                        dense: e.modelValue.options?.density === "compact" || e.modelValue.options?.density === "comfortable"
                      }, {
                        default: le(() => [
                          (oe(!0), De(pe, null, pt(Y(Ea)(s) ? s.children : [s], (l) => (oe(), ye(la, {
                            key: l.fullKey,
                            "model-value": (
                              /** @type import('../../types.js').VjsfNode */
                              l
                            ),
                            "stateful-layout": e.statefulLayout
                          }, null, 8, ["model-value", "stateful-layout"]))), 128))
                        ]),
                        _: 2
                      }, 1032, ["dense"])
                    ]),
                    _: 2
                  }, 1024)
                ]),
                _: 2
              }, 1032, ["value"]))), 128))
            ]),
            _: 1
          }, 8, ["modelValue"])
        ]),
        _: 1
      }, 16)
    ], 64));
  }
}, GC = { class: "d-flex flex-row" }, YC = {
  __name: "vertical-tabs",
  props: {
    modelValue: {
      /** @type import('vue').PropType<import('../../types.js').VjsfVerticalTabsNode> */
      type: Object,
      required: !0
    },
    statefulLayout: {
      /** @type import('vue').PropType<import('../../types.js').VjsfStatefulLayout> */
      type: Object,
      required: !0
    }
  },
  setup(e) {
    Ge({}, "VjsfVerticalTabs");
    const a = vt("VjsfVerticalTabs-VSheet", { border: !0 }), i = I(() => ({
      ...e.modelValue.props,
      direction: (
        /** @type {'vertical'} */
        "vertical"
      )
    })), r = ie(0);
    return (n, t) => (oe(), De(pe, null, [
      C(Yn, { node: e.modelValue }, null, 8, ["node"]),
      C(Y(pa), Gt(oa(Y(a))), {
        default: le(() => [
          D("div", GC, [
            C(Y(Ku), re({
              modelValue: r.value,
              "onUpdate:modelValue": t[0] || (t[0] = (s) => r.value = s)
            }, i.value), {
              default: le(() => [
                (oe(!0), De(pe, null, pt(e.modelValue.children, (s, o) => (oe(), ye(Y(kr), {
                  key: s.key,
                  value: o,
                  color: s.validated && (s.error || s.childError) ? "error" : void 0
                }, {
                  default: le(() => [
                    s.validated && (s.error || s.childError) ? (oe(), ye(Y(xe), {
                      key: 0,
                      color: "error",
                      icon: e.statefulLayout.options.icons.alert
                    }, null, 8, ["icon"])) : Ve("", !0),
                    Fe(" " + Ue(s.layout.title ?? s.layout.label), 1)
                  ]),
                  _: 2
                }, 1032, ["value", "color"]))), 128))
              ]),
              _: 1
            }, 16, ["modelValue"]),
            C(Y(Nn), {
              modelValue: r.value,
              "onUpdate:modelValue": t[1] || (t[1] = (s) => r.value = s),
              class: "flex-fill"
            }, {
              default: le(() => [
                (oe(!0), De(pe, null, pt(e.modelValue.children, (s, o) => (oe(), ye(Y(Ln), {
                  key: s.key,
                  value: o
                }, {
                  default: le(() => [
                    C(Y(jr), { fluid: "" }, {
                      default: le(() => [
                        C(Qs, { "model-value": s }, null, 8, ["model-value"]),
                        C(Y(sa), {
                          dense: e.modelValue.options?.density === "compact" || e.modelValue.options?.density === "comfortable"
                        }, {
                          default: le(() => [
                            (oe(!0), De(pe, null, pt(Y(Ea)(s) ? s.children : [s], (l) => (oe(), ye(la, {
                              key: l.fullKey,
                              "model-value": (
                                /** @type import('../../types.js').VjsfNode */
                                l
                              ),
                              "stateful-layout": e.statefulLayout
                            }, null, 8, ["model-value", "stateful-layout"]))), 128))
                          ]),
                          _: 2
                        }, 1032, ["dense"])
                      ]),
                      _: 2
                    }, 1024)
                  ]),
                  _: 2
                }, 1032, ["value"]))), 128))
              ]),
              _: 1
            }, 8, ["modelValue"])
          ])
        ]),
        _: 1
      }, 16)
    ], 64));
  }
}, XC = dt({
  props: {
    modelValue: {
      /** @type import('vue').PropType<import('../../types.js').VjsfComboboxNode> */
      type: Object,
      required: !0
    },
    statefulLayout: {
      /** @type import('vue').PropType<import('../../types.js').VjsfStatefulLayout> */
      type: Object,
      required: !0
    }
  },
  setup(e) {
    Ge({}, "VjsfCombobox");
    const a = W(e, "modelValue"), i = Br(a, e.statefulLayout), { inputProps: r, compSlots: n, localData: t, layout: s, options: o } = mt(a, e.statefulLayout), l = gn(e.modelValue.fullKey), u = I(() => {
      const c = { ...r.value };
      return c.returnObject = !1, o.value.readOnly ? c.menuProps = { modelValue: !1 } : c.menuProps = { zIndex: l }, i.hasItems.value && (c.items = i.items.value, c.loading = i.loading.value), s.value.multiple && (c.multiple = !0, c.chips = !0, c.closableChips = !0), c;
    });
    return () => Oe(qh, { ...u.value, modelValue: t.value }, n.value);
  }
}), ZC = dt({
  props: {
    modelValue: {
      /** @type import('vue').PropType<import('../../types.js').VjsfComboboxNode> */
      type: Object,
      required: !0
    },
    statefulLayout: {
      /** @type import('vue').PropType<import('../../types.js').VjsfStatefulLayout> */
      type: Object,
      required: !0
    }
  },
  setup(e) {
    Ge({}, "VjsfCombobox");
    const a = W(e, "modelValue"), i = Br(a, e.statefulLayout), { inputProps: r, compSlots: n, localData: t, layout: s, options: o } = mt(a, e.statefulLayout, { bindData: !1, layoutPropsMap: ["step", "min", "max"] }), l = gn(e.modelValue.fullKey), u = I(() => {
      const c = { ...r.value };
      return c.type = "number", c.returnObject = !1, o.value.readOnly ? c.menuProps = { modelValue: !1 } : c.menuProps = { zIndex: l }, i.hasItems.value && (c.items = i.items.value, c.loading = i.loading.value), s.value.multiple && (c.multiple = !0, c.chips = !0, c.closableChips = !0), c["onUpdate:modelValue"] = (d) => e.statefulLayout.input(e.modelValue, d && (Array.isArray(d) ? d.map(Number) : Number(d))), c;
    });
    return () => Oe(qh, { ...u.value, modelValue: t.value }, n.value);
  }
}), JC = {
  __name: "expansion-panels",
  props: {
    modelValue: {
      /** @type import('vue').PropType<import('../../types.js').VjsfExpansionPanelsNode> */
      type: Object,
      required: !0
    },
    statefulLayout: {
      /** @type import('vue').PropType<import('../../types.js').VjsfStatefulLayout> */
      type: Object,
      required: !0
    }
  },
  setup(e) {
    Ge({}, "VjsfExpansionPanels");
    const a = e, { compProps: i } = mt(W(a, "modelValue"), a.statefulLayout);
    return (r, n) => (oe(), De(pe, null, [
      C(Yn, { node: e.modelValue }, null, 8, ["node"]),
      C(Y(vC), Gt(oa(Y(i))), {
        default: le(() => [
          (oe(!0), De(pe, null, pt(e.modelValue.children, (t, s) => (oe(), ye(Y(dC), {
            key: t.key,
            value: s
          }, {
            default: le(() => [
              C(Y(Ko), null, {
                default: le(() => [
                  t.validated && (t.error || t.childError) ? (oe(), ye(Y(xe), {
                    key: 0,
                    color: "error",
                    class: "mr-2",
                    icon: e.statefulLayout.options.icons.alert
                  }, null, 8, ["icon"])) : Ve("", !0),
                  Fe(" " + Ue(t.layout.title ?? t.layout.label), 1)
                ]),
                _: 2
              }, 1024),
              C(Y(Fo), null, {
                default: le(() => [
                  C(Y(jr), { fluid: "" }, {
                    default: le(() => [
                      C(Qs, { "model-value": t }, null, 8, ["model-value"]),
                      C(Y(sa), {
                        dense: e.modelValue.options?.density === "compact" || e.modelValue.options?.density === "comfortable"
                      }, {
                        default: le(() => [
                          (oe(!0), De(pe, null, pt(Y(Ea)(t) ? t.children : [t], (o) => (oe(), ye(la, {
                            key: o.fullKey,
                            "model-value": (
                              /** @type import('../../types.js').VjsfNode */
                              o
                            ),
                            "stateful-layout": e.statefulLayout
                          }, null, 8, ["model-value", "stateful-layout"]))), 128))
                        ]),
                        _: 2
                      }, 1032, ["dense"])
                    ]),
                    _: 2
                  }, 1024)
                ]),
                _: 2
              }, 1024)
            ]),
            _: 2
          }, 1032, ["value"]))), 128))
        ]),
        _: 1
      }, 16)
    ], 64));
  }
}, QC = {
  __name: "stepper",
  props: {
    modelValue: {
      /** @type import('vue').PropType<import('../../types.js').VjsfStepperNode> */
      type: Object,
      required: !0
    },
    statefulLayout: {
      /** @type import('vue').PropType<import('../../types.js').VjsfStatefulLayout> */
      type: Object,
      required: !0
    }
  },
  setup(e) {
    Ge({}, "VjsfStepper");
    const a = e, i = I(() => a.modelValue.props), r = ie(0), n = I(() => {
      const s = a.modelValue.children.findIndex((o) => o.validated && !!(o.error || o.childError));
      return s === -1 ? a.modelValue.children.length : s;
    }), t = () => {
      const s = a.modelValue.children[r.value];
      a.statefulLayout.validateNodeRecurse(s), s.error || s.childError || r.value++;
    };
    return (s, o) => (oe(), De(pe, null, [
      C(Yn, { node: e.modelValue }, null, 8, ["node"]),
      C(Y(MC), re({
        modelValue: r.value,
        "onUpdate:modelValue": o[1] || (o[1] = (l) => r.value = l)
      }, i.value), {
        default: le(() => [
          C(Y(Yh), null, {
            default: le(() => [
              (oe(!0), De(pe, null, pt(e.modelValue.children, (l, u) => (oe(), De(pe, {
                key: l.key
              }, [
                C(Y(Xh), {
                  value: u,
                  title: (
                    /** @type {string | undefined} */
                    l.layout.title ?? l.layout.label
                  ),
                  error: l.validated && !!(l.error || l.childError),
                  complete: l.validated && !(l.error || l.childError),
                  editable: u <= n.value
                }, null, 8, ["value", "title", "error", "complete", "editable"]),
                C(Y(ia))
              ], 64))), 128))
            ]),
            _: 1
          }),
          C(Y(Zh), null, {
            default: le(() => [
              (oe(!0), De(pe, null, pt(e.modelValue.children, (l) => (oe(), ye(Y(Jh), {
                key: l.key
              }, {
                default: le(() => [
                  C(Y(jr), {
                    fluid: "",
                    class: "pa-0"
                  }, {
                    default: le(() => [
                      C(Qs, { "model-value": l }, null, 8, ["model-value"]),
                      C(Y(sa), {
                        dense: e.modelValue.options?.density === "compact" || e.modelValue.options?.density === "comfortable"
                      }, {
                        default: le(() => [
                          (oe(!0), De(pe, null, pt(Y(Ea)(l) ? l.children : [l], (u) => (oe(), ye(la, {
                            key: u.fullKey,
                            "model-value": (
                              /** @type import('../../types.js').VjsfNode */
                              u
                            ),
                            "stateful-layout": e.statefulLayout
                          }, null, 8, ["model-value", "stateful-layout"]))), 128))
                        ]),
                        _: 2
                      }, 1032, ["dense"])
                    ]),
                    _: 2
                  }, 1024)
                ]),
                _: 2
              }, 1024))), 128))
            ]),
            _: 1
          }),
          C(Y(Gh), null, {
            prev: le(() => [
              r.value > 0 ? (oe(), ye(Y(Te), {
                key: 0,
                variant: "text",
                onClick: o[0] || (o[0] = (l) => r.value--)
              }, {
                default: le(() => [...o[2] || (o[2] = [
                  Fe(" Back ", -1)
                ])]),
                _: 1
              })) : Ve("", !0)
            ]),
            next: le(() => [
              C(Y(yr)),
              r.value < e.modelValue.children.length - 1 ? (oe(), ye(Y(Te), {
                key: 0,
                variant: "flat",
                color: "primary",
                onClick: t
              }, {
                default: le(() => [...o[3] || (o[3] = [
                  Fe(" Next ", -1)
                ])]),
                _: 1
              })) : Ve("", !0)
            ]),
            _: 1
          })
        ]),
        _: 1
      }, 16, ["modelValue"])
    ], 64));
  }
}, ex = dt({
  props: {
    modelValue: {
      type: String,
      required: !0
    },
    listNode: {
      /** @type import('vue').PropType<import('../../types.js').VjsfListNode> */
      type: Object,
      required: !0
    },
    statefulLayout: {
      /** @type import('vue').PropType<import('../../types.js').VjsfStatefulLayout> */
      type: Object,
      required: !0
    },
    rules: {
      /** @type import('vue').PropType<((v: string) => boolean)[]> */
      type: Array,
      required: !0
    }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: a }) {
    Ge({}, "VjsfListSelectKey");
    const i = vt("VjsfIndexedList-VSelect", { variant: "outlined", class: "mt-2" }), r = vt("VjsfSelectItem-VAvatar", { rounded: !1, size: "small" }), { getItems: n, selectProps: t, selectSlots: s } = ec(W(e, "listNode"), e.statefulLayout, r.value, "v-select"), o = I(() => {
      const c = { ...t.value };
      return delete c.hint, c.label = e.listNode.messages.addItem, c;
    }), l = I(() => {
      const c = jo([i.value, o.value]);
      return c.loading = n.loading.value, c.items = n.items.value, delete c.clearable, delete c.onBlur, c.rules = e.rules, c.active = !1, e.modelValue ? c.modelValue = e.modelValue : delete c.modelValue, c["onUpdate:modelValue"] = (d) => {
        d && a("update:modelValue", d);
      }, c;
    }), u = I(() => {
      const c = { ...s.value };
      return delete c.selection, c;
    });
    return () => Oe(n.items.value.length > 20 ? Nh : Ju, l.value, u.value);
  }
});
function Wm(e, a, i) {
  return a === i || a === -1 || i === -1 ? e : !Array.isArray(e) && typeof e == "object" ? ey(e, a, i) : tc(e, a, i);
}
function tc(e, a, i) {
  if (a === i || a === -1 || i === -1) return e;
  if (!Array.isArray(e) && typeof e == "object") return ey(e, a, i);
  const r = [...e], n = r[a];
  return r.splice(a, 1), r.splice(i, 0, n), r;
}
function ey(e, a, i) {
  if (a === i || a === -1 || i === -1) return e;
  const r = (
    /** @type {string[] } */
    tc(Object.keys(e), a, i)
  ), n = {};
  for (const t of r)
    n[t] = e[t];
  return n;
}
function tx(e, a) {
  const i = I(() => !(!("draggable" in document.createElement("div")) || window.matchMedia("(pointer: coarse)").matches)), r = fe(e), n = ie(-1), t = ie(-1), s = ie(-1);
  return n.value = 1, {
    activeDnd: i,
    sortableArray: r,
    hovered: n,
    draggable: t,
    dragging: s,
    itemBind: (u, c) => ({
      ...c,
      // hover the item
      onMouseenter: () => {
        n.value = u;
      },
      onMouseleave: () => {
        n.value = -1;
      },
      // drag the item
      onDragstart: () => {
        s.value = u;
      },
      onDragover: () => {
        r.value = tc(r.value, s.value, u), s.value = u;
      },
      onDragend: () => {
        n.value = u, s.value = -1, a();
      }
    }),
    handleBind: (u) => ({
      // hover the handle
      onMouseover() {
        t.value = u;
      },
      onMouseout() {
        t.value = -1;
      }
    })
  };
}
const ax = { class: "vjsf-list-item-actions-wrapper" }, nx = {
  __name: "list",
  props: {
    modelValue: {
      /** @type import('vue').PropType<import('../../types.js').VjsfListNode> */
      type: Object,
      required: !0
    },
    statefulLayout: {
      /** @type import('vue').PropType<import('../../types.js').VjsfStatefulLayout> */
      type: Object,
      required: !0
    }
  },
  setup(e) {
    Ge({}, "VjsfList");
    const a = vt("VjsfList-VCard", { border: !0, flat: !0, tile: !0 }), i = vt("VjsfList-VList", { class: "py-0" }), r = vt("VjsfList-VListItem", { variant: "flat", class: "pa-1" }), n = vt("VjsfList-Edit-VDialog", { persistent: !0 }), t = vt("VjsfList-Edit-VDialog-VSheet", {}), s = vt("VjsfList-Edit-VMenu", {}), o = qs(), l = e, u = I(() => l.modelValue.options), c = I(() => l.modelValue.layout), d = I(() => l.modelValue.children), f = () => c.value.listEditMode === "dialog" || c.value.listEditMode === "menu" ? d.value.filter((Q) => Q.options.summary) : d.value, { activeDnd: v, sortableArray: g, draggable: h, hovered: y, dragging: m, itemBind: p, handleBind: b } = tx(f(), () => {
      const Q = c.value.indexed ? g.value.reduce(
        (te, N) => (te[N.key] = N.data, te),
        /** @type {Record<string, any>} */
        {}
      ) : g.value.map((te) => te.data);
      l.statefulLayout.input(l.modelValue, Q), w.value = -1;
    });
    ce(d, () => {
      g.value = f();
    });
    const w = ie(-1), k = (Q) => {
      w.value = Q, P.value = -1;
    }, S = gn(l.modelValue.fullKey), _ = I(() => l.statefulLayout.activatedItems[l.modelValue.fullKey]), P = ie(-1), M = (Q, te) => {
      P.value = te ? Q : -1, T.value = !1;
    }, q = I(() => c.value.listActions.includes("edit") && c.value.listEditMode !== "inline" && _.value !== void 0 ? _.value : m.value !== -1 ? -1 : P.value !== -1 ? P.value : w.value !== -1 ? w.value : y.value), K = I(() => u.value.density === "default" ? "comfortable" : u.value.density), j = I(() => {
      const Q = l.modelValue.layout.itemTitle;
      return Q ? g.value.map((te) => l.statefulLayout.evalNodeExpression(l.modelValue, Q, te.data)) : null;
    }), H = I(() => {
      const Q = l.modelValue.layout.itemSubtitle;
      return Q ? g.value.map((te) => l.statefulLayout.evalNodeExpression(l.modelValue, Q, te.data)) : null;
    }), B = (Q) => {
      c.value.listEditMode === "inline-single" || c.value.listEditMode === "dialog" ? l.statefulLayout.activateItem(l.modelValue, Q) : l.statefulLayout.focusNode(l.modelValue.fullKey + "/" + Q);
    }, L = () => {
      const Q = (l.modelValue.data ?? []).concat([void 0]);
      l.statefulLayout.input(l.modelValue, Q), B(Q.length - 1);
    }, O = ie(""), U = ie(null), Z = () => {
      if (!O.value || !U.value || !U.value.isValid) return;
      const Q = { ...l.modelValue.data ?? {}, [O.value]: void 0 };
      l.statefulLayout.input(l.modelValue, Q), B(O.value), O.value = "", U.value?.reset();
    }, J = (Q) => {
      u.value.confirmDeleteItem ? T.value = !0 : A(Q);
    }, A = (Q) => {
      if (c.value.indexed) {
        const te = (
          /** @type {Record<string, any>} */
          l.modelValue.data
        ), N = Object.keys(l.modelValue.data), R = {};
        for (let G = 0; G < N.length; G++)
          G !== Q && (R[N[G]] = te[N[G]]);
        l.statefulLayout.input(l.modelValue, R);
      } else {
        const te = [...l.modelValue.data.slice(0, Q), ...l.modelValue.data.slice(Q + 1)];
        l.statefulLayout.input(l.modelValue, te);
      }
      P.value = -1;
    }, T = ie(!1), E = (Q, te) => {
      const N = l.modelValue.layout.itemCopy ? l.statefulLayout.evalNodeExpression(l.modelValue, l.modelValue.layout.itemCopy, na(Q.data)) : na(Q.data), R = [...l.modelValue.data.slice(0, te + 1), N, ...l.modelValue.data.slice(te + 1)];
      l.statefulLayout.input(l.modelValue, R), B(te + 1), P.value = -1;
    }, x = G$(() => l.modelValue.layout.clipboardKey ?? l.modelValue.fullKey), $ = (Q) => {
      x.value = Q.data, P.value = -1;
    }, V = (Q) => {
      const te = x.value;
      if (te === null) throw new Error("attempt to paste but clipboard is empty");
      const N = l.modelValue.layout.itemCopy ? l.statefulLayout.evalNodeExpression(l.modelValue, l.modelValue.layout.itemCopy, na(te)) : na(te), R = [...l.modelValue.data ?? [], N];
      l.statefulLayout.input(l.modelValue, R), B(R.length - 1);
    }, F = I(() => (Q, te) => _.value === te ? o.current.value.colors.primary : Q.validated && (Q.error || Q.childError) ? o.current.value.colors.error : u.value.readOnly ? "transparent" : q.value === te || w.value === te ? o.current.value.colors.primary : "transparent"), z = I(() => [(Q) => !l.modelValue.children.some((te) => te.key === Q), (Q) => !Q || !!l.modelValue.layout.indexed?.some((te) => Q.match(Au(te)))]), X = (Q) => {
      Q || l.statefulLayout.deactivateItem(l.modelValue);
    };
    return (Q, te) => (oe(), ye(Y(Lh), re(Y(a), {
      loading: e.modelValue.loading
    }), {
      default: le(() => [
        C(Y(Sr), Gt(oa(Y(i))), {
          default: le(() => [
            e.modelValue.layout.title ? (oe(), ye(Y(kn), { key: 0 }, {
              default: le(() => [
                Fe(Ue(e.modelValue.layout.title), 1)
              ]),
              _: 1
            })) : Ve("", !0),
            (oe(!0), De(pe, null, pt(Y(g), (N, R) => (oe(), De(pe, {
              key: d.value.findIndex((G) => G === N)
            }, [
              C(Y(it), re({ ref_for: !0 }, Y(p)(R, Y(r)), {
                draggable: Y(h) === R,
                style: `border: 1px solid ${F.value(N, R)}`,
                class: "vjsf-list-item"
              }), Yo({
                default: le(() => [
                  j.value?.[R] ? (oe(), ye(Y(Bo), {
                    key: 0,
                    class: "pl-4 pt-2"
                  }, {
                    default: le(() => [
                      Fe(Ue(j.value?.[R]), 1)
                    ]),
                    _: 2
                  }, 1024)) : e.modelValue.layout.indexed ? (oe(), ye(Y(Bo), {
                    key: 1,
                    class: "pl-4 pt-2"
                  }, {
                    default: le(() => [
                      Fe(Ue(N.key), 1)
                    ]),
                    _: 2
                  }, 1024)) : Ve("", !0),
                  H.value?.[R] ? (oe(), ye(Y(Oh), {
                    key: 2,
                    class: "pl-4 pt-2"
                  }, {
                    default: le(() => [
                      Fe(Ue(H.value?.[R]), 1)
                    ]),
                    _: 2
                  }, 1024)) : Ve("", !0),
                  C(Y(sa), { class: "ma-0" }, {
                    default: le(() => [
                      (oe(!0), De(pe, null, pt(Y(Ea)(N) ? N.children : [N], (G) => (oe(), ye(la, {
                        key: G.fullKey,
                        "model-value": (
                          /** @type import('../../types.js').VjsfNode */
                          G
                        ),
                        "stateful-layout": e.statefulLayout
                      }, null, 8, ["model-value", "stateful-layout"]))), 128))
                    ]),
                    _: 2
                  }, 1024)
                ]),
                _: 2
              }, [
                !e.modelValue.options.readOnly && e.modelValue.layout.listActions.length ? {
                  name: "append",
                  fn: le(() => [
                    D("div", ax, [
                      q.value !== R ? (oe(), ye(Y(Zi), { key: 0 }, {
                        default: le(() => [
                          C(Y(Te), {
                            style: { visibility: "hidden" },
                            variant: "text",
                            density: K.value,
                            icon: u.value.icons.edit,
                            disabled: e.modelValue.loading
                          }, null, 8, ["density", "icon", "disabled"])
                        ]),
                        _: 1
                      })) : e.modelValue.layout.listActions.includes("edit") && e.modelValue.layout.listEditMode === "inline-single" && _.value === R ? (oe(), ye(Y(Zi), { key: 1 }, {
                        default: le(() => [
                          C(Y(Te), {
                            title: e.modelValue.messages.close,
                            icon: u.value.icons.edit,
                            variant: "flat",
                            color: "primary",
                            density: K.value,
                            disabled: e.modelValue.loading,
                            onClick: te[0] || (te[0] = (G) => e.statefulLayout.deactivateItem(e.modelValue))
                          }, null, 8, ["title", "icon", "density", "disabled"])
                        ]),
                        _: 1
                      })) : w.value === R ? (oe(), ye(Y(Zi), { key: 2 }, {
                        default: le(() => [
                          C(Y(Te), re({
                            title: e.modelValue.messages.sort,
                            icon: u.value.icons.sort,
                            variant: "flat",
                            color: "primary",
                            density: K.value,
                            disabled: e.modelValue.loading
                          }, { ref_for: !0 }, Y(b)(R)), null, 16, ["title", "icon", "density", "disabled"])
                        ]),
                        _: 2
                      }, 1024)) : (_.value === void 0 || e.modelValue.layout.listEditMode === "menu") && e.modelValue.layout.listActions.length ? (oe(), ye(Y(Zi), { key: 3 }, {
                        default: le(() => [
                          C(Y(La), {
                            location: "bottom end",
                            "z-index": Y(S),
                            density: e.modelValue.options.density,
                            "close-on-content-click": !1,
                            "model-value": P.value === R,
                            "onUpdate:modelValue": (G) => M(R, G)
                          }, {
                            activator: le(({ props: G }) => [
                              C(Y(Te), re({ ref_for: !0 }, G, {
                                icon: u.value.icons.menu,
                                variant: "plain",
                                slim: "",
                                disabled: e.modelValue.loading,
                                density: K.value
                              }), null, 16, ["icon", "disabled", "density"])
                            ]),
                            default: le(() => [
                              C(Y(Sr), {
                                density: e.modelValue.options.density
                              }, {
                                default: le(() => [
                                  e.modelValue.layout.listActions.includes("edit") && e.modelValue.layout.listEditMode !== "inline" ? (oe(), De(pe, { key: 0 }, [
                                    c.value.listEditMode === "menu" ? (oe(), ye(Y(La), re({
                                      key: 0,
                                      location: "start",
                                      "z-index": Y(S),
                                      density: e.modelValue.options.density,
                                      "model-value": _.value !== void 0,
                                      "close-on-content-click": !1
                                    }, { ref_for: !0 }, Y(s), {
                                      width: e.modelValue.options.listMenuWidth,
                                      "onUpdate:modelValue": te[1] || (te[1] = (G) => G || e.statefulLayout.deactivateItem(e.modelValue))
                                    }), {
                                      activator: le(({ props: G }) => [
                                        C(Y(it), re({
                                          density: e.modelValue.options.density,
                                          "base-color": "primary"
                                        }, { ref_for: !0 }, G, {
                                          onClick: (ae) => {
                                            e.statefulLayout.activateItem(e.modelValue, R);
                                          }
                                        }), {
                                          prepend: le(() => [
                                            C(Y(xe), {
                                              icon: u.value.icons.edit
                                            }, null, 8, ["icon"])
                                          ]),
                                          default: le(() => [
                                            Fe(" " + Ue(e.modelValue.messages.edit), 1)
                                          ]),
                                          _: 1
                                        }, 16, ["density", "onClick"])
                                      ]),
                                      default: le(() => [
                                        C(Y(pa), null, {
                                          default: le(() => [
                                            C(Y(sa), { class: "ma-0" }, {
                                              default: le(() => [
                                                (oe(!0), De(pe, null, pt(Y(Ea)(d.value[d.value.length - 1]) ? d.value[d.value.length - 1].children : [d.value[d.value.length - 1]], (G) => (oe(), ye(la, {
                                                  key: G.fullKey,
                                                  "model-value": (
                                                    /** @type import('../../types.js').VjsfNode */
                                                    G
                                                  ),
                                                  "stateful-layout": e.statefulLayout
                                                }, null, 8, ["model-value", "stateful-layout"]))), 128))
                                              ]),
                                              _: 1
                                            })
                                          ]),
                                          _: 1
                                        })
                                      ]),
                                      _: 2
                                    }, 1040, ["z-index", "density", "model-value", "width"])) : (oe(), ye(Y(it), {
                                      key: 1,
                                      density: e.modelValue.options.density,
                                      "base-color": "primary",
                                      onClick: (G) => {
                                        e.statefulLayout.activateItem(e.modelValue, R), P.value = -1;
                                      }
                                    }, {
                                      prepend: le(() => [
                                        C(Y(xe), {
                                          icon: u.value.icons.edit
                                        }, null, 8, ["icon"])
                                      ]),
                                      default: le(() => [
                                        Fe(" " + Ue(e.modelValue.messages.edit), 1)
                                      ]),
                                      _: 1
                                    }, 8, ["density", "onClick"]))
                                  ], 64)) : Ve("", !0),
                                  e.modelValue.layout.listActions.includes("duplicate") ? (oe(), ye(Y(it), {
                                    key: 1,
                                    onClick: (G) => E(N, R)
                                  }, {
                                    prepend: le(() => [
                                      C(Y(xe), {
                                        icon: u.value.icons.duplicate
                                      }, null, 8, ["icon"])
                                    ]),
                                    default: le(() => [
                                      Fe(" " + Ue(e.modelValue.messages.duplicate), 1)
                                    ]),
                                    _: 1
                                  }, 8, ["onClick"])) : Ve("", !0),
                                  e.modelValue.layout.listActions.includes("copy") ? (oe(), ye(Y(it), {
                                    key: 2,
                                    onClick: (G) => $(N)
                                  }, {
                                    prepend: le(() => [
                                      C(Y(xe), {
                                        icon: u.value.icons.copy
                                      }, null, 8, ["icon"])
                                    ]),
                                    default: le(() => [
                                      Fe(" " + Ue(e.modelValue.messages.copy), 1)
                                    ]),
                                    _: 1
                                  }, 8, ["onClick"])) : Ve("", !0),
                                  e.modelValue.layout.listActions.includes("sort") && Y(v) ? (oe(), ye(Y(it), {
                                    key: 3,
                                    disabled: e.modelValue.data.length === 1,
                                    onClick: (G) => k(R)
                                  }, {
                                    prepend: le(() => [
                                      C(Y(xe), {
                                        icon: u.value.icons.sort
                                      }, null, 8, ["icon"])
                                    ]),
                                    default: le(() => [
                                      Fe(" " + Ue(e.modelValue.messages.sort), 1)
                                    ]),
                                    _: 1
                                  }, 8, ["disabled", "onClick"])) : Ve("", !0),
                                  e.modelValue.layout.listActions.includes("sort") ? (oe(), ye(Y(it), {
                                    key: 4,
                                    disabled: R === 0,
                                    onClick: (G) => {
                                      e.statefulLayout.input(e.modelValue, Y(Wm)(e.modelValue.data, R, R - 1)), P.value = -1;
                                    }
                                  }, {
                                    prepend: le(() => [
                                      C(Y(xe), {
                                        icon: u.value.icons.sortUp
                                      }, null, 8, ["icon"])
                                    ]),
                                    default: le(() => [
                                      Fe(" " + Ue(e.modelValue.messages.up), 1)
                                    ]),
                                    _: 1
                                  }, 8, ["disabled", "onClick"])) : Ve("", !0),
                                  e.modelValue.layout.listActions.includes("sort") ? (oe(), ye(Y(it), {
                                    key: 5,
                                    disabled: R === e.modelValue.data.length - 1,
                                    onClick: (G) => {
                                      e.statefulLayout.input(e.modelValue, Y(Wm)(e.modelValue.data, R, R + 1)), P.value = -1;
                                    }
                                  }, {
                                    prepend: le(() => [
                                      C(Y(xe), {
                                        icon: u.value.icons.sortDown
                                      }, null, 8, ["icon"])
                                    ]),
                                    default: le(() => [
                                      Fe(" " + Ue(e.modelValue.messages.down), 1)
                                    ]),
                                    _: 1
                                  }, 8, ["disabled", "onClick"])) : Ve("", !0),
                                  e.modelValue.layout.listActions.includes("delete") ? (oe(), ye(Y(it), {
                                    key: 6,
                                    "base-color": "warning",
                                    onClick: (G) => J(R)
                                  }, {
                                    prepend: le(() => [
                                      C(Y(xe), {
                                        icon: u.value.icons.delete
                                      }, null, 8, ["icon"])
                                    ]),
                                    default: le(() => [
                                      Fe(" " + Ue(e.modelValue.messages.delete), 1)
                                    ]),
                                    _: 1
                                  }, 8, ["onClick"])) : Ve("", !0),
                                  T.value ? (oe(), ye(Y(it), { key: 7 }, {
                                    default: le(() => [
                                      C(Y(yr)),
                                      C(Y(Te), {
                                        color: "warning",
                                        class: "float-right ma-1",
                                        onClick: (G) => A(R)
                                      }, {
                                        default: le(() => [
                                          Fe(Ue(e.modelValue.messages.confirm), 1)
                                        ]),
                                        _: 1
                                      }, 8, ["onClick"])
                                    ]),
                                    _: 2
                                  }, 1024)) : Ve("", !0)
                                ]),
                                _: 2
                              }, 1032, ["density"])
                            ]),
                            _: 2
                          }, 1032, ["z-index", "density", "model-value", "onUpdate:modelValue"])
                        ]),
                        _: 2
                      }, 1024)) : Ve("", !0)
                    ])
                  ]),
                  key: "0"
                } : void 0
              ]), 1040, ["draggable", "style"]),
              R < e.modelValue.children.length - 1 ? (oe(), ye(Y(ia), { key: 0 })) : Ve("", !0)
            ], 64))), 128)),
            !e.modelValue.options.readOnly && (e.modelValue.layout.listActions.includes("add") || e.modelValue.layout.listActions.includes("paste")) ? (oe(), ye(Y(it), {
              key: 1,
              class: "py-2"
            }, {
              default: le(() => [
                e.modelValue.layout.indexed ? (oe(), De(pe, { key: 0 }, [
                  e.modelValue.layout.listActions.includes("add") ? (oe(), ye(Y(SC), {
                    key: 0,
                    ref_key: "newKeyForm",
                    ref: U,
                    style: { "max-width": "250px" },
                    onSubmit: te[4] || (te[4] = yy(() => {
                    }, ["prevent"]))
                  }, {
                    default: le(() => [
                      e.modelValue.layout.getItems ?? e.modelValue.layout.items ? (oe(), ye(ex, {
                        key: 0,
                        modelValue: O.value,
                        "onUpdate:modelValue": [
                          te[2] || (te[2] = (N) => O.value = N),
                          Z
                        ],
                        "list-node": e.modelValue,
                        "stateful-layout": e.statefulLayout,
                        rules: z.value
                      }, null, 8, ["modelValue", "list-node", "stateful-layout", "rules"])) : (oe(), ye(Y(Dt), {
                        key: 1,
                        modelValue: O.value,
                        "onUpdate:modelValue": te[3] || (te[3] = (N) => O.value = N),
                        variant: "outlined",
                        placeholder: e.modelValue.messages.addItem,
                        "hide-details": "",
                        rules: z.value,
                        onKeypress: gy(Z, ["enter"])
                      }, {
                        append: le(() => [
                          C(Y(xe), {
                            color: "primary",
                            size: "large",
                            icon: u.value.icons.add,
                            onClick: Z
                          }, null, 8, ["icon"])
                        ]),
                        _: 1
                      }, 8, ["modelValue", "placeholder", "rules"]))
                    ]),
                    _: 1
                  }, 512)) : Ve("", !0)
                ], 64)) : (oe(), De(pe, { key: 1 }, [
                  e.modelValue.layout.listActions.includes("add") ? (oe(), ye(Y(Te), {
                    key: 0,
                    color: "primary",
                    "prepend-icon": u.value.icons.add,
                    class: "mr-2",
                    onClick: L
                  }, {
                    default: le(() => [
                      Fe(Ue(e.modelValue.messages.addItem), 1)
                    ]),
                    _: 1
                  }, 8, ["prepend-icon"])) : Ve("", !0),
                  e.modelValue.layout.listActions.includes("paste") && Y(x) !== null ? (oe(), ye(Y(Te), {
                    key: 1,
                    color: "primary",
                    "prepend-icon": u.value.icons.paste,
                    onClick: V
                  }, {
                    default: le(() => [
                      Fe(Ue(e.modelValue.messages.paste), 1)
                    ]),
                    _: 1
                  }, 8, ["prepend-icon"])) : Ve("", !0)
                ], 64))
              ]),
              _: 1
            })) : Ve("", !0),
            c.value.listEditMode === "dialog" ? (oe(), ye(Y(QP), re({
              key: 2,
              "model-value": _.value !== void 0
            }, Y(n), {
              width: u.value.listDialogWidth,
              "z-index": Y(S),
              class: "vjsf-list-dialog",
              "onUpdate:modelValue": X
            }), {
              default: le(({ isActive: N }) => [
                C(Y(pa), Gt(oa(Y(t))), {
                  default: le(() => [
                    C(Y(GP), {
                      density: "compact",
                      color: "surface",
                      class: "vjsf-list-dialog-toolbar"
                    }, {
                      default: le(() => [
                        C(Y(yr)),
                        C(Y(Te), {
                          title: e.modelValue.messages.close,
                          icon: u.value.icons.close,
                          variant: "flat",
                          density: "comfortable",
                          disabled: e.modelValue.loading,
                          onClick: (R) => N.value = !1
                        }, null, 8, ["title", "icon", "disabled", "onClick"])
                      ]),
                      _: 2
                    }, 1024),
                    C(Y(sa), { class: "ma-0" }, {
                      default: le(() => [
                        (oe(!0), De(pe, null, pt(Y(Ea)(d.value[d.value.length - 1]) ? d.value[d.value.length - 1].children : [d.value[d.value.length - 1]], (R) => (oe(), ye(la, {
                          key: R.fullKey,
                          "model-value": (
                            /** @type import('../../types.js').VjsfNode */
                            R
                          ),
                          "stateful-layout": e.statefulLayout
                        }, null, 8, ["model-value", "stateful-layout"]))), 128))
                      ]),
                      _: 1
                    })
                  ]),
                  _: 2
                }, 1040)
              ]),
              _: 1
            }, 16, ["model-value", "width", "z-index"])) : Ve("", !0)
          ]),
          _: 1
        }, 16)
      ]),
      _: 1
    }, 16, ["loading"]));
  }
}, rx = dt({
  props: {
    modelValue: {
      /** @type import('vue').PropType<import('../../types.js').VjsfFileInputNode> */
      type: Object,
      required: !0
    },
    statefulLayout: {
      /** @type import('vue').PropType<import('../../types.js').VjsfStatefulLayout> */
      type: Object,
      required: !0
    }
  },
  setup(e) {
    Ge({}, "VjsfFileInput");
    const { inputProps: a, localData: i, compSlots: r } = mt(
      W(e, "modelValue"),
      e.statefulLayout,
      { layoutPropsMap: ["placeholder", "accept", "multiple"] }
    ), n = I(() => {
      const t = { ...a.value };
      return t.multiple && console.error("File input doesn't support multiple inputs yet"), t["onUpdate:modelValue"] = (s) => {
        e.statefulLayout.input(e.modelValue, s);
      }, t;
    });
    return () => Oe(kC, { ...n.value, modelValue: i.value }, r.value);
  }
}), ix = {
  __name: "card",
  props: {
    modelValue: {
      /** @type import('vue').PropType<import('../../types.js').VjsfCardNode> */
      type: Object,
      required: !0
    },
    statefulLayout: {
      /** @type import('vue').PropType<import('../../types.js').VjsfStatefulLayout> */
      type: Object,
      required: !0
    }
  },
  setup(e) {
    Ge({}, "VjsfCard");
    const a = I(() => ({
      title: e.modelValue.layout.title || void 0,
      ...e.modelValue.props
    }));
    return (i, r) => (oe(), ye(Y(Lh), Gt(oa(a.value)), {
      default: le(() => [
        C(Y(jr), { fluid: "" }, {
          default: le(() => [
            C(Yn, {
              node: e.modelValue,
              "hide-title": ""
            }, null, 8, ["node"]),
            C(Y(sa), {
              dense: e.modelValue.options?.density === "compact" || e.modelValue.options?.density === "comfortable"
            }, {
              default: le(() => [
                (oe(!0), De(pe, null, pt(e.modelValue.children, (n) => (oe(), ye(la, {
                  key: n.fullKey,
                  "model-value": (
                    /** @type import('../../types.js').VjsfNode */
                    n
                  ),
                  "stateful-layout": e.statefulLayout
                }, null, 8, ["model-value", "stateful-layout"]))), 128))
              ]),
              _: 1
            }, 8, ["dense"])
          ]),
          _: 1
        })
      ]),
      _: 1
    }, 16));
  }
}, lx = {
  __name: "vjsf",
  props: {
    schema: {
      type: Object,
      required: !0
    },
    precompiledLayout: {
      /** @type import('vue').PropType<import('@json-layout/core').CompiledLayout> */
      type: Object,
      default: null
    },
    modelValue: {
      type: null,
      default: null
    },
    options: {
      /** @type import('vue').PropType<import('../types.js').PartialVjsfOptions | null> */
      type: Object,
      default: null
    }
  },
  emits: Y$,
  setup(e, { emit: a }) {
    const i = {
      section: J$,
      "text-field": m1,
      textarea: h1,
      checkbox: w1,
      switch: $1,
      "number-field": E1,
      slider: B1,
      "date-picker": J1,
      "time-picker": s_,
      "date-time-picker": w_,
      "color-picker": uP,
      select: qC,
      autocomplete: zC,
      "radio-group": BC,
      "checkbox-group": FC,
      "switch-group": KC,
      "one-of-select": HC,
      tabs: WC,
      "vertical-tabs": YC,
      "expansion-panels": JC,
      stepper: QC,
      list: nx,
      combobox: XC,
      "number-combobox": ZC,
      "file-input": rx,
      card: ix
    }, r = e, n = a, { el: t, statefulLayout: s, stateTree: o } = X$(
      I(() => r.schema),
      I(() => r.modelValue),
      I(() => r.options),
      i,
      n,
      K0,
      F0,
      I(() => r.precompiledLayout)
    );
    return (l, u) => (oe(), De("div", {
      ref_key: "el",
      ref: t,
      class: "vjsf"
    }, [
      Y(s) && Y(o) ? (oe(), ye(v$, {
        key: 0,
        "model-value": Y(o),
        "stateful-layout": Y(s)
      }, null, 8, ["model-value", "stateful-layout"])) : Ve("", !0)
    ], 512));
  }
};
export {
  lx as Vjsf,
  lx as default,
  K$ as defaultIcons,
  H$ as defaultOptions
};
